 OPT UADE15 ; > Uade15
 TTL File server file UADE15


;*  C O M M A N D  P R O C E S S O R*

CMND

 JSR GETBB ;Get big buffer !

 JSR VSTRIN
 = CR,"Starting - "
 NOP


CLPA LDXIM MONON
 STX MONFLG ;Monitor ON to start with
 STX OTIME
 STX OTIME+1 ;timer timeout

;SET UP RXCB

 INX
 STX EVCHAR ;initialise event flag
 STX RIPPLE ;Rxcb counter

 JSR OPENRX ;open CB1

 LDA &220
 STA OLDEV
 LDA &220 + 1
 STA OLDEV + 1

 LDAIM EVENT
 STA &220
 LDAIM /(EVENT)
 STA &220 + 1

 LDAIM  14
 LDXIM  2 
 JSR OSBYTE ;enable KB event
 LDAIM  229 ;disable escape
 LDXIM  1 
 JSR OSBYTE

 JSR VSTRIN
 = "Ready",CR,CR,15
 NOP


 LDAIM 53
 JSR OSBYTE ;** 13/2/84 **
   ; sever any REMOTE connection now

 LDXIM PROT
 LDYIM /PROT
 LDAIM &13 ; Net OSWORD
 JSR OSWORD ; Set protection mask

CLPD   ;CLPD

; Poll KB and Rxcb's in the I/O processor

CPOLL0

 LDA EVCHAR ;look for event
 BEQ COMRTS
 LDXIM 0
 STX EVCHAR ;reset the flag
 CMPIM ESC
 BEQ DOCHDI
 ANDIM &DF ;force upper case
 CMPIM "M"
 BEQ DOMONT ;switch monitor status
 CMPIM "Q"
 BEQ DOQUIT ;call HALT 

;else fall through ..
;Now poll the control blocks using the MOS

COMRTS  ;come here for new command

 LDX RXTAB ;get number of CB to poll
 STX RXCBN ;save this for later use
 LDAIM 51 ;poll Rx number (X)
 JSR OSBYTE ;result returned in X
 TXA
 BMI DOCMND ;leap off to deal with the Rx'd packet
 JSR PRTIM ;** only call dongle every 30 or so seconds **
 JMP CPOLL0

DOCHDI   ;DOCHDI
 LDAIM &7E
 JSR OSBYTE ;acknowledge escape condition here
 JSR NOEVNT ;disable events
 LDAIM 8
 JSR SETRTN ;ensure free space table
 JSR USRMAN
 JSR CHDISC ;*** CHANGE DISC **
 JMP CLPA ;back to the start

DOQUIT   ;DOQUIT
 JSR NOEVNT ;disable events
 LDAIM 8 ;ensure all users free space ** 3/10/84 **
 JSR SETRTN
 JSR USRMAN ;no RC from this
 JSR FLUSYS
 LDXIM DOBYE
 LDYIM /DOBYE
 JSR OSCLI ;*bye the discs
 JMP INITCO ;Back to COMMAND prompt

DOBYE = "Bye",CR

DOMONT   ;DOMONT

;Switch monitor and go back to loop start.

 JSR VSTRIN
 = CR,"Monitor "
 NOP

 LDX MONFLG
 CPXIM MONOFF
 BEQ DOMONL
 JSR VSTRIN
 = "OFF"
 NOP
 LDAIM MONOFF
 JMP DOMONJ

DOMONL JSR VSTRIN
 = "ON"
 NOP
 LDAIM MONON
DOMONJ STA MONFLG

DBNCEX JSR OSCRLF
 JMP CLPD ;Go back to main RX loop

DOCMND   ;DOCMND

;Reception has happened, so check
;the function code in the RXbuffer
;and jump to the operation.

 LDA RXCBN ;save CB number
 PHA ;altered in OPENRX
 JSR OPENRX ;open a new Rxcb
 PLA ;RXTAB updated to new CB here
 STA RXCBN ;reset CB number

 LDXIM RXCBN
 LDYIM /(RXCBN)
 LDAIM &11 ;MOS interface
 JSR OSWORD ;read the control block

; the structure set up in RXCBV is of the form
; CB number (1) ;in RXCBN
; CB data (12)

; Thus QPTR is always zero as only one CB is
; read at any time

 LDAIM &00
 STA QPTR ;standard offset
 SEC
 LDA RXCBV + 4 ;get low byte of address
 SBCIM RXBUF ;calulate buffer offset
 STA BPTR ;point at the buffer
 TAX

 LDAAX RXBUF ;Reply port at top of buffer
 STA RPLYPT ;Store reply port

 LDA CBBUF
 STA OLDRXB ;STORE OLD BUFFER PTR.
 LDA CBBUF + 1
 STA OLDRXB + 1


;Provide p.0 pointer to control block (used
;in XMIT/REPLY etc.)

 CLC
 LDA QPTR
 ADCIM RXCBV
 STA NETCB
 LDAIM /(RXCBV)
 ADCIM  0
 STA NETCB + 1

 LDAAX RXBUF + 1 ;Get fn. code
 BEQ FCOK ;Don't monitor commands immediately

 PHA
 JSR MONITR ;*** Do monitor **
 PLA

 CMPIM FCMAX
 BCC FCOK ;Yes => ok

 LDAIM COERRA

;Send error return to machine

 JSR EXTERR

;Finish command (don't matter if error
;didn't get through).

 JMP COMRTS

FCOK   ;FCOK

;FN. code is ok, so get routine entry address

 ASLA
 TAX
 LDAAX FNTAB
 STA GENPTR
 LDAAX FNTAB + 1
 STA GENPTR + 1
 LDY BPTR


;ENTER ROUTINE ..

 JMI GENPTR



;T A B L E S

CTABA   ;CTABA

;Initial receive control block
;Top four bytes

 = RXFLAG
 = COPORT ;Command port
 =  0
 =  0 ;Set to RX on any station

FNTAB   ;FNTAB

;Addresses of functions

 & CLINE ;Decode command line
 & SAVE   ;1
 & LOAD   ;2
 & EXAMIN ;3
 & CATHDR ;4
 & LOAD ;Load command for execution
 & FIND   ;6
 & CPSHUT ;7
 & GETBYT ;8
 & PUTBYT ;9
 & GBYTES ;10
 & PBYTES ;11
 & CPRDAR ;=> GETARGS
 & CPSTAR ;=> SETARGS
 & DISCS  ;14
 & CPUSRS ;15
 & CPDATE ;16
 & CPEOF  ;17
 & CPINFO ;18
 & CPSTAT ;Set object attributes
 & CPDEL ;Delete from fn. code
 & USRENV ;21
 & CPSOPT ;Set user option bits
 & FCBYE ;Logoff by function code
 & CPUINF ;Single user info.
 & CPVERN ;25
 & CPSPAC ;26 - returns disc free space
 & CDIRFN ;27 - cdir from function code, specify size
 & CPSETD ;28 - Set date and time from program
 & SAVE ; 29 - Do a 'create', like 'save' but no data
 & RDFREE ;30 - read callers free space
 & WRFREE ;31 - write users free space

;COMMAND LINE DECODER ....


COMTAB = "CAT"
 = CLIDLM
 & /(CAT)
 = "DELETE"
 = CLIDLM
 & /(DELETE)
 = "INFO"
 = CLIDLM
 & /(INFO)
 = "LOAD"
 = CLIDLM
 & /(DOLOAD)
 = "SAVE"
 = CLIDLM
 & /(DOSAVE)
 = "DIR"
 = CLIDLM
 & /(SELDIR)
 = "SDISC"
 = CLIDLM
 & /(SELDSC)
 = "CDIR"
 = CLIDLM
 & /(CDIR)
 = "ACCESS"
 = CLIDLM
 & /(SETACC)
 = "PASS"
 = CLIDL1 
 & /(SETPW)
 = "I AM"
 = CLIDL1
 & /(LOGON)
 = "BYE"
 = CLIDLM
 & /(USROFF)
 = "NEWUSER"
 = CLIDLM
 & /(NEWUSE)
 = "PRIV"
 = CLIDLM
 & /(STPRIV)
 = "LIB"
 = CLIDLM
 & /(SLIB)
 = "REMUSER"
 = CLIDLM
 & /(REMUSE)
 = "RENAME"
 = CLIDLM
 & /(RENAME)
 =  0 ;Indicates table end


CLINE LDXIM &FF
 CLD
THUNK LDY BPTR
 JSR SPACES
 DEY
FIRCH INY
 INX
 LDAAX COMTAB
 BEQ BADCOM ;Last delimiter is zero
 CMPIM CLIDL1
 BEQ CHKLST
 CMPIM CLIDLM
 BEQ CHKLST ;Check next char after command is non-alpha
 EORAY MIDRX ;Compare
 ANDIM &DF ;Force cases
 BEQ FIRCH
 DEX
MINUS INX
 LDAAX COMTAB
 CMPIM CLIDL1
 BEQ MINUS1
 CMPIM CLIDLM
 BNE MINUS
MINUS1 INX  ;Get past CLIDLM
 INX
 LDAAY MIDRX
 CMPIM "."
 BNE THUNK
 INY
 DEX ;Point to address
 DEX
 BCS FINISH ;Always jump

CHKLST LDAAY MIDRX ;Otherwise check char. after cmnd. is non-alpha
 JSR ISCHAR
 BCS FINISH ;Is non-alpha => end of command
 INX
 INX ;Inc. past CLIDLM and address
 BCC THUNK ;Always jump

FINISH LDAAX COMTAB ;Check if is to be monitored or not
 CMPIM CLIDL1
 BEQ CLINE3 ;Non-monitor command (LOGON and PASS)

 TXA
 PHA ;Store table offset
 LDAIM  0 ;Set function code
 STY COTEMP ;Store command line pointer
 LDY QPTR ;Point to receive buffer
 JSR MONITR ;Do monitor message
 LDY COTEMP ;Restore command line pointer
 PLA
 TAX ;Restore table offset

CLINE3 LDAAX COMTAB + 1 ;Set jump addresses
 STA GENPTR + 1
 LDAAX COMTAB + 2
 STA GENPTR


 CLC
 LDXIM  0
 JMI GENPTR


BADCOM

;UNRECOGNISED COMMAND

 JSR BUFTXT
 BNE BDEXIT ;Quotes error
 LDXIM  0 ;Now move from TXTBUF to TXBUF
BCLOOP LDAAX TXTBUF
 STAAX MIDTX
 INX
 CMPIM CR
 BNE BCLOOP

 CPXIM  1
 BNE BCONA
 LDAIM WOTERR
 JSR EXTERR ;Do WHAT? error immediately
 JMP BDEXIT
BCONA TXA
 CLC
 ADCIM TXHDR ;Message length
 LDYIM CCCMND
 STY CCODE
 JSR REPLYC
BDEXIT JMP COMRTS




MONITR   ;MONITR

 BIT MONFLG
 BPL MONEX ;bit7=0 -> no monitor

 LDXIM MONTL ;length of the 'monitored' function codes table
 
MON1 CMPAX MONT1 ;look for function match
 BEQ MON2 ;found one
 DEX
 BPL MON1 ;if fall thru' then exit
MONEX RTS

MON2 STX COTEMP+1 ;save this for later use
 JSR PRTMC ;print the machine number

 JSR VSTRIN
 = ": "
 NOP

 LDYIM 0
 LDX COTEMP+1
 BEQ MON11 ;CLI here

MON3 LDAAY MONT3 ;read though the text
 BEQ MON4 ;count the number so far
 INY
 BNE MON3
MON4 INY
 DEX
 BNE MON3
 LDX COTEMP+1

MON5 LDAAY MONT3 ;now at the correct operation
 BEQ MON6
 JSR WRCH ;print ascii chars only
 INY ;step thru'
 BNE MON5 ;stop on zero 

MON6 JSR MONOUT ;print a space
MON11 LDAAX MONT2 ;determine objectname offset (if any)
 BMI MON9 ;none here

 CLC
 ADC BPTR
 TAY ;Y has offset within the buffer

MON7 LDAAY MIDRX ;get chars from Rx buffer
 CMPIM CR ;end of name
 BEQ MON8
 JSR WRCH ;print the name
 INY
 BNE MON7

MON8 JSR MONOUT ;print another space

MON9 LDAAX MONT4 ;determine size offset (if any)
 BMI MON10
 CLC
 ADC BPTR
 TAY ;Y has offset within the buffer

 LDAAY MIDRX+2
 JSR WHEX
 LDAAY MIDRX+1
 JSR WHEX
 LDAAY MIDRX
 JSR WHEX

MON10 JMP OSCRLF


WRCH CMPIM &7F
 BCS MONEX
 CMPIM &20
 BCC MONEX
 JMP OSASCI ;print ascii characters

MONT1 = 0,1,2,5,20,23,27,29 ;function codes
MONT2 = 0,11,0,0,0,-1,1,11 ;name offsets
MONT3
 = 0 ;CLI here
 = "Save",0
 = "Load",0
 = "Run",0
 = "Delete",0
 = "Bye",0
 = "Cdir",0
 = "Create",0
MONT4 = -1,8,-1,-1,-1,-1,-1,8 ;length offsets
MONTL * MONT2-MONT1-1



 [ 1=0
PRTMC   ;PRTMC

;Print machine number.

 LDA CBSTID + 1
 BEQ PRMCLA ;Net. no. = 0
 JSR WRTDEC
 JMP PRMCLB
PRMCLA JSR VSTRIN
 = "   "
 NOP
PRMCLB LDAIM SPACE
 JSR OSWRCH
 LDA CBSTID

WRTDEC STA TEMPA
 LDAIM  0
 STA TEMPB
 TXA
 PHA
 TYA
 PHA
 LDXIM "/" ;Hundreds
 LDA TEMPA
 SEC
WRTDLA SBCIM &64
 INX
 BCS WRTDLA
 ADCIM &64
 PHA
 TXA
 JSR WRTDIG
 LDXIM "/" ;Tens
 PLA
 SEC
WRTDLB SBCIM &A
 INX
 BCS WRTDLB
 ADCIM &A
 PHA
 TXA
 JSR WRTDIG
 DEC TEMPB
 PLA
 CLC
 ADCIM "0"
 JSR WRTDIG
 PLA
 TAY
 PLA
 TAX
 RTS

 |

PRTMC LDXIM 4
 LDA CBSTID+1
 BEQ PRTMC1

 JSR MKDEC ;make decimal
 JSR PRTMC2 ;print the network number

 LDXIM 1
PRTMC1 LDAIM SPACE
 JSR OSWRCH
 DEX
 BNE PRTMC1 ;print spaces

 LDA CBSTID
 JSR MKDEC ;convert to decimal

PRTMC2
 LDA COWORK ;msig digit
 JSR OSWRCH
 LDA COWORK+1
 JSR OSWRCH
 LDA COWORK+2
 JMP OSWRCH ;print all three characters in COWORK

MKDEC
 TAY

 LDAIM -1
 STA TEMPA ;leading zero flag

 LDAIM 100
 JSR MKDEC1
 STA COWORK
 LDAIM 10
 JSR MKDEC1
 STA COWORK+1
 LDAIM 1

MKDEC1 STA COWORK+3
 TYA
 LDXIM "0"-1
 SEC

MKDEC2 INX
 SBC COWORK+3
 BCS MKDEC2
 ADC COWORK+3

 CPXIM "0"
 BNE MKDEC3
 BIT TEMPA
 BPL MKDEC3
 LDXIM SPACE
 BNE MKDEC4

MKDEC3 INC TEMPA ;print zeros
MKDEC4 TAY ;restore original parameter
 TXA
 STA COWORK+2 ;save this for now
 RTS

 ]

 [ 1=0
WRTDIG CMPIM "0"
 BNE WRTDIK
 BIT TEMPB
 BMI WRTDIM
 LDAIM SPACE
 BNE WRTDIM
WRTDIK DEC TEMPB ;Only works for 15 leading spaces
WRTDIM JMP OSWRCH
 ]

CHDISC   ;CHDISC

;1) READ DRIVE NUMBER (IF DRIVES>1)
;2) GET DISC NUMBER FOR DRIVE
;3) FLUSH ALL OBJECTS FROM STORE
;4) ENSURE DISC MAP
;5) RESTART (MAPMAN)
;6) RESTART (AUTMAN)

 LDA DRIVES
 SEC
 SBCIM  1
 BEQ CHDILA ;ONE DRIVE, CONTINUE

 JSR RDDRIV
 BNE CHDIQ ;IF QUIT TYPED, QUIT ** 13/9/84

CHDILA PHA  ;STORE DRIVE NO.
 JSR CHMSG ;"CHANGING DRIVE - ??"
 PLA
 STA CURDRV
 JSR DRVINF ;GET DISC NO.

 BNE CHDIAB ;ABORT IF ERROR

 LDAIM  8
 JSR SETRTN
 JSR STRMAN ;*** FLUSH STORE **
 BNE CHDIAB

 LDAIM  6
 JSR SETRTN
 JSR MAPMAN ;*** ENSURE DISC **
 BNE CHDIAB

CHDILB JSR CHMSGA ;"LOAD NEW DISC"
 BNE CHDIQ ;IF ABORT, ABORT ** 13/9/84 **

 LDA CURDRV
 LDYIM ARGB
 STAIY NEWARG
 LDAIM  9
 JSR SETRTN
 JSR MAPMAN ;*** RESTART DRIVE **
 BEQ CHDIOK ;ALL WELL, FINISH

 JSR USRERR ;ERROR, PRINT MESSAGE
 JMP CHDILB

CHDIOK JSR GETPWF ;Restart AUTMAN
 JSR VSTRIN
 = CR,"Restarting - "
 NOP

 RTS

CHDIAB JSR INTERR
CHDIQ JSR FLUSYS ;clear out the system
 JMP INITCO ;** 13/9/84 ** return to command prompt after abort


RDDRIV   ;RDDRIV

;READ DRIVE NUMBER FROM CMND. LINE

 JSR VSTRIN
 = CR,"Drive: "
 NOP

 JSR RDLINE

 LDYIM  0
 LDAIY COMPTR
 ANDIM &DF ;force upper case
 CMPIM ABTCH ;ABORT ?? "Q"
 BNE RDDONA ;** 13/9/84 **

 LDAIM &FF
 BNE RDDREX ;ABORT ...

RDDONA JSR GETINT ;GET DRIVE NO.
 BNE RDDRIV ;DO AGAIN IF NESC.

 LDA INTEGR + 1
 BNE RDDRIV

 LDA INTEGR
 CMP DRIVES
 BCS RDDRIV ;INTEGR>=DRIVES -> ERROR

 LDXIM  0 ;GIVE Z SET EXIT
RDDREX RTS



CHMSG   ;CHMSG

 PHA
 JSR VSTRIN
 = CR,"Changing drive - "
 NOP

 PLA
 JSR WHEX
 JMP OSCRLF



CHMSGA   ;CHMSGA

 JSR VSTRIN
 = CR,"Load new disc",CR
 NOP

CHMALP JSR OSECHO ;fudge around ESCAPE problem ** 28/9/84 **
 CMPIM SPACE
 BEQ CHMAEX
 ANDIM &DF ;force upper case ** 13/9/84 **
 CMPIM ABTCH
 BNE CHMALP

 LDAIM &FF ;GIVE ABORT EXIT

CHMAEX RTS



GETPWF

;Call AUTMAN restart and write message
;if PW file not found.

 LDAIM  6
 LDYIM ARGA
 STAIY NEWARG
 JSR AUTMAN
 BEQ GETPWX

 JSR VSTRIN
 = CR,"WARNING - PW File not found"
 NOP

GETPWX RTS

EVENT
 PHP ;save status over routine
 PHA
 CMPIM  2
 BNE EVENT1
 STY EVCHAR
 PLA
 PLP
 RTS

EVENT1
 PLA
 PLP
 JMI OLDEV ;unknown event

NOEVNT
 LDAIM  15
 LDXIM  0
 JSR OSBYTE ;flush buffer

 LDAIM  13
 LDXIM  2
 JSR OSBYTE ;disable event
 LDAIM  229
 LDXIM  0
 JSR OSBYTE ;re-enable escape

 LDA OLDEV
 STA &220
 LDA OLDEV + 1
 STA &220 + 1

 LDX RXCBN ;get CB number
 LDAIM  52
 JMP OSBYTE ;delete open CB

OPENRX LDXIM  4 ;Table offset
CLPC LDAAX CTABA
 STAAX RXCBV ;Set flag, port and stid.
 DEX
 BPL CLPC

 INX
 STX RXCBV + 6 ;Rx into parasite side of TUBE
 STX RXCBV + 7
 STX RXCBV + 10
 STX RXCBV + 11 ;fill in top bytes
 STX RXCBN ;ready for OSWORD call

;Now set buffer pointers. The start
;of a buffer for one cb. is 1+end of buffer fr
;previous cb (kept in TEMP). So the end address
;is stored in TEMP and incremented adter setting
;buffer pointers.
;The one byte gap between the buffers
;is to prevent corruption when a zero is placed
;at the end of received data to prevent
;catastrophe when a bad file name is being
;decoded.

 LDAIM RXBUF
 STA RXCBV+ 4
 LDAIM /(RXBUF)
 STA RXCBV + 5

 LDAIM RXBUF +RXBUFL
 STA RXCBV + 8
 LDAIM /(RXBUF +RXBUFL)
 STA RXCBV + 9

 LDA RIPPLE
 INC RIPPLE
 LSRA ;flag in carry

 BCC CONB

 LDAIM RXBUF +RXBUFL + 1
 STA RXCBV+ 4
 LDAIM /(RXBUF +RXBUFL + 1)
 STA RXCBV + 5

 LDAIM RXBUF +RXBUFL +RXBUFL + 1
 STA RXCBV + 8
 LDAIM /(RXBUF +RXBUFL +RXBUFL + 1)
 STA RXCBV + 9

CONB   ;CONB

;At this point, previous CB is set to receive.

 LDXIM RXCBN
 LDYIM /RXCBN
 LDAIM &11
 JSR OSWORD ;do OPENRX

 LDA RXCBN
 STA RXTAB ;save CB number
 BNE CONC

 LDAIM IERRAI ;unable to open Rxcb
 JMP INTERR

CONC RTS


 LNK UADE16
