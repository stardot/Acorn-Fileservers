
 OPT RMAN02 ;RNDMAN > Rman02
 TTL File server file RMAN02


;**************** RDRDCH ****************

;RDRDCH: read one byte from an open file

;Entry: ARGB = (LS) ptr to user info
;ARGC = (MS) ptr to user info
;ARGD = file handle
;ARGE = sequence no. (in LS bit)

;Exit:  ARGA = return code
;ARGB = byte read
;ARGC = end-of-file flag
;normally zero,
;#X80 if this is the last byte in file
;#XC0 if this is byte after end of file

;1) Get HANDTB entry from handle
;2) Check that object is a file
;3) Get RANDTB entry
;4) Compare sequence no. in ARGD with that
;in RANDTB entry.
;Same => old seq. file ptr := current SFP
;increment sequence no. in RANDTB entry
;Different => repeat of last read;
;current SFP := old SFP
;5) Check sequential file pointer against file size
;SFP =  size => return $FE and EOFFLG = $C0
;SFP >  size => end of file; return RC
;SFP <  size => OK
;6) Work out disc address of block containing
;required byte, and offset of byte in block.
;7) Find / get required block in cache (STRMAN)
;8) Fetch required byte and return it
;Increment current SFP in RANDTB

RDRDCH JSR INITRD ;GENPTR := user info; MCNUMB := machine no.
;[RNDPTR := rubbish]

 LDYIM ARGD
 LDAIY ARGPTR ;A := handle
 JSR FNDHND ;HNDPTR := HANDTB entry
 BNE RDRDCZ ;Not found - exit

 
 JSR SETRPT ;RTEPTR := RANDTB entry
 BNE RDRDCZ ;Not found (object not file)

 LDYIM HTMODE
 LDAIY HNDPTR ;check that file is open for input
 ANDIM READAC
 BNE RDRDCA
 LDAIM RDERRO ;file not open for input ** 15/11/84 **
 BNE RDRDCZ

RDRDCA JSR RDCSEQ ;Compare sequence numbers
;and choose file ptr; if equal
;then increment seq no.
 JSR RDCKEX ;Check SFP against file length
 BNE RDRDCZ ;End of file
 LDAIM &FE ;Byte after last
 BIT EOFFLG
 BVS RDRDLA ;Reading byte after last
;so return $FE


 JSR RDGBLK ;Get required block into cache
;GENPTR := store address
 BNE RDRDCZ ;error

;*** Assuming blocksize is 256 bytes ***
;Offset of required byte in block is given
;by LS byte of seq. file pointer.

 LDYIM RTCSFP
 LDAIY RTEPTR ;LS byte of SFP
 TAY
 LDAIY GENPTR ;Get required byte
RDRDLA LDYIM ARGB
 STAIY ARGPTR ;Return byte read
 INY
 LDA EOFFLG
 STAIY ARGPTR ;Return end-of-file flag

 JSR RDISFP ;Increment Current SFP

 LDAIM  0
RDRDCZ JMP RDEXIT ;Exit: Rc in A


;**************** RDWRCH ****************

;RDWRCH: write one byte to an open file

;Entry: ARGB = (LS) ptr to user info
;ARGC = (MS) ptr to user info
;ARGD = file handle
;ARGE = sequence no. (in LS bit)
;ARGF = byte to be written

;Exit:  ARGA = return code

;1) Get HANDTB entry from handle
;2) Check that object is a file
;3) Check file open for update
;4) Get RANDTB entry
;5) Compare sequence no. in ARGD with that
;in RANDTB entry.
;Same => old seq. file ptr := current SFP
;increment sequence no. in RANDTB entry
;Different => repeat of last read;
;current SFP := old SFP
;6) Check sequential file pointer against file size
;SFP >= size => end of file; extend file
;SFP <  size => OK
;7) Work out disc address of block containing
;required byte, and offset of byte in block.
;8) Find / get required block in cache (STRMAN)
;9) Write byte to cache; mark cache buffer dirty
;(but do not cause it to be written to disc: this will
;happen when the cache space is needed for
;something else, or when the file is closed.
;The cache buffer is left unlocked between
;calls of RDWRCH).
;10) IF SFP > HWM THEN HWM := SFP
;11) Increment current SFP

RDWRCH JSR INITRD ;GENPTR := user info; MCNUMB := machine no.
;[RNDPTR := rubbish]

 LDYIM ARGD
 LDAIY ARGPTR ;A := handle
 JSR FNDHND ;HNDPTR := HANDTB entry
 BNE RDWRCZ ;Not found - exit

 LDYIM HTMODE ;Check file open for update
 LDAIY HNDPTR ;Get mode
 ANDIM WRITAC ;Extract write access bit
 BNE RDWRCA ;OK to write

 LDAIM RDERRN ;"File not open for update"
 BNE RDWRCZ ;Always jumps

RDWRCA JSR SETRPT ;RTEPTR := RANDTB entry
 BNE RDWRCZ ;Not found (object not file)

 JSR RDCSEQ ;Compare sequence numbers
;and choose file ptr; if equal
;then increment seq no.
 JSR RDCKSP ;Check SFP against file length
 BIT EOFFLG ;If PTR = EXT, need to extend
 BVS RDWRCC ;V set => PTR = EXT => extend
 BEQ RDWRCB ;Otherwise, Z set if inside file
;so don't extend

RDWRCC

;Must extend file
;Allocate another block (1K bytes)

 LDAIM  0
 STA NEWFSZ ;Ls byte of new size
 LDAIM  4 ;Add 1K to 3-byte size
 CLC
 LDYIM RTFSZE + 1 ;CS byte of size
 ADCIY RTEPTR
 STA NEWFSZ + 1
 INY
 LDAIM  0
 ADCIY RTEPTR ;MS byte
 STA NEWFSZ + 2
 JSR RDCHSZ ;Change file size
 BNE RDWRCZ ;Error


RDWRCB JSR RDGBLK ;Get required block into cache
;GENPTR := store address
 BNE RDWRCZ ;error

;*** Assuming blocksize is 256 bytes ***
;Offset of required byte in block is given
;by LS byte of seq. file pointer.

 LDYIM ARGF
 LDAIY ARGPTR ;Byte to be written
 TAX  ;Save it
 LDYIM RTCSFP
 LDAIY RTEPTR ;LS byte of file pointer
 TAY
 TXA
 STAIY GENPTR ;Write byte to cache

 JSR MRKDRT ;Mark buffer dirty (addr in GENPTR)
 JSR RDISFP ;Increment Current SFP
 JSR RDSHWM ;Set high water mark

 LDAIM  0 ;Success

RDWRCZ JMP RDEXIT ;Return - RC in A



;****** RDRDAR ******

;RDRDAR: read RANDTB info on open file

;Entry: ARGB (LS) ptr to user info
;ARGC (MS) ptr to user info
;ARGD = file handle

;Exit:  ARGA = return code
;ARGB = (LS) Seq file ptr
;ARGC = (CS)  "   "    "
;ARGD = (MS   "   "    "
;ARGE = (LS) File high water mark
;ARGF = (CS)  "    "     "
;ARGG = (MS)  "    "     "
;ARGH = (LS) File size
;ARGI = (CS)  "    "
;ARGJ = (MS)  "    "

;The file handle is used to find the HANDTB
;entry, which points to the RANDTB entry
;from which the info is extracted.

RDRDAR JSR INITRD ;GENPTR:=ptr to user info
 LDYIM ARGD
 LDAIY ARGPTR ;A := handle
 JSR FNDHND ;HNDPTR := HANDTB entry
 BNE RDRDAZ ;Not found - exit

 JSR SETRPT ;RTEPTR := RANDTB entry
 BNE RDRDAZ ;Not found

;Return current seq file ptr

 LDYIM RTCSFP
 LDAIY RTEPTR ;LS byte of SFP
 LDYIM ARGB
 STAIY ARGPTR
 LDYIM RTCSFP + 1
 LDAIY RTEPTR ;CS byte
 LDYIM ARGC
 STAIY ARGPTR
 LDYIM RTCSFP + 2
 LDAIY RTEPTR ;MS
 LDYIM ARGD
 STAIY ARGPTR

;Copy 6 bytes from RANDTB entry to ARGPTR
;stack.  (The 2 fields are in the same
;order in each place).

 LDXIM  6 ;Loop count
 LDAIM ARGE ;1st stack offset
 STA RNDTMP ;Temp workspace
 LDYIM RTHWM ;Offset in RANDTB entry

RDRDAA LDAIY RTEPTR ;Get data from RANDTB
 STY RNDTMP + 1 ;Save RANDTB entry offset
 LDY RNDTMP ;Get stack offset
 STAIY ARGPTR ;Put data on stack
 INY
 STY RNDTMP ;Save next stack offset
 LDY RNDTMP + 1 ;Restore entry offset
 INY
 DEX  ;Loop count
 BNE RDRDAA ;Loop if not zero
 JSR RDCKSP ;check for EOF ** 26/5/83 **
 BEQ RDRDAJ ;skip except on error

 LDYIM ARGJ
 STY RNDTMP
 LDYIM ARGD
 LDXIM  2 ;copy size to pointer area
RDRDAK STY RNDTMP + 1
 LDY RNDTMP
 LDAIY ARGPTR ;move the data
 LDY RNDTMP + 1
 STAIY ARGPTR
 DEC RNDTMP
 DEY
 DEX
 BPL RDRDAK ;three bytes

RDRDAJ LDAIM  0 ;All copied - set RC

RDRDAZ JMP RDEXIT ;Return - RC in A



;****** RDSTAR ******

;RDSTAR: set sequential file ptr

;Entry: ARGB = (LS) ptr to user info
;ARGC = (MS)  "   "   "   "
;ARGD = file handle
;ARGE = arg saying what to set
;0: SFP
;1: HWM ** 5/9/84 **
;ARGF = (LS) New value to set
;ARGG = (CS)  "   "    "   "
;ARGH = (MS)  "   "    "   "
;ARGI = 4th byte if any

;Exit:  ARGA = return code

;The file handle is used to find the RANDTB entry.
;The arg in ARGE is inspected to find
;out what is being set.

RDSTAR JSR INITRD ;GENPTR -> user info
 LDYIM ARGD
 LDAIY ARGPTR ;A := handle
 JSR FNDHND ;HANDPTR := HANDTB entry
 BEQ RDSTAD ;OK

RDSTAE JMP RDSTAZ ;Exit

RDSTAD JSR SETRPT ;RTEPTR := RANDTB entry
 BNE RDSTAE ;Not found

;Inspect arg in ARGE

 LDYIM ARGE
 LDAIY ARGPTR
 LSRA
 BEQ RDSTAB ;0 => set SFP
            ;1 => set HWM

 LDAIM RDERRM ;"Bad arg to RDSTAR"
 JMP RDSTAZ

;Set seq file ptr

;IF newSFP < size THEN oldSFP = newSFP
;ELIF openforwriting THEN resize file: HWM = newSFP: oldSFP = newSFP
;ELSE IF newSFP <> size THEN error ELSE oldSFP = newSFP

RDSTAB BCS RDJHWM ;A = 1 => set extent of file
 SEC
 LDYIM ARGF
 LDAIY ARGPTR
 LDYIM RTFSZE
 SBCIY RTEPTR ;Do RNDTMP := SFP - size
 STA RNDTMP
 LDYIM ARGG
 LDAIY ARGPTR
 LDYIM RTFSZE + 1
 SBCIY RTEPTR
 STA RNDTMP + 1
 LDYIM ARGH
 LDAIY ARGPTR
 LDYIM RTFSZE + 2
 SBCIY RTEPTR
 ORA RNDTMP
 ORA RNDTMP + 1
 BCC RDSTAF ;Set SFP = new SFP size > SFP

;Here SFP => size, so attempt to point
;outside file. If open for update, resize
;else if SFP <> size then error else set SFP = new SFP

RDSTAA PHP ;Push Z flag indicating SFP = size
 LDYIM HTMODE
 LDAIY HNDPTR ;Mode handle opened for
 ANDIM WRITAC ;Check if open for writing
 BNE RDSTAG ;Yes, so resize

 PLP ;Not open for writing, so check if SFP=size
 BEQ RDSTAF ;Yes, so set SFP
 LDAIM RDERRL ;No => "attempt to point outside file"
 BNE RDSTAZ ;Error exit

RDSTAG PLP ;Restore stack, and resize file
 LDYIM ARGH
 LDAIY ARGPTR ;Set NEWFSZ to seq. ptr.
 STA NEWFSZ + 2
 DEY
 LDAIY ARGPTR
 STA NEWFSZ + 1
 DEY
 LDAIY ARGPTR
 STA NEWFSZ
 JSR RDCHSZ ;Change size of file
 BNE RDSTAZ ;Error => exit

 LDAIM ARGF
 STA OFF1
 LDAIM RTHWM
 STA OFF2 ;Having resized file, set HWM to ptr. value
 JSR MOVRND

RDSTAF

;Copy SFP into RANDTB

 LDAIM ARGF
 STA OFF1
 LDAIM RTCSFP
 STA OFF2
 JSR MOVRND ;Set current seq. ptr.
 LDAIM RTOSFP ;Set old seq. ptr. as well
 STA OFF2
 JSR MOVRND
 LDAIM  0 ;Return code

RDSTAZ JMP RDEXIT ;Return - RC in A


RDJHWM
 LDYIM HTMODE
 LDAIY HNDPTR
 ANDIM WRITAC
 BNE RDJHW2 ;open for update

 LDAIM RDERRN ;not open for update
 BNE RDSTAZ 

RDJHW2

 LDYIM ARGF
 LDXIM -3
RDJHW1 LDAIY ARGPTR
 STAAX NEWFSZ - :LSB:(-3)
 INY
 INX
 BNE RDJHW1

 LDYIM RTHWM+2
 LDXIM 2
RDJHW4 LDAIY RTEPTR
 CMPAX NEWFSZ
 BNE RDJHW5
 DEY
 DEX
 BPL RDJHW4

;exactly the same size so NOP here

 BMI RDJHW9 ;exit, all ok 

RDJHW5 LDYIM RTHWM
 LDAIY RTEPTR
 STA TEMPA ;save current extent
 ROLA
 STA TEMPB ;save carry as well

;C=0 => extending the file

 RORA
 BCC RDJHWA

;if decreasing file then must flush all blocks
;else cache may be left with antiquated data

 LDAIM 5
 JSR SETRTN
 JSR RDDSIN
 JSR STRMAN ;flush all blocks
 BNE RDJHWX

RDJHWA JSR RDCHSZ ;call changesize
 BNE RDSTAZ

 ROR TEMPB ;restore the carry

 [ 1=0
 BCS RDJHW9 ; exit all ok
 JSR RDDSIN ;put SIN and disc on stack

 LDYIM RTHWM
 STY TEMPA
 LDYIM ARGG ;two pointer locations
 STY TEMPB

 LDXIM 2 ;do all three bytes
RDJHW3 LDY TEMPA
 LDAIY RTEPTR
 LDY TEMPB
 STAIY NEWARG
 INC TEMPA
 INC TEMPB
 DEX
 BPL RDJHW3

 LDAIM 13
 JSR SETRTN ;call to zero the disc
 JSR MAPMAN
 BNE RDJHWX
 ] ;do this in RDCHSZ ** 20/9/84 **

RDJHW9 LDAIM ARGF
 STA OFF1
 LDAIM RTHWM
 STA OFF2 ;Having resized file, set HWM to ptr. value
 JSR MOVRND

 LDAIM 0
RDJHWX JMP RDSTAZ ;return the RC to the user

MOVRND

;Little space-saving routine

 LDXIM ARGPTR
 LDYIM RTEPTR
 LDAIM  3
 JMP MOVBLK


;*** RDCHSZ ***

;Change the size of a file to the 3-byte value
;in NEWFSZ.  HNDPTR points at its HANDTB entry,
;and RTEPTR at the RANDTB entry.

;MAPMAN.CHANGESIZE is called, and the new
;size is recorded in the RANDTB entry.

;RC in A on exit.


RDCHSZ JSR RDDSIN ;Put disc and SIN on stack

;Put new size on stack

 LDA NEWFSZ ;LS byte
 LDYIM ARGG
 STAIY NEWARG
 LDA NEWFSZ + 1
 INY
 STAIY NEWARG ;CS byte
 LDA NEWFSZ + 2
 INY
 STAIY NEWARG ;MS byte

 JSR JUSINF ;** 3/10/84 **

 LDAIM 3 ;MAPMAN.CHANGESIZE
 JSR SETRTN
 JSR MAPMAN
 BNE RDCHSX ;Failed, return code

;zero the new area if needed

 JSR RDDSIN ;** 20/9/84 **

 LDYIM RTFSZE
 LDAIY RTEPTR
 LDYIM ARGG
 STAIY NEWARG

 LDYIM RTFSZE+1
 LDAIY RTEPTR
 LDYIM ARGH
 STAIY NEWARG

 LDYIM RTFSZE+2
 LDAIY RTEPTR
 LDYIM ARGI
 STAIY NEWARG

 LDAIM 13
 JSR SETRTN
 JSR MAPMAN
 BNE RDCHSX ;failed, return code 
 
;Size changed: record in RANDTB

RDCHSA LDAIM  6
 JSR SETRTN ;Ensure map on disc
 JSR MAPMAN ;Note assumes disc no. still on stack

 BNE RDCHSX ;Error -> leave

 LDYIM RTFSZE
RDCHSB LDA NEWFSZ
 STAIY RTEPTR ;LS byte
 LDA NEWFSZ + 1
 INY
 STAIY RTEPTR ;CS byte
 LDA NEWFSZ + 2
 INY
 STAIY RTEPTR ;MS byte

 LDAIM  0 ;RC
RDCHSX RTS


;*** SETRPT ***

;Set RTEPTR to point to RANDTB entry

;Entry: HNDPTR points at HANDTB entry

;Exit:  A = return code
;RTEPTR points to corresponding RANDTB entry


SETRPT LDYIM HTACC
 LDAIY HNDPTR ;A := type of object (& access)
 ANDIM TYPE ;Mask type
 CMPIM TYPFIL ;Is it a file?
 BEQ SETRPA ;Jump if file

 LDAIM RDERRI ;"Object not a file"
 RTS  ;Return

SETRPA LDYIM HTRPTR
 LDAIY HNDPTR ;LS byte
 STA RTEPTR ;LS byte
 INY
 LDAIY HNDPTR
 STA RTEPTR + 1 ;MS byte

 LDAIM  0 ;return code
 RTS


;*** RDDSIN ***

;Put disc number and SIN on NEWARG
;stack from ARGB - ARGF.

RDDSIN LDAIM HTDISC ;"Move from" offset
 STA OFF1
 LDAIM ARGB ;"move to" offset
 STA OFF2
 LDXIM HNDPTR ;Move from
 LDYIM NEWARG ;Move to
 LDAIM  5 ;Size of disc no. + SIN
 JMP MOVBLK ;Note -> assumes DISC/SIN contiguous


;*** RDCKEX ***

;Check SFP against HWM (For read operation)

RDCKEX LDYIM RTHWM
 BNE RDCKLA ;share code with RDCKSP


;*** RDCKSP ***

;Check sequential file pointer against file size

;Entry: RTEPTR points to RANDTB entry

;Exit:  A = return code: 0 => OK, SFP < size
;EOFFLG = 0 normally
;= #X80 if this is last byte of file
;= $C0 If byte after last

RDCKSP LDYIM RTFSZE
RDCKLA STY RNDTMP +2
 LDAIM  0 ;First set EOFFLG to zero
 STA EOFFLG
 SEC
 LDY RNDTMP +2 ;Subtract SFP from file size
 INC RNDTMP +2
 LDAIY RTEPTR ;LS byte of file size
 LDYIM RTCSFP
 SBCIY RTEPTR ;Subtract LS bytes
 STA RNDTMP ;Use RNDTMP as workspace
 LDY RNDTMP +2
 INC RNDTMP +2
 LDAIY RTEPTR
 LDYIM RTCSFP + 1
 SBCIY RTEPTR ;CS bytes
 STA RNDTMP + 1
 LDY RNDTMP +2
 INC RNDTMP +2
 LDAIY RTEPTR
 LDYIM RTCSFP + 2
 SBCIY RTEPTR ;Sets carry if SFP <= size

 TAX  ;Save MS byte for EOFFLG test
 ORA RNDTMP ;OR all 3 bytes of result
 ORA RNDTMP + 1 ;for zero test
 BEQ RDCKSC ;Jump if SFP = file size
 BCC RDCKSA ;Jump if SFP > file size

;OK: SFP < file size | HWM
;Set EOFFLG to #X80 if this is the last
;byte of the file (size - SFP = 1)

 CMPIM  1 ;Is OR of all bytes 1?
 BNE RDCKSB ;No
 TXA  ;OR MS two bytes
 ORA RNDTMP + 1 ;CS byte
 BNE RDCKSB ;MS 2 bytes not both 0

 LDAIM &80 ;(size - SFP)=1 so set
 STA EOFFLG ;end-of-file flag

RDCKSB LDAIM  0 ;OK: SFP <= file size
 RTS

;SFP = file size
;Set end of file marker to indicate
;reading/writing byte AFTER end of file.

RDCKSC LDAIM &C0 ;Last AND one after last
 STA EOFFLG
 BNE RDCKSB ;Exit, Z set, A=0

RDCKSA LDAIM RDERRJ ;"End of file"
 RTS



;*** RDCSEQ ***

;Compare sequence number received with that recorded
;in RANDTB.  If they are equal, then increment
;the sequence number in RANDTB and set
;old SFP := current SFP
;Otherwise, this is a repetition of the
;last operation, so don't change the sequence number
;and set current SFP := old SFP

;Entry: RTEPTR points to RANDTB entry
;ARGE on ARGPTR stack holds received
;seq no (in LS bit)

;Exit:  Sequence number
;in RANDTB entry incremented if and only if
;sequence numbers matched.

RDCSEQ LDYIM ARGE
 LDAIY ARGPTR ;A := received seq no.
 LDYIM RTINUS ;Seq no. byte of RANDTB entry
 EORIY RTEPTR ;A := XOR of seq nos.
 ANDIM  1 ;Mask out "in use" bit
 BEQ RDCSEA ;Jump if seq nos. equal

;Seq nos different, so back up SFP:
;current SFP := old SFP

RDBACK LDYIM RTOSFP ;** 5/8/83 **
 LDAIY RTEPTR
 LDYIM RTCSFP
 STAIY RTEPTR
 LDYIM RTOSFP + 1
 LDAIY RTEPTR
 LDYIM RTCSFP + 1
 STAIY RTEPTR
 LDYIM RTOSFP + 2
 LDAIY RTEPTR
 LDYIM RTCSFP + 2
 STAIY RTEPTR
 RTS  ;Seq nos. different; return

RDCSEA LDAIY RTEPTR ;Get seq. no.
 EORIM  1 ;Flip seq no., leaving "in use" flag
 STAIY RTEPTR

;old SFP := current SFP

 LDYIM RTCSFP
 LDAIY RTEPTR
 LDYIM RTOSFP
 STAIY RTEPTR
 LDYIM RTCSFP + 1
 LDAIY RTEPTR
 LDYIM RTOSFP + 1
 STAIY RTEPTR
 LDYIM RTCSFP + 2
 LDAIY RTEPTR
 LDYIM RTOSFP + 2
 STAIY RTEPTR
 RTS  ;Return


;*** RDISFP ***

;Increment sequential file ptr (3 bytes)

RDISFP CLC
 LDAIM  1
 LDYIM RTCSFP
 ADCIY RTEPTR
 STAIY RTEPTR ;LS byte
 INY
 LDAIY RTEPTR
 ADCIM  0
 STAIY RTEPTR ;CS byte
 INY
 LDAIY RTEPTR
 ADCIM  0
 STAIY RTEPTR ;MS byte

 RTS  ;Return


;*** RDGBLK ***

;Gets the required block into the cache.
;In order to speed up the operation, a means
;is provided of usually avoiding a call of STRMAN.
;Each entry in RANDTB contains a hint - in the form
;of a pointer to the cache descriptor for the block
;last used.  STRMAN guarantees that this will
;continue to point to SOME cache descriptor, but if
;there has been a store crisis in the cache, then
;it may not still point to the block we want.
;Therefore the hint is carefully checked for validity
;before use.
;If the hint is no good, then the required block
;is read from disc by calling STRMAN.DISC ADDRESS->
;STORE ADDRESS. The address of the cache descriptor
;is put in the RANDTB entry as the next hint.

;Entry: HNDPTR points to handle table entry
;RTEPTR points to RANDTB entry

;Exit:  A = RC
;GENPTR contains store address of cache buffer.
;Hint field of RANDTB entry points to cache
;descriptor (or is zero).

RDGBLK JSR RDCHNT ;Check hint; set GENPTR if OK
 BNE RDGBLB ;Hint no good

 RTS  ;GENPTR already set; return

RDGBLB JSR RDDSIN ;Put disc and SIN on stack

;Logical block number of the block containing the
;current byte is given by the top 2 bytes of the
;sequential file pointer.
;*** This firmly assumes that the blocksize is
;*** 256 bytes (as does DIVIDE in MAPMAN).

 LDYIM RTCSFP + 1
 LDAIY RTEPTR ;Seq file ptr (CS)
 LDYIM ARGG
 STAIY NEWARG ;Logical block no. (LS)
 LDYIM RTCSFP + 2
 LDAIY RTEPTR ;Seq file ptr (MS)
 LDYIM ARGH
 STAIY NEWARG ;Logical block no. (MS)

;Ask for one block only.  This simplifies the
;arithmetic elsewhere.
;(Would using units of > 1 block give a
;significant speed improvement?)

 LDAIM  1
 LDYIM ARGI
 STAIY NEWARG
 LDAIM  0
 INY
 STAIY NEWARG

 LDAIM  1 ;STRMAN: Disc address -> store address
 LDYIM ARGA
 STAIY NEWARG

 JSR STRMAN ;*** STRMAN.DISC -> STORE ADDRESS **
 BEQ RDGBLA ;OK, continue

 RTS  ;Failed; return

RDGBLA LDYIM ARGB ;GENPTR := store address
 LDAIY NEWARG
 STA GENPTR ;(LS)
 INY
 LDAIY NEWARG
 STA GENPTR + 1 ;(MS)

 INY  ;Store cache desc. addr. in RANDTB entry
 LDAIY NEWARG ;LS byte
 LDYIM RTDESC
 STAIY RTEPTR
 LDYIM ARGE
 LDAIY NEWARG ;MS byte
 LDYIM RTDESC + 1
 STAIY RTEPTR

;Must unlock cache window, so that it is not
;locked between byte transfers.  Note that if
;parallelism is ever introduced into the file
;server, care must be taken that RNDMAN does
;not relinquish control between deciding that
;it has found a block in the cache and using it.

;Very conveniently, STRMAN has left the buffer
;address in the right place on the stack.

 LDAIM  3 ;STRMAN.UNLOCKWINDOW
 LDYIM ARGA
 STAIY NEWARG

 JSR STRMAN ;*** STRMAN.UNLOCKWINDOW **

 RTS  ;exit

 LNK RMAN03
