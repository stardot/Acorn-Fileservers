 OPT UADE14 ; > Uade14
 TTL File server file UADE14

DSCTOP
 ORG DSCTOP


;*********************************
;*           D S C M A N         *
;*********************************



;DSCMAN: THE DISC MANAGER
;THIS MODULE READS & WRITES OBJECTS FROM
;AND TO THE DISC.
;NOTE THAT IT USES MANY OF THE POINTERS,VARIABLES,
;AND ROUTINES PROVIDED BY MAPMAN.


;ENTRY: ARGA = (1=>READ,2=>WRITE)
;ARGB = LS(DISC NO)
;ARGC = MS(DISC NO)
;ARGD = LS(SIN)
;ARGE = CS(SIN)
;ARGF = MS(SIN)
;ARGG = LS(START BLOCK NO)
;ARGH = MS(START BLOCK NO)
;ARGI = LS(NUMBER OF BLOCKS)
;ARGJ = MS(NUMBER OF BLOCKS)
;ARGK = LS(STORE ADDRESS)
;ARGL = MS(STORE ADDRESS)

;EXIT: ARGA = RC



;********** MAIN ROUTINE **********

DSCMAN LDXIM  4
 LDAIM MODDSC
 JSR ENTRY
 LDAAX DCRTNS
 STA DCJUMP + 1
 LDAAX DCRTNS + 1
 STA DCJUMP + 2
 JMP DCJUMP ;N.B. NO NEED FOR SETFS-NOT CALLING ANY MODULE
DCRTNS
 & DCREAD ;1 => READ
 & DCWRIT ;2 => WRITE
 & DCIORD ;3 => READ (I/O processor)
 & DCIOWR ;4 => WRITE (I/O processor)
DCJUMP JMP DCJUMP
DCEXIT BEQ DCEXEX
 LDXIM &FF
 STX ODSCMN ;invalidate cache on disc error
 STX ODSCMN + 1
DCEXEX JMP PREXIT





;************ DCREAD ************


;DCREAD: READ AN OBJECT FROM THE DISC.
;NOTE IF A SECTOR HAS NOT BEEN WRITTEN THEN
;THE APPROPRIATE AREA OF STORE IS CLEARED TO ZERO.


DCIORD JSR DCCACH ;check call against last caller
 BEQ DCREDX ;all done !!!!!

 LDXIM &FF ;for I/O side operation
 BNE DCRDL1
DCREAD LDXIM  0
DCRDL1 STX DSCCB+TRADD+ 2
 STX DSCCB+TRADD+ 3

 JSR DCINIT ;INITIALISE FOR DSCMAN VARIABLES
 BNE DCREDZ

 [ WINCH=0
 LDAIM  8
 |
 LDAIM &53 ;DOS READ COMMAND
 ]
 STA SAVCOM ;SAVCOM := DOS DISC READ COMMAND

DCREDB JSR SETDSE ;DCSECT := SECTOR NUMBER


 JSR SETDES ;SETUP DOS DISC DRIVE DESCRIPTOR

 [ DEBUG <> 0
 LDAIM "r"
 JSR TRACE
 ]

 LDA DCRASH
 BNE DCREDX ;If a disc error occured in NMI
;task...error.

 JSR XFERIN ;TRANSFER MPTMPD SECTORS
 JSR MOVEON ;FIND NEXT SECTORS FROM DISC MAP
 BEQ DCREDB
 CMPIM  1
 BNE DCREDZ ;NO MORE SECTORS TO READ
 LDAIM  0
DCREDZ TAX
 LDA DCRASH
 BNE DCREDX ;Check no crash on last BG job
 TXA
DCREDX JMP DCEXIT



;************ DCWRIT ************


;DCWRIT: WRITE AN OBJECT TO DISC
;NOTE THAT IF A SECTOR IS WRITTEN FOR THE FIRST TIME
;IT IS MARKED DIRTY IN THE MAP (IN WHICH CASE
;THE MAP IS MARKED DIRTY).


DCIOWR JSR DCCACF ;copy new stack into variables
 LDXIM &FF ;for I/O side operation
 BNE DCWRL1
DCWRIT JSR DCSIN ;check invalidation of cache
 LDXIM  0
DCWRL1 STX DSCCB+TRADD+ 2
 STX DSCCB+TRADD+ 3
 JSR DCINIT
 BNE DCWRTZ

 [ WINCH=0
 LDAIM &0A
 |
 LDAIM &4B ;DOS DISC WRITE COMMAND
 ]
 STA SAVCOM ;SAVCOM:=COMMAND TO WRITE
DCWRTB JSR SETDSE ;DCSECT:=SECTOR NUMBER
 JSR SETDES ;SETUP DRIVE DESCRIPTOR FOR DOS

 [ DEBUG <> 0
 LDAIM "w"
 JSR TRACE
 ]

 LDA DCRASH
 BNE DCWRTZ

 JSR XFERIN ;START TRANSFR OF ONE SECTOR

 JSR MOVEON
 BEQ DCWRTB

 TAX
 LDA DCRASH
 BNE DCWRTZ
 TXA
 CMPIM  1
 BNE DCWRTZ ;NO MORE SECTORS TO READ
 LDAIM  0
DCWRTZ JMP DCEXIT




;DCINIT: INITIALISE DSCMAN VARIABLES FOR TRANSFER
;0) GET APPROPRIATE DISC MAP LOADED
;1) LDRNB := LOGICAL DRIVE NUMBER (GOT FROM MAPTB ENTRY)
;2) NBLKS := NUMBER OF DISC BLOCKS TO TX
;3) DCSTAD := STORE ADDRESS OF SECTOR
;4) CHECK SIN IS FOR START OF OBJECT
;5) MAPTMP := SIN, MPSCPT:=PTR TO RELEVENT MAP ENTRY
;6) DSCTMP := PTR TO MAP'S DIRTY FLAG



DCINIT LDAIM  0
 STA DCRASH ;Initialise disc error flag
 JSR FNDMAP ;MAPPTR & MAPENT PT MAPTB ENTRY
 BEQ DCINTA
 JMP DCINTZ

DCINTA LDA MPDRVE
 STA LDRNB ;LDRNB:= LOGICAL DRIVE NUMBER

;FIRST CHECK THAT THE SPECIFIED SIN IS SENSIBLE

 LDYIM ARGD
 LDAIY ARGPTR
 STA MPTMPA
 INY
 LDAIY ARGPTR
 STA MPTMPA + 1 ;MPTMPA:=SIN
 INY
 LDAIY ARGPTR
 STA MPTMPA + 2
 CLC
 JSR RDMPBK
 BEQ DCINTB
 JMP DCINTZ
DCINTB LDA MAPTMP
 STA MPMBPT
 LDA MAPTMP + 1
 STA MPMBPT + 1
 LDAIM  0
 STA NBLKS + 1
 LDYIM ARGI
 LDAIY ARGPTR
 STA NBLKS ;NBLKS:=NUMBER OF SECTORS TO BE TX
 BNE DCINTD
DCINTC LDAIM DCERRA ;INVALID NUMBER OF BLOCKS
 JMP DCINTZ

DCINTD INY
 LDAIY ARGPTR
 BNE DCINTC

 LDYIM ARGK
 LDAIY ARGPTR
 STA DCSTAD
 INY
 LDAIY ARGPTR
 STA DCSTAD + 1 ;DCSTAD:=STORE ADDRESS


;NOW GET TO THE CORRECT STARTING POINT IN THE OBJECT

 LDYIM ARGG
 LDAIY ARGPTR
 STA BREGA
 INY
 LDAIY ARGPTR
 STA BREGA + 1 ;BREGA:=START BLOCK NUMBER

DCENT2 LDAIM MBENTS
 STA MPTMPB
 LDAIM /(MBENTS )
 STA MPTMPB + 1
 CLC
 LDA MPMBPT
 ADC MPTMPB
 STA MPSCPT
 LDA MPMBPT + 1
 ADC MPTMPB + 1
 STA MPSCPT + 1
DCINTS SEC
 LDYIM  3
 LDA BREGA
 SBCIY MPSCPT
 STA BREGA
 LDA BREGA + 1
 INY
 SBCIY MPSCPT
 STA BREGA + 1
 BCC DCINTM
 JSR NXTEN
 BEQ DCINTS
 JMP DCINTZ
DCINTM CLC
 LDYIM  3
 LDAIY MPSCPT
 ADC BREGA
 STA BREGA
 INY
 LDAIY MPSCPT
 ADC BREGA + 1
 STA BREGA + 1
 LDYIM  0
 CLC
 LDAIY MPSCPT
 ADC BREGA
 STA MAPTMP
 INY
 LDAIY MPSCPT
 ADC BREGA + 1
 STA MAPTMP + 1
 INY
 LDAIY MPSCPT
 ADCIM  0
 STA MAPTMP + 2
 SEC
 INY
 LDAIY MPSCPT
 SBC BREGA
 STA MPTMPD
 INY
 LDAIY MPSCPT
 SBC BREGA + 1
 STA MPTMPD + 1
 JSR SETSZE

 LDAIM  0
DCINTZ RTS

SETSZE LDA NBLKS
 CMP MPTMPD
 LDA NBLKS + 1
 SBC MPTMPD + 1
 BCS STSZND
 LDA NBLKS
 STA MPTMPD
 LDA NBLKS + 1
 STA MPTMPD + 1
STSZND RTS

NXTEN CLC
 LDA MPTMPB
 ADCIM ENSZ
 STA MPTMPB
 LDA MPTMPB + 1
 ADCIM /(ENSZ )
 STA MPTMPB + 1
NXENLP CLC
 LDA MPMBPT
 ADC MPTMPB
 STA MPSCPT
 LDA MPTMPB + 1
 ADC MPMBPT + 1
 STA MPSCPT + 1
 LDYIM  0
 LDAIY MPSCPT
 INY
 ORAIY MPSCPT
 INY
 ORAIY MPSCPT
 BEQ NXENNG
 LDA MPTMPB
 CMPIM LSTENT
 LDA MPTMPB + 1
 SBCIM /(LSTENT )
 BCC NXENND
 LDYIM  0
 LDAIY MPSCPT
 STA MPTMPA
 INY
 LDAIY MPSCPT
 STA MPTMPA + 1
 INY
 LDAIY MPSCPT
 STA MPTMPA + 2
 LDA DSCCB+TRADD+ 2
 PHA
 LDA DCSTAD
 PHA
 LDA DCSTAD + 1
 PHA
 LDA SAVCOM
 PHA
 CLC
 JSR RDMPBK
 BNE NXENGA
 PLA
 STA SAVCOM
 PLA
 STA DCSTAD + 1
 PLA
 STA DCSTAD
 PLA
 STA DSCCB+TRADD+ 2
 STA DSCCB+TRADD+ 3
 LDA MAPTMP
 STA MPMBPT
 LDA MAPTMP + 1
 STA MPMBPT + 1
 LDAIM MBENTS
 STA MPTMPB
 LDAIM /(MBENTS )
 STA MPTMPB + 1
 JMP NXENLP
NXENGA TAX
 PLA
 PLA
 PLA
 PLA
 TXA
 JMP NXENFN
NXENNG LDAIM DCERRC
 JMP NXENFN
NXENND LDYIM  0
 LDAIY MPSCPT
 STA MAPTMP
 INY
 LDAIY MPSCPT
 STA MAPTMP + 1
 INY
 LDAIY MPSCPT
 STA MAPTMP + 2
 INY
 LDAIY MPSCPT
 STA MPTMPD
 INY
 LDAIY MPSCPT
 STA MPTMPD + 1
 LDAIM  0
NXENFN RTS

SETDSE LDA MAPTMP ;DCSECT := MAPTMP (I.E SECTOR NUMBER)
 STA DCSECT
 LDA MAPTMP + 1
 STA DCSECT + 1
 LDA MAPTMP + 2
 STA DCSECT + 2
 RTS


;SETDES: SETUP DOS'S DISC DRIVE DESCRIPTOR.
;SETUP CORRECT SECTOR NUMBER IN DOS DESCRIPTOR
;AND SELECT APPROPRIATE DRIVE, WHEN ACTUAL DRIVES
;CHANGE.
;A DRIVE MUST BE "DRVSEL" SELECTED & STARTED
;BEFORE TRANSFERS CAN BE INITIATED.
;HOWEVER WE WANT TO AVOID CALLING"DRVSEL" BETWEEN
;THE SECTORS OF A MULTI-SECTOR TRANSFER.

;ENTRY: OLDFDR = LAST ACTUAL DRIVE NUMBER USED(SETBY SETDES)
;LDRNB = LOGICAL DRIVE NO(I.E. DISC UNIT)
;DCSECT = LOGICAL SECTOR NUMBER
;MAPENT = PTR TO RELEVENT MAPTB ENTRY(MAPMAN/FNDMAP)

;FUNCTION:-
;SECTSD := NO OF SECTORS ON A SIDE OF THIS DISC;
;IF DCSECT >= SECTSD #NO OF SECTORS ON A SIDE#
;THEN SECTOR NO=SECTDC-SECTSD
;DRIVNO = LDRNB + 2
;ELSE SECTOR NO=DCSECT;
;DRIVNO := LDRNB
;FI;
;IF DRIVNO <> OLDFDR
;THEN FDRIVE = DRIVE NUMBER
;JSR DRVSEL;
;IF DRIVNO <> othersideof OLDFDR THEN JSR ZTRKSL
;FI;


SETDES LDA LDRNB
 STA DRIVNO

 LDYIM MPSECS
 LDAIY MAPENT
 STA SECTSD
 INY
 LDAIY MAPENT
 STA SECTSD + 1 ;SECTSD:=NUMBER OF SECTORS ON A SIDE
 INY
 LDAIY MAPENT
 STA SECTSD + 2

STDSLP LDA DCSECT
 CMP SECTSD
 LDA DCSECT + 1
 SBC SECTSD + 1
 LDA DCSECT + 2
 SBC SECTSD + 2
 BCC SETDSF

;DCSECT >= SECTSD

 CLC
 LDYIM MPDRNC
 LDA DRIVNO
 ADCIY MAPPTR
 STA DRIVNO
 SEC
 LDA DCSECT
 SBC SECTSD
 STA DCSECT
 STA RBDA
 LDA DCSECT + 1
 SBC SECTSD + 1 ;SUBT NO. OF SECTORS ON A SIDE
 STA DCSECT + 1
 STA RBDA + 1
 LDA DCSECT + 2
 SBC SECTSD + 2
 STA DCSECT + 2
 STA RBDA + 2
 JMP STDSLP

;DCSECT < SECTSD

SETDSF
 [ WINCH=0
 LDA DCSECT
 STA RBDA
 LDA DCSECT + 1
 STA RBDA + 1
 LDA DCSECT + 2
 STA RBDA + 2
 RTS
 |
 LDA DCSECT
 STA DDRSCT + 1
 LDA DCSECT + 1
 ANDIM &F
 STA DDRSCT ;SECTOR NUMBER

;WORK OUT TRACK & SECTOR NUMBER


SETDSM LDAIM  0
 STA CTRACK ;START FROM TRACK ZERO
SETDSP LDYIM MPSPCY
 SEC ;KEEP SUBTRACTING UNTIL CORRECT TRACK FOUND
 LDA DCSECT
 SBCIY MAPPTR
 STA DCSECT
 INY
 LDA DCSECT + 1
 SBCIY MAPPTR
 STA DCSECT + 1
 LDA DCSECT + 2
 SBCIM  0
 STA DCSECT + 2
 BCC SETDSQ
 INC CTRACK
 JMP SETDSP
SETDSQ LDYIM MPSPCY
 CLC ;GET SECTOR NUMBER BACK
 LDA DCSECT
 ADCIY MAPPTR
 STA DCSECT
 STA CSECTR
 INY
 LDA DCSECT + 1
 ADCIY MAPPTR
 STA DCSECT + 1
 LDA DCSECT + 2
 ADCIM  0
 STA DCSECT + 2
 RTS

 ]


;MOVEON: SET NXT SECTOR
;FUNCTION:- NBLKS -:=1
;DCSTAD +:= BLKSZE
;MAPTMP := NXT SECTOR NUMBER
;MPSCPT := PTR TO NXT MAP ENTRY

;EXIT: A = 0  => CARRY ON
;A = 1  => NO MORE BLOCKS TO TX
;A > 1 => ERROR

MOVEON SEC
 LDA NBLKS
 SBC MPTMPD
 STA NBLKS
 LDA NBLKS + 1
 SBC MPTMPD + 1
 STA NBLKS + 1
 ORA NBLKS
 BNE MOVENB
 LDAIM  1 ;RC:=NO MORE BLOCKS
 BNE MOVENZ
MOVENB CLC;INCREMENT STORE ADDRESS
 LDA DCSTAD + 1
 ADC MPTMPD
 STA DCSTAD + 1
 BCC MOVEND
 LDAIM DCERRB ;STORE ADDR GONE ILLEGAL
 JSR INTERR
MOVEND JSR NXTEN ;UPDATE MAPTMP & MPSCPT
 JSR SETSZE
MOVENZ RTS


 JSR SETDSE ;DCSECT := SECTOR NUMBER = MAPTMP
; JMP STRTDR ;START DRIVE


; STRTDR JMP SETDES ;RTN TO START DRIVE IF NECESSARY


XFER LDAIM  1
 STA DDRSZE + 1
 LDAIM  0
 STA DDRSZE
 JMP XFERST

XFERIN LDA MPTMPD
 STA DDRSZE+ 1
 LDA MPTMPD + 1
 STA DDRSZE
XFERST LDA DCSTAD
 STA DDRSTA
 LDA DCSTAD + 1
 STA DDRSTA+ 1
 LDA SAVCOM ;A:=TYPE OF TRANSFER (READ/WRITE)
 JSR TRANS
 BEQ XFEROK ;is ok, end NMI
 CMPIM &FF
 BNE DSKON1 ;is write protect?
 LDAIM DCERRE ;Write protect -> back to client
 BNE XFERX ;as usual, and carry on

DSKON1 LDAIM DCERRF ;Other, non-recoverable disc error
XFERX STA DCRASH
XFEROK RTS


;Block read and write
;   On entry::
;      DRIVNO holds the drive number
;      DDRSTA holds the start address
;      CSECTR holds the start sector number
;      CTRACK holds the start track number
;      DDRSZE holds the number of sectors to transfer

 [ WINCH=0
BLKRD LDAIM &08 ;COMMAND FOR READ
 JMP TRANS
 LDAIM &0A ;COMMAND FOR WRITE
TRANS STA DSCCB+CMD
 LDA DRIVNO
 CLC
 RORA
 RORA
 RORA
 RORA
 ORA RBDA+ 2
 STA DSCCB+CMD+ 1
 LDA RBDA+ 1
 STA DSCCB+CMD+ 2
 LDA RBDA
 STA DSCCB+CMD+ 3

;test for writing to sector zero

 LDA RBDA
 ORA RBDA+1
 ORA RBDA+2
 BNE TRANSJ
 
 LDAIM IERRAK ;writing to sector zero
 JMP INTERR ;***

TRANSJ LDA DDRSTA
 STA DSCCB+TRADD ; SAVE THE ADDRESS
 LDA DDRSTA + 1
 STA DSCCB+TRADD+ 1
 LDA DDRSZE + 1 ;CHECK FOR END OF TRANSFER
 STA DSCCB+LENGTH+ 1
 LDA DDRSZE
 STA DSCCB+LENGTH+ 2
 LDAIM  0
 STA DSCCB
 STA DSCCB+LENGTH
 STA DSCCB+LENGTH+ 3
 STA DSCCB+CMD+ 4
 STA DSCCB+CMD+ 5
 JMP DSCCMD ;DO THE TRANSFER

 |

BLKRD LDAIM &53 ;COMMAND FOR READ
 JMP TRANS
BLKWR LDAIM &4B ;COMMAND FOR WRITE
TRANS STA DSCCB+CMD
 LDA DRIVNO
 STA DSCCB ;SAVE THE DRIVE NUMBER
 LDA DDRSTA
 STA DSCCB+TRADD ; SAVE THE ADDRESS
 LDA DDRSTA + 1
 STA DSCCB+TRADD+ 1
 LDAIM  3 ;NUMBER OF PARAMETERS
 STA DSCCB+NOPRMS
TRLOOP LDA DDRSZE ;CHECK FOR END OF TRANSFER
 ORA DDRSZE + 1
 BNE TRSK5
 JMP TREND
TRSK5 SEC
 LDAIM &A ;MAX NUMBER OF SECTORS
 SBC CSECTR ;MAX WE CAN TRANSFER
 STA DSCCB+PARAMS+ 2
 LDA DDRSZE ;IF THIS IS NON-ZERO TRANS CANNOT HAVE FINISHED
 BNE TRSKP
 LDA DSCCB+PARAMS+ 2 ;DO WE NEED THIS MANY
 CMP DDRSZE+ 1
 BMI TRSKP ;SKIP IF NOT
 LDA DDRSZE+ 1
 STA DSCCB+PARAMS+ 2 ;ONLY TRANSFER AMOUNT REQUIRED
TRSKP LDA CSECTR
 STA DSCCB+PARAMS+ 1 ;SAVE SECTOR NUMBER
 LDA CTRACK
 STA DSCCB+PARAMS ;SAVE TRACK NUMBER
 LDAIM &20 ;256 BYTES PER SECTOR
 ORA DSCCB+PARAMS+ 2
 STA DSCCB+PARAMS+ 2
 JSR DSCCMD ;DO THE TRANSFER
 BNE TREND ;OOPS! FAILED
 LDAIM &00 ;FROM NOW ON START AT SECTOR ZERO
 STA CSECTR
 INC CTRACK ;NEXT TRACK
 LDA DSCCB+PARAMS+ 2
 ANDIM &F ;GET NUMBER OF SECTORS
 STA CNTA
 SEC
 LDA DDRSZE+ 1
 SBC CNTA ;SUBTRACT FROM TOTAL
 STA DDRSZE+ 1
 LDA DDRSZE
 SBCIM  0
 STA DDRSZE
 CLC
 LDA DSCCB+PARAMS+ 2
 ANDIM &F
 ADC DSCCB+TRADD+ 1
 STA DSCCB+TRADD+ 1
; LDA DSCCB+TRADD+ 2 ;** 15/2/85 ** dangerous !
; ADCIM &00
; STA DSCCB+TRADD+ 2
 JMP TRLOOP ;GET THE REST
TREND RTS

 ]
 [ WINCH=0
DSCCMD
 [  0=1
 LDYIM  16
DSCLP LDAAY DSCCB
 JSR WHEX
 DEY
 BPL DSCLP
 LDAIM "r"
 JSR OSWRCH
 JSR OSCRLF

 ]
 LDAIM 0
 STA DSCCB

 LDXIM DSCCB
 LDYIM /(DSCCB )
 LDAIM &72
 JSR OSWORD
 LDA DSCCB
 BEQ LHNOER  ; REPORT DISC ERRORS TO SCREEN 5/6/86 LH
 JSR LHDSCR

LHNOER RTS 

LHDSCR PHA
 LDAIM &73
 LDXIM DSCCB
 LDYIM /(DSCCB )
 JSR OSWORD
 JSR VSTRIN
 = "       : Disc Error. "
 NOP
 LDA DSCCB+3
 JSR WHEX
 JSR VSTRIN
 = " At "
 NOP
 LDA DSCCB+2
 JSR WHEX
 LDA DSCCB+1
 JSR WHEX
 LDA DSCCB
 JSR WHEX
 PLA
 RTS

 |
;DSCCMD
;   SEND A COMMAND TO THE DISC CONTROLLER
;   DSCCB IS THE CONTROL BLOCK AND MUST BE SET UP
;   TRIES ANY ERROR 10 TIMES
;   RETURNS WITH Z SET IF OK
;   IF FAILED RETURNS WITH ERROR NUMBER
DSCCMD LDAIM &A ;COUNT
 STA CNTA
DSCLP LDXIM DSCCB
 LDYIM /(DSCCB )
 LDAIM &7F
 JSR OSWORD
 LDA DSCCB+PARAMS+ 3 ;LOOK AT REPLY
 BEQ DSCOK
 DEC CNTA
 BNE DSCLP ;TRY AGAIN IF ERROR
 LDA DSCCB+PARAMS+ 3
DSCOK RTS ;RETURN WITH CORRECT ERROR NUMBER
 ]

DCCACH LDYIM ARGJ ;get MS number of blocks to load
 LDAIY ARGPTR
 BNE DCCACD ;exit 'cos its too big
 DEY ;get LS number of blocks
 LDAIY ARGPTR
 CMP IOBSIZ + 1
 BEQ DCCACF
 BCS DCCACD ;overflow here

DCCACF LDYIM ARGL
 LDXIM  10
 LDAIM  0
 STA GENPTR ;spare space

DCCACA LDAIY ARGPTR
 CMPAX ODSCMN ;look against old stack
 BEQ DCCACB
 INC GENPTR ;unzero flag
DCCACB STAAX ODSCMN ;save stack
 DEY
 DEX
 BPL DCCACA ;loop until done

 LDA GENPTR ;load flag
DCCACD RTS

DCSIN LDYIM ARGB
 LDXIM  0
DCSINA LDAIY ARGPTR
 CMPAX ODSCMN ;compare against old cache
 BNE DCSINB
 INY
 INX
 CPXIM  5 ;test disc number & SIN
 BNE DCSINA
 LDXIM &FF
 STX ODSCMN ;invalidate cache
 STX ODSCMN + 1
DCSINB RTS ;return to main routine


 LNK UADE15
