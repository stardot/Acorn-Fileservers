 OPT UADE14 ; > Uade14
 TTL File server file UADE14

DSCTOP
 ORG DSCTOP


;*********************************
;*           D S C M A N         *
;*********************************

;DSCMAN: THE DISC MANAGER
;THIS MODULE READS & WRITES OBJECTS FROM
;AND TO THE DISC.
;NOTE THAT IT USES MANY OF THE POINTERS,VARIABLES,
;AND ROUTINES PROVIDED BY MAPMAN.


;ENTRY:
;ARGA = (1=>READ,2=>WRITE)
;ARGB-C DISC NO
;ARGD-F SIN
;ARGG-H START BLOCK NO
;ARGI-J NUMBER OF BLOCKS
;ARGK-L STORE ADDRESS

;EXIT: ARGA = RC



;*********************************
;*           D S C M A N         *
;*********************************



;********** MAIN ROUTINE **********

DSCMAN LDXIM 4
 LDAIM MODDSC
 JSR ENTRY
 LDAAX DCRTNS
 STA DCJUMP+1
 LDAAX DCRTNS+1
 STA DCJUMP+2
DCJUMP JMP DCJUMP ;N.B. NO NEED FOR SETFS-NOT CALLING ANY MODULE
DCRTNS
 & DCREAD ;1 => READ
 & DCWRIT ;2 => WRITE
 & DCIORD ;3 => READ (I/O processor)
 & DCIOWR ;4 => WRITE (I/O processor)
DCEXIT BEQ DCEXEX
 LDXIM &FF
 STX ODSCMN ;invalidate cache on disc error
 STX ODSCMN+1
DCEXEX JMP PREXIT





;************ DCREAD ************


;DCREAD: READ AN OBJECT FROM THE DISC.
;NOTE IF A SECTOR HAS NOT BEEN WRITTEN THEN
;THE APPROPRIATE AREA OF STORE IS CLEARED TO ZERO.


DCIORD ROUT
 JSR DCCACH ;check call against last caller
 BEQ #40 ;all done !!!!!

 LDXIM &FF ;for I/O side operation
 BNE #10
DCREAD LDXIM 0
10 STX DSCCB+TRADD+2
 STX DSCCB+TRADD+3

 JSR DCINIT ;INITIALISE FOR DSCMAN VARIABLES
 BNE #30

 [ WINCH=0
 LDAIM  8
 |
 LDAIM &53 ;DOS READ COMMAND
 ]
 STA SAVCOM ;SAVCOM := DOS DISC READ COMMAND

20 JSR SETDSE ;DCSECT := SECTOR NUMBER


 JSR SETDES ;SETUP DOS DISC DRIVE DESCRIPTOR

 [ DEBUG <> 0
 LDAIM "r"
 JSR TRACE
 ]

 LDA DCRASH
 BNE #40 ;If a disc error occured in NMI
;task...error.

 JSR XFERIN ;TRANSFER MPTMPD SECTORS
 JSR MOVEON ;FIND NEXT SECTORS FROM DISC MAP
 BEQ #20
 CMPIM 1
 BNE #30 ;NO MORE SECTORS TO READ
 LDAIM  0
30 TAX
 LDA DCRASH
 BNE #40 ;Check no crash on last BG job
 TXA
40 JMP DCEXIT



;************ DCWRIT ************


;DCWRIT: WRITE AN OBJECT TO DISC
;NOTE THAT IF A SECTOR IS WRITTEN FOR THE FIRST TIME
;IT IS MARKED DIRTY IN THE MAP (IN WHICH CASE
;THE MAP IS MARKED DIRTY).


DCIOWR ROUT
 JSR DCCACF ;copy new stack into variables
 LDXIM &FF ;for I/O side operation
 BNE #10
DCWRIT JSR DCSIN ;check invalidation of cache
 LDXIM 0
10 STX DSCCB+TRADD+2
 STX DSCCB+TRADD+3
 JSR DCINIT
 BNE #30

 [ WINCH=0
 LDAIM &0A
 |
 LDAIM &4B ;DOS DISC WRITE COMMAND
 ]
 STA SAVCOM ;SAVCOM:=COMMAND TO WRITE
20 JSR SETDSE ;DCSECT:=SECTOR NUMBER
 JSR SETDES ;SETUP DRIVE DESCRIPTOR FOR DOS

 [ DEBUG <> 0
 LDAIM "w"
 JSR TRACE
 ]

 LDA DCRASH
 BNE #30

 JSR XFERIN ;START TRANSFR OF ONE SECTOR

 JSR MOVEON
 BEQ #20

 TAX
 LDA DCRASH
 BNE #30
 TXA
 CMPIM  1
 BNE #30 ;NO MORE SECTORS TO READ
 LDAIM  0
30 JMP DCEXIT




;DCINIT: INITIALISE DSCMAN VARIABLES FOR TRANSFER
;0) GET APPROPRIATE DISC MAP LOADED
;1) LDRNB := LOGICAL DRIVE NUMBER (GOT FROM MAPTB ENTRY)
;2) NBLKS := NUMBER OF DISC BLOCKS TO TX
;3) DCSTAD := STORE ADDRESS OF SECTOR
;4) CHECK SIN IS FOR START OF OBJECT
;5) MAPTMP := SIN, MPSCPT:=PTR TO RELEVENT MAP ENTRY
;6) DSCTMP := PTR TO MAP'S DIRTY FLAG



DCINIT ROUT
 LDAIM  0
 STA DCRASH ;Initialise disc error flag
 JSR FNDMAP ;MAPPTR & MAPENT PT MAPTB ENTRY
 BNE #25
 LDA MPDRVE
 STA LDRNB ;LDRNB:= LOGICAL DRIVE NUMBER

;FIRST CHECK THAT THE SPECIFIED SIN IS SENSIBLE

 LDYIM ARGD
 LDAIY ARGPTR
 STA MPTMPA
 INY
 LDAIY ARGPTR
 STA MPTMPA+1 ;MPTMPA:=SIN
 INY
 LDAIY ARGPTR
 STA MPTMPA+2
 CLC
 JSR RDMPBK
 BNE #25
 LDA MAPTMP
 STA MPMBPT
 LDA MAPTMP+1
 STA MPMBPT+1
 LDAIM 0
 STA NBLKS+1
 LDYIM ARGI
 LDAIY ARGPTR
 STA NBLKS ;NBLKS:=NUMBER OF SECTORS TO BE TX
 BNE #30
20 LDAIM DCERRA ;INVALID NUMBER OF BLOCKS
25 RTS

30 INY
 LDAIY ARGPTR
 BNE #20

 LDYIM ARGK
 LDAIY ARGPTR
 STA DCSTAD
 INY
 LDAIY ARGPTR
 STA DCSTAD+1 ;DCSTAD:=STORE ADDRESS


;NOW GET TO THE CORRECT STARTING POINT IN THE OBJECT

 LDYIM ARGG
 LDAIY ARGPTR
 STA BREGA
 INY
 LDAIY ARGPTR
 STA BREGA+1 ;BREGA:=START BLOCK NUMBER

DCENT2 LDAIM :LSB:MBENTS
 STA MPTMPB
 LDAIM :MSB:MBENTS
 STA MPTMPB+1
 CLC
 LDA MPMBPT
 ADC MPTMPB
 STA MPSCPT
 LDA MPMBPT+1
 ADC MPTMPB+1
 STA MPSCPT+1
50 SEC
 LDYIM 3
 LDA BREGA
 SBCIY MPSCPT
 STA BREGA
 LDA BREGA+1
 INY
 SBCIY MPSCPT
 STA BREGA+1
 BCC #60
 JSR NXTEN
 BEQ #50
 RTS

60 CLC
 LDYIM  3
 LDAIY MPSCPT
 ADC BREGA
 STA BREGA
 INY
 LDAIY MPSCPT
 ADC BREGA+1
 STA BREGA+1
 LDYIM 0
 CLC
 LDAIY MPSCPT
 ADC BREGA
 STA MAPTMP
 INY
 LDAIY MPSCPT
 ADC BREGA+1
 STA MAPTMP+1
 INY
 LDAIY MPSCPT
 ADCIM 0
 STA MAPTMP+2
 SEC
 INY
 LDAIY MPSCPT
 SBC BREGA
 STA MPTMPD
 INY
 LDAIY MPSCPT
 SBC BREGA+1
 STA MPTMPD+1
 JSR SETSZE
 LDAIM 0
 RTS

SETSZE ROUT
 LDA NBLKS
 CMP MPTMPD
 LDA NBLKS+1
 SBC MPTMPD+1
 BCS #10
 LDA NBLKS
 STA MPTMPD
 LDA NBLKS+1
 STA MPTMPD+1
10 RTS

NXTEN ROUT
 CLC
 LDA MPTMPB
 ADCIM :LSB:ENSZ
 STA MPTMPB
 LDA MPTMPB+1
 ADCIM :MSB:ENSZ
 STA MPTMPB+1
10 CLC
 LDA MPMBPT
 ADC MPTMPB
 STA MPSCPT
 LDA MPTMPB+1
 ADC MPMBPT+1
 STA MPSCPT+1
 LDYIM 0
 LDAIY MPSCPT
 INY
 ORAIY MPSCPT
 INY
 ORAIY MPSCPT
 BEQ #30
 LDA MPTMPB
 CMPIM :LSB:LSTENT
 LDA MPTMPB+1
 SBCIM :MSB:LSTENT
 BCC #40
 LDYIM 0
 LDAIY MPSCPT
 STA MPTMPA
 INY
 LDAIY MPSCPT
 STA MPTMPA+1
 INY
 LDAIY MPSCPT
 STA MPTMPA+2
 LDA DSCCB+TRADD+2
 PHA
 LDA DCSTAD
 PHA
 LDA DCSTAD+1
 PHA
 LDA SAVCOM
 PHA
 CLC
 JSR RDMPBK
 BNE #20
 PLA
 STA SAVCOM
 PLA
 STA DCSTAD+1
 PLA
 STA DCSTAD
 PLA
 STA DSCCB+TRADD+2
 STA DSCCB+TRADD+3
 LDA MAPTMP
 STA MPMBPT
 LDA MAPTMP+1
 STA MPMBPT+1
 LDAIM :LSB:MBENTS
 STA MPTMPB
 LDAIM :MSB:MBENTS
 STA MPTMPB+1
 JMP #10

20 TAX
 PLA
 PLA
 PLA
 PLA
 TXA
 RTS

30 LDAIM DCERRC
 RTS

40 LDYIM 0
 LDAIY MPSCPT
 STA MAPTMP
 INY
 LDAIY MPSCPT
 STA MAPTMP+1
 INY
 LDAIY MPSCPT
 STA MAPTMP+2
 INY
 LDAIY MPSCPT
 STA MPTMPD
 INY
 LDAIY MPSCPT
 STA MPTMPD+1
 LDAIM 0
 RTS


SETDSE LDA MAPTMP ;DCSECT := MAPTMP (I.E SECTOR NUMBER)
 STA DCSECT
 LDA MAPTMP+1
 STA DCSECT+1
 LDA MAPTMP+2
 STA DCSECT+2
 RTS


;SETDES: SETUP DOS'S DISC DRIVE DESCRIPTOR.
;SETUP CORRECT SECTOR NUMBER IN DOS DESCRIPTOR
;AND SELECT APPROPRIATE DRIVE, WHEN ACTUAL DRIVES
;CHANGE.
;A DRIVE MUST BE "DRVSEL" SELECTED & STARTED
;BEFORE TRANSFERS CAN BE INITIATED.
;HOWEVER WE WANT TO AVOID CALLING"DRVSEL" BETWEEN
;THE SECTORS OF A MULTI-SECTOR TRANSFER.

;ENTRY: OLDFDR = LAST ACTUAL DRIVE NUMBER USED(SETBY SETDES)
;LDRNB = LOGICAL DRIVE NO(I.E. DISC UNIT)
;DCSECT = LOGICAL SECTOR NUMBER
;MAPENT = PTR TO RELEVENT MAPTB ENTRY(MAPMAN/FNDMAP)

;FUNCTION:-
;SECTSD := NO OF SECTORS ON A SIDE OF THIS DISC;
;IF DCSECT >= SECTSD #NO OF SECTORS ON A SIDE#
;THEN SECTOR NO=SECTDC-SECTSD
;DRIVNO = LDRNB + 2
;ELSE SECTOR NO=DCSECT;
;DRIVNO := LDRNB
;FI;
;IF DRIVNO <> OLDFDR
;THEN FDRIVE = DRIVE NUMBER
;JSR DRVSEL;
;IF DRIVNO <> othersideof OLDFDR THEN JSR ZTRKSL
;FI;


SETDES ROUT
 LDA LDRNB
 STA DRIVNO

 LDYIM MPSECS
 LDAIY MAPENT
 STA SECTSD
 INY
 LDAIY MAPENT
 STA SECTSD+1 ;SECTSD:=NUMBER OF SECTORS ON A SIDE
 INY
 LDAIY MAPENT
 STA SECTSD+2

10 LDA DCSECT
 CMP SECTSD
 LDA DCSECT+1
 SBC SECTSD+1
 LDA DCSECT+2
 SBC SECTSD+2
 BCC #20

;DCSECT >= SECTSD

 CLC
 LDYIM MPDRNC
 LDA DRIVNO
 ADCIY MAPPTR
 STA DRIVNO
 SEC
 LDA DCSECT
 SBC SECTSD
 STA DCSECT
 STA RBDA
 LDA DCSECT+1
 SBC SECTSD+1 ;SUBT NO. OF SECTORS ON A SIDE
 STA DCSECT+1
 STA RBDA+1
 LDA DCSECT+2
 SBC SECTSD+2
 STA DCSECT+2
 STA RBDA+2
 JMP #10

;DCSECT < SECTSD

20
 [ WINCH=0
 LDA DCSECT
 STA RBDA
 LDA DCSECT+1
 STA RBDA+1
 LDA DCSECT+2
 STA RBDA+2
 RTS
 |
 LDA DCSECT
 STA DDRSCT+1
 LDA DCSECT+1
 ANDIM &F
 STA DDRSCT ;SECTOR NUMBER

;WORK OUT TRACK & SECTOR NUMBER


 LDAIM 0
 STA CTRACK ;START FROM TRACK ZERO
30 LDYIM MPSPCY
 SEC ;KEEP SUBTRACTING UNTIL CORRECT TRACK FOUND
 LDA DCSECT
 SBCIY MAPPTR
 STA DCSECT
 INY
 LDA DCSECT+1
 SBCIY MAPPTR
 STA DCSECT+1
 LDA DCSECT+2
 SBCIM 0
 STA DCSECT+2
 BCC #40
 INC CTRACK
 JMP #30

40 LDYIM MPSPCY
 CLC ;GET SECTOR NUMBER BACK
 LDA DCSECT
 ADCIY MAPPTR
 STA DCSECT
 STA CSECTR
 INY
 LDA DCSECT+1
 ADCIY MAPPTR
 STA DCSECT+1
 LDA DCSECT+2
 ADCIM 0
 STA DCSECT+2
 RTS

 ]


;MOVEON: SET NXT SECTOR
;FUNCTION:- NBLKS -:=1
;DCSTAD +:= BLKSZE
;MAPTMP := NXT SECTOR NUMBER
;MPSCPT := PTR TO NXT MAP ENTRY

;EXIT: A = 0  => CARRY ON
;A = 1  => NO MORE BLOCKS TO TX
;A > 1 => ERROR

MOVEON ROUT
 SEC
 LDA NBLKS
 SBC MPTMPD
 STA NBLKS
 LDA NBLKS+1
 SBC MPTMPD+1
 STA NBLKS+1
 ORA NBLKS
 BNE #10
 LDAIM 1 ;RC:=1 if no more blocks
 RTS

10 CLC ;INCREMENT STORE ADDRESS
 LDA DCSTAD+1
 ADC MPTMPD
 STA DCSTAD+1
 BCC #20
 LDAIM DCERRB ;STORE ADDR GONE ILLEGAL
 JSR INTERR
20 JSR NXTEN ;UPDATE MAPTMP & MPSCPT
 JMP SETSZE


XFER ROUT
 LDAIM 1
 STA DDRSZE+1
 LDAIM 0
 JMP #10

XFERIN LDA MPTMPD
 STA DDRSZE+1
 LDA MPTMPD+1
10 STA DDRSZE
 LDA DCSTAD
 STA DDRSTA
 LDA DCSTAD+1
 STA DDRSTA+1
 LDA SAVCOM ;A:=TYPE OF TRANSFER (READ/WRITE)
 JSR TRANS
 BEQ #40 ;is ok, end NMI
 STA DCRASH  ;record fault
40 RTS


;Block read and write
;   On entry::
;      DRIVNO holds the drive number
;      DDRSTA holds the start address
;      CSECTR holds the start sector number
;      CTRACK holds the start track number
;      DDRSZE holds the number of sectors to transfer

 [ WINCH=0
BLKRD ROUT
 LDAIM &08 ;COMMAND FOR READ
TRANS STA DSCCB+CMD
 LDA DRIVNO
 CLC
 RORA
 RORA
 RORA
 RORA
 ORA RBDA+2
 STA DSCCB+CMD+1
 LDA RBDA+1
 STA DSCCB+CMD+2
 LDA RBDA
 STA DSCCB+CMD+3

;test for writing to sector zero

 LDA RBDA
 ORA RBDA+1
 ORA RBDA+2
 BNE #10
 
 LDAIM IERRAK ;writing to sector zero
 JMP INTERR ;***

10 LDA DDRSTA
 STA DSCCB+TRADD ; SAVE THE ADDRESS
 LDA DDRSTA+1
 STA DSCCB+TRADD+1
 LDA DDRSZE+1 ;CHECK FOR END OF TRANSFER
 STA DSCCB+LENGTH+1
 LDA DDRSZE
 STA DSCCB+LENGTH+2
 LDAIM 0
 STA DSCCB
 STA DSCCB+LENGTH
 STA DSCCB+LENGTH+3
 STA DSCCB+CMD+4
 STA DSCCB+CMD+5
 JMP DSCCMD ;DO THE TRANSFER

 |

BLKRD ROUT
 LDAIM &53 ;COMMAND FOR READ
TRANS STA DSCCB+CMD
 LDA DRIVNO
 STA DSCCB ;SAVE THE DRIVE NUMBER
 LDA DDRSTA
 STA DSCCB+TRADD ; SAVE THE ADDRESS
 LDA DDRSTA+1
 STA DSCCB+TRADD+1
 LDAIM 3 ;NUMBER OF PARAMETERS
 STA DSCCB+NOPRMS
10 LDA DDRSZE ;CHECK FOR END OF TRANSFER
 ORA DDRSZE+1
 BNE #20
15 RTS

20 SEC
 LDAIM &A ;MAX NUMBER OF SECTORS
 SBC CSECTR ;MAX WE CAN TRANSFER
 STA DSCCB+PARAMS+2
 LDA DDRSZE ;IF THIS IS NON-ZERO TRANS CANNOT HAVE FINISHED
 BNE #30
 LDA DSCCB+PARAMS+2 ;DO WE NEED THIS MANY
 CMP DDRSZE+1
 BMI #30 ;SKIP IF NOT
 LDA DDRSZE+1
 STA DSCCB+PARAMS+2 ;ONLY TRANSFER AMOUNT REQUIRED
30 LDA CSECTR
 STA DSCCB+PARAMS+1 ;SAVE SECTOR NUMBER
 LDA CTRACK
 STA DSCCB+PARAMS ;SAVE TRACK NUMBER
 LDAIM &20 ;256 BYTES PER SECTOR
 ORA DSCCB+PARAMS+2
 STA DSCCB+PARAMS+2
 JSR DSCCMD ;DO THE TRANSFER
 BNE #15 ;OOPS! FAILED
 LDAIM &00 ;FROM NOW ON START AT SECTOR ZERO
 STA CSECTR
 INC CTRACK ;NEXT TRACK
 LDA DSCCB+PARAMS+2
 ANDIM &F ;GET NUMBER OF SECTORS
 STA CNTA
 SEC
 LDA DDRSZE+1
 SBC CNTA ;SUBTRACT FROM TOTAL
 STA DDRSZE+1
 LDA DDRSZE
 SBCIM 0
 STA DDRSZE
 CLC
 LDA DSCCB+PARAMS+2
 ANDIM &F
 ADC DSCCB+TRADD+1
 STA DSCCB+TRADD+1
; LDA DSCCB+TRADD+2 ;** 15/2/85 ** dangerous !
; ADCIM &00
; STA DSCCB+TRADD+2
 JMP #10 ;GET THE REST
 ]

 [ WINCH=0
DSCCMD ROUT
 [  0=1
 LDYIM 16
00 LDAAY DSCCB
 JSR WHEX
 DEY
 BPL #00
 LDAIM "r"
 JSR OSWRCH
 JSR OSCRLF

 ]
 LDAIM 0
 STA DSCCB

 LDXIM :LSB:DSCCB
 LDYIM :MSB:DSCCB
 LDAIM &72
 JSR OSWORD
 LDA DSCCB
 BEQ #05  ; REPORT DISC ERRORS TO SCREEN 5/6/86 LH
 JSR #10
05 RTS 

10 PHA
 LDAIM &73
 LDXIM DSCCB
 LDYIM /(DSCCB )
 JSR OSWORD
 JSR VSTRIN
 = "Disc Error No. "
 NOP
 LDA DSCCB+3
 JSR WHEX
 JSR VSTRIN
 = " At Disc Address "
 NOP
 LDA DSCCB+2
 JSR WHEX
 LDA DSCCB+1
 JSR WHEX
 LDA DSCCB
 JSR WHEX
 PLA
 RTS

 |
;DSCCMD
;   SEND A COMMAND TO THE DISC CONTROLLER
;   DSCCB IS THE CONTROL BLOCK AND MUST BE SET UP
;   TRIES ANY ERROR 10 TIMES
;   RETURNS WITH Z SET IF OK
;   IF FAILED RETURNS WITH ERROR NUMBER
DSCCMD ROUT
 LDAIM &A ;COUNT
 STA CNTA
10 LDXIM :LSB:DSCCB
 LDYIM :MSB:DSCCB
 LDAIM &7F
 JSR OSWORD
 LDA DSCCB+PARAMS+3 ;LOOK AT REPLY
 BEQ #20
 DEC CNTA
 BNE #10 ;TRY AGAIN IF ERROR
 LDA DSCCB+PARAMS+3
20 RTS ;RETURN WITH CORRECT ERROR NUMBER
 ]

DCCACH ROUT
 LDYIM ARGJ ;get MS number of blocks to load
 LDAIY ARGPTR
 BNE #40 ;exit 'cos its too big
 DEY ;get LS number of blocks
 LDAIY ARGPTR
 CMP IOBSIZ+1
 BEQ #10
 BCS #40 ;overflow here

DCCACF
10 LDYIM ARGL
 LDXIM 10
 LDAIM 0
 STA GENPTR ;spare space

20 LDAIY ARGPTR
 CMPAX ODSCMN ;look against old stack
 BEQ #30
 INC GENPTR ;unzero flag
30 STAAX ODSCMN ;save stack
 DEY
 DEX
 BPL #20 ;loop until done

 LDA GENPTR ;load flag
40 RTS

DCSIN ROUT
 LDYIM ARGB
 LDXIM 0
10 LDAIY ARGPTR
 CMPAX ODSCMN ;compare against old cache
 BNE #20
 INY
 INX
 CPXIM 5 ;test disc number & SIN
 BNE #10
 LDXIM &FF
 STX ODSCMN ;invalidate cache
 STX ODSCMN+1
20 RTS ;return to main routine

 LNK UADE15
