 OPT UADE06 ;FILE > Uade06
 TTL File server file UADE06


;**********************************
;*           U S R M A N          *
;**********************************

;USRMAN: USRMAN (THE USER TABLE MANAGER)
;KEEPS INFORMATION ABOUT LOGGED ON USERS.
;USRMAN MAINTAINS A DATA STRUCTURE
;KNOWN AS THE USERTB. THIS TABLE
;CONTAINS INFORMATION ABOUT WHICH
;USERS ARE LOGGED ON, THE
;NUMBER OF THE MACHINE, HANDLES
;FOR UFD & CURRENTLY SELECTED DIRECTORY,
;AND OTHER USER STATE INFORMATION.

;THE USERTB CONTAINS THE FOLLOWING INFO:-
;0) MACHINE NUMBER (2 BYTES)
;1) USERID (4 BYTES)
;2) CURRENT SELECTED DISC NUMBER (2 BYTES)
;3) SYSTEM PRIVILEGE FLAG
;4) HANDLE FOR UFD (USER FILE DIR) (1 BYTE)
;5) HANDLE FOR SELECTED DIR
;6) HANDLE BYTE (A RECORD OF WHICH HANDLES ARE INUSE)


;************ MAIN ROUTINE ************


USRMAN LDXIM 9 ;USRMAN HAS 9 ENTRY POINTS
 LDAIM MODUSR ;A:=NAME OF THIS MODULE
 JSR ENTRY
 LDAAX USRTNS
 STA USJUMP + 1
 LDAAX USRTNS + 1
 STA USJUMP + 2
 LDAIM 15
 JSR SETFS
USJUMP JMP USJUMP
USEXIT JMP PREXIT
USRTNS
 & USNWMC ;1 => REGISTER A MACHINE(LOGON)
 & USDLMC ;2 => DELETE MACHINE FROM USERTB(LOGOFF)
 & USSDSC ;3 => SELECT DISC
 & USREST ;4 => RESTART
 & USSDIR ;5 => SELECT DIRECTORY
 & USUSER ;6 => USER INFO (PRIV & MC/NO OF GIVEN USERID)
 & USUSRS ;7 => LOGGED ON USERS
 & USQUIT ;8 => update all users free space ** 3/10/84 **
 & USFREE ;9 => update single user allocation


;************ USNWMC ************

;USNWMC: USRMAN.NEW MACHINE (LOGON)
;ENTRY: ARGB,C = (MC/NO)
;ARGD,E = (PTR TO USERID FOLLOWED BY PASSWORD)

;EXIT : ARGA = RC
;ARGB,C = (PTR TO USERINFO)
;ARGD = UFD HANDLE
;ARGE = CSD HADLE
;ARGF = LIB HANDLE
;ARGG = Option bits (bottom two)
;ARGH = Privilege ** 27/9/84 **

;FUNCTION: -

;IF machine already in USERTB (I.E. LOGGED ON)
;THEN close all open files,
;close all open dirs;
;remove USERTB entry
;FI;

;check validity of password;read option bits

;FOR each drive WHILE NOT found
;DO IF $.USERID exists
;THEN get handles for ufd, library and selected dir;
;found := TRUE
;FI
;OD;

;IF NOT found
;THEN use root dir for ufd, library & selected dir
;FI

USNWMC JSR CHKMC ;LOGGED ON ?
 BNE USNWA
 JSR LOGOFF
 JMP USNWC

;FIND A FREE USERTB ENTRY

USNWA LDA MCTEMP ;MCTEMP SET BY CHKMC
 ORA MCTEMP + 1
 BNE USNWC
 LDAIM URERRF ;RC:=M/C NUMBER = ZERO
 JMP USNWY

;CHECK PASSWORD

USNWC LDYIM ARGA
 LDAIM 2 ;AUTMAN.CHECKPW
 STAIY NEWARG
 LDYIM ARGD
 LDAIY ARGPTR
 STAIY NEWARG ;LS(PTR TO USERID FOLLOWED BY PW)
 INY ;Y:= ARGE
 LDAIY ARGPTR
 STAIY NEWARG ;MS(PTR TO USERID)
 JSR AUTMAN
 BNE USNWY1

 JSR INITUS ;USTPTR:=USERTB,X:=USERS
 LDYIM UTPRIV
USNWB LDAIY USTPTR ;HOLDS THE INUSE FLAG
 BEQ USNWCA
 JSR INCUST
 BNE USNWB
USSYSX LDAIM URERRB ;RC:=USERTB FULL
USNWY1 JMP USNWY

;SETUP USERTB ENTRY

USNWCA LDYIM ARGF
 LDAIY NEWARG ;Read PW Flag byte
 STA USTEMP ;Store so can return option bits
 ORAIM INUSE ;and mark in use.
 LDYIM UTPRIV
 STAIY USTPTR ;:= INUSE + SYSTEM PRIV FLAG
 LDA MCTEMP ;(MCTEMP SET BY CHKMC)
 LDYIM UTMCNO
 STAIY USTPTR
 LDA MCTEMP + 1
 INY
 STAIY USTPTR ;MACHINE NUMBER

 LDAIM ARGB ;copy disc space into table
 STA OFF1
 LDAIM UTFREE
 STA OFF2
 LDXIM NEWARG
 LDYIM USTPTR
 LDAIM UTFRLN
 JSR MOVBLK ;** 2/10/84 **

 LDYIM ARGD
 LDAIY ARGPTR
 STA MOVFRM
 LDYIM ARGE
 LDAIY ARGPTR
 STA MOVFRM + 1
 CLC
 LDA USTPTR
 ADCIM UTUSID
 STA MOVTO
 LDA USTPTR + 1
 ADCIM 0
 STA MOVTO + 1
 LDXIM UTDISC-UTUSID
 JSR MOVE ;COPY USERID INTO USERTB

 LDAIM 0
 LDYIM UTHNDB
 STAIY USTPTR

;NOW TRY TO FIND A UFD FOR THIS USER
;SO TRY TO RETRIEVE $.USERID BY SEARCHING ALL THE DRIVES

 LDAIM 0
 STA USWORK
 STA USWORK + 1 ;USWORK := O := DEVICE NO
USNWF LDA USWORK
 JSR DRVINF ;MAPMAN.DRIVEINFO
 BNE USNWM ;** 18/9/84 **

 JSR SUSRDI ;Set users disc no.
 JSR GETUFD ;GET HANDLES FOR UFD
 BEQ USNWY

;havn't matched full name here, so see about partial match
;** 18/9/84 **

 LDYIM MAXID+UTUSID+1 ;look for a "."
USNWMA LDAIY USTPTR
 CMPIM SEPART
 BEQ USNWMB
 DEY
 CPYIM UTUSID
 BNE USNWMA ;look right through the string
 BEQ USNWMD

USNWMB LDAIM TERMIN ;abbreviate the name string
 STAIY USTPTR
 TYA
 PHA ;save pointer across call

 LDA USWORK
 JSR DRVINF ;get drive info
 JSR SUSRDI ;set up the info
 JSR GETUFD
 TAX ;save RC

 PLA
 TAY
 LDAIM SEPART
 STAIY USTPTR ;restore the string to its former glory

 TXA ;restore RC
 BEQ USNWY ;all ok here  

USNWMD INC USWORK ;USWORK +:=1
 BNE USNWF ;try next logical drive


;IF A UFD DOES NOT EXIST ON ANY DISC THEN
;MAKE UFD := SELECTED DIR := ROOT DIR ON THE
;DISC ON DRIVE ZERO

USNWM LDAIM 0
 JSR DRVINF
 JSR SUSRDI ;Set user disc no.
 JSR GTROOT
 BEQ USNWY
 JSR LOGOFF ;CLEAN UP if no dirs available

USNWY LDYIM ARGB
 PHA ;Store return code
 LDA USTPTR
 STAIY ARGPTR
 INY
 LDA USTPTR + 1
 STAIY ARGPTR
 INY
 JSR MOVHND
 LDA USTEMP ;Read PW flag byte
 PHA
 ANDIM OPTMSK ;Mask off option bits
 LDYIM ARGG
 STAIY ARGPTR
 PLA
 INY
 ANDIM SYSTPV ;** 27/9/84 **
 STAIY ARGPTR ;return user's privilege
 PLA ;Restore return code
 JMP USEXIT


SUSRDI LDYIM ARGB
 LDAIY NEWARG
 LDYIM UTDISC
 STAIY USTPTR
 LDYIM ARGC
 LDAIY NEWARG
 LDYIM UTDISC + 1
 STAIY USTPTR ;DISC NUMBER
 RTS


;************ USDLMC ************


;USDLMC: DELETE USERTB ENTRY FOR GIVEN MACHINE NUMBER

;ENTRY: ARGB = LS(PTR TO USERINFO)
;ARGC = MS(PTR TO USERINFO)

;EXIT:  ARGA = RC

;FUNCTION: FIND USERTB ENTRY AND MARK IT NOT IN USE.


USDLMC JSR SETUTP
 JSR LOGOFF
 LDAIM 0
USDLMX JMP USEXIT



;************ USSDSC ************


;USSDSC: USRMAN.SELECT DISC

;ENTRY: ARGB = LS(PTR TO USERINFO)
;ARGC = MS(PTR TO USERINFO)
;ARGD = LS(DISC NO)
;ARGE = MS(DISC NO)
;ARGF = CURRENT UFD HANDLE
;ARGG = CURRENT CSD HANDLE
;ARGH = CURRENT LIB HANDLE

;EXIT : ARGA = RC
;ARGB = NEW UFD
;ARGC = NEW CSD
;ARGD = NEW LIB

;FUNCTION:-
;IF specified disc loaded
;THEN close ufd, library & selected dir;
;IF $.USERID exists on selected dir;
;THEN get handles for ufd, library & selected dir
;ELSE ufd:=selected dir:=library:=root dir
;FI


USSDSC JSR SETUTP ;SETUP USTPTR TO POINT INTO USERTB

;FIRST, SEE WHETHER SPECIFIED DISC IS LOADED

 LDYIM ARGD
 LDAIY ARGPTR
 STA USDISC
 INY
 LDAIY ARGPTR
 STA USDISC + 1 ;USDISC:=SELECTED DISC NUMBER

 LDYIM ARGC
 STAIY NEWARG
 DEY ;Y:=ARGB
 LDA USDISC
 STAIY NEWARG
 DEY ;Y:= ARGA
 LDAIM 4 ;MAPMAN.SINOFROOT
 STAIY NEWARG
 JSR MAPMAN
 BNE USSDCY

;NOW CLOSE THREE HANDLES FOR
;OLD DISC

 LDYIM ARGF
 LDAIY ARGPTR
 JSR CLOSE
 BNE USSDCY
 LDYIM ARGG
 LDAIY ARGPTR
 JSR CLOSE
 BNE USSDCY
 LDYIM ARGH
 LDAIY ARGPTR
 JSR CLOSE
 BNE USSDCY
;PUT SELECTED DISC NUMBER INTO THE USERTB

 LDYIM UTDISC
 LDA USDISC
 STAIY USTPTR
 INY
 LDA USDISC + 1
 STAIY USTPTR

;SEE IF A UFD EXISTS IN THE ROOT DIR FOR THIS USER

 JSR GETUFD
 BEQ USSDCY

;OTHERWISE MAKE THE ROOT DIR THE UFD, LIB  & SELECTED DIR

 JSR GTROOT

USSDCY LDYIM ARGB
 JSR MOVHND ;PUT HANDLES ON STACK
 JMP USEXIT



;************ USREST ************


;USREST: RESTART
;1) CALL GETVEC TO GRAB AN AREA
;OF STORE FOR THE USERTB.
;2) SETUP THE VARAIBLE (USERTB)
;TO POINT TO THIS AREA.
;3) CALL CLRSTR TO INITIALISE THE
;WHOLE TABLE TO ZERO.


USREST LDX USERS
 LDYIM UTENSZ
 JSR SETTAB
 STY USERTB
 STX USERTB + 1
 LDAIM 0
 STA USSYS ;priv'd user logged-on flag
 JMP USEXIT



;************ USSDIR ************


;USSDIR: USRMAN.SELECT DIRECTORY

;ENTRY: ARGB = LS(PTR TO USERINFO)
;ARGC = MS(PTR TO USERINFO)
;ARGD = LS(PTR TO DIR TITLE)
;ARGE = MS(PTR TO DIR TITLE)
;ARGF = UFD HANDLE
;ARGG = CURRENT SEL. DIR. HND

;EXIT : ARGA = RC
;ARGB = HANDLE FOR NEW CSD

;FUNCTION:-

;IF dir title = null string
;THEN make the current selected dir=ufd
;ELIF directory exists
;THEN open selected dir;
;close old selected dir
;ELSE return error
;FI


USSDIR JSR SETUTP ;SETUP USTPTR

 LDYIM ARGF
 LDAIY ARGPTR
 STA UMHUFD
 INY
 LDAIY ARGPTR
 STA UMHCSD
;FIRST, RETRIEVE THE DIRECTORY

 LDYIM ARGD
 LDAIY ARGPTR
 STA TITPTR
 STA GENPTR
 INY
 LDAIY ARGPTR
 STA TITPTR + 1 ;TITPTR := ADDR OF DIR NAME
 STA GENPTR + 1 ;GENPTR := PTR TO DIR TITLE

 LDYIM 0
 LDAIY GENPTR
 CMPIM TERMIN
 BNE USSDRK

;NOW CALL RNDMAN TO CREATE A COPY OF THE HANDLE
;FOR THE UFD.

 LDA UMHCSD
 JSR CLOSE ;CLOSE OLD SELECTED DIR.
 BNE USSDRY

 LDYIM ARGA
 LDAIM 5 ;RNDMAN.COPY
 STAIY NEWARG
 JSR SETUSR

 LDA UMHUFD ;SET USER ROOT TO COPY
 LDYIM ARGD
 STAIY NEWARG ;= HANDLE OF UFD
 JSR RNDMAN ;RNDMAN.COPY
 BNE USSDRY

 LDYIM ARGE
 LDAIY NEWARG ;HANDLE FROM RNDMAN
 JMP USSDRW

USSDRK LDAIM &C1 ;accept all wild cards
 JSR RETRV ;CALL DIRMAN.RETRV & CHECK THAT ITS A DIR
 BNE USSDRY

;NOW GET A HANDLE FOR IT

 JSR OPEN ;USRHND:=HANDLE FOR NEW SELECTED DIR
 BNE USSDRY
 PHA

;NOW CLOSE THE OLD SELECTED DIR

 LDA UMHCSD
 JSR CLOSE
 BNE USSDRZ ;If this close fails, close new one too
 PLA

USSDRW LDYIM ARGB
 STAIY ARGPTR ;Set new handle
 LDAIM 0

USSDRY JMP USEXIT
USSDRZ STA TEMPA ;Store rcode
 PLA ;Pull new csd
 JSR CLOSE ;Close it
 LDA TEMPA ;Restore rcode
 BNE USSDRY ;End



;************ USUSER ************


;USUSER: USER INFO

;ENTRY: ARGB=LS(PTR TO USERINFO)
;ARGC = MS(PTR TO USERINFO)
;ARGD = LS(PTR TO USERID)
;ARGE = MS(PTR TO USERID)

;EXIT : ARGA = RC
;       ARGB = USER PRIVILEDGE
;       ARGC = MACHINE NUMBER (LO)
;       ARGD = MACHINE NUMBER (HI)
;       ARGE,F = pointer to userid information ** 5/10/84 **


USUSER JSR INITUS
 LDYIM ARGD
 LDAIY ARGPTR
 STA URMPPT ;Pointer to User Id to check
 INY
 LDAIY ARGPTR
 STA URMPPT + 1

USUSRB LDYIM UTPRIV ;Check if entry in use
 LDAIY USTPTR
 ANDIM INUSE
 BEQ USUSRF ;Nope -> continue

;NOW SEE IF USERIDS MATCH

 LDAIM UTUSID
 STA OFF2 ;Offset in user-table
 LDYIM 0 ;Offset of argument name

USUSRC LDAIY URMPPT
 STY OFF1
 CPYIM 21 ;Max user length
 BNE USUSRE ;Not at end yet -> go on

 CMPIM TERMIN ;At end, check user name given is terminated
 BEQ USUSRQ ;Yes -> found
 BNE USUSRF ;No -> continue search

USUSRE LDY OFF2
 EORIY USTPTR
 INC OFF2 ;Increment USTPTR offset for next time
 ANDIM &DF ;Complete comparison
 BNE USUSRF ;Not the same -> go on to next one

 LDY OFF1 ;Point to char. offset from USTPTR
 LDAIY URMPPT ;The same => check if end of string
 INY ;Increment for next time

 SEC
 SBCIM TERMIN
 BNE USUSRC ;Not terminators => continue search

;FOUND IT - SO COPY PRIV & MC/NO INTO STACK

USUSRQ LDYIM UTPRIV
 LDAIY USTPTR
 ANDIM SYSTPV
 LDYIM ARGB
 STAIY ARGPTR ;SYSTEM PRIV FLAG

 LDYIM UTMCNO
 LDAIY USTPTR
 LDYIM ARGC
 STAIY ARGPTR
 LDYIM UTMCNO + 1
 LDAIY USTPTR
 LDYIM ARGD
 STAIY ARGPTR ;MC/NO
 INY
 LDA USTPTR
 STAIY ARGPTR
 INY
 LDA USTPTR+1
 STAIY ARGPTR ;** 5/10/84 **

 LDAIM 0
 BEQ USUSRY

USUSRF JSR INCUST
 BNE USUSRB
 LDAIM URERRE
USUSRY JMP USEXIT


;**************** USUSRS ************

;ENTRY: ARGB = Start entry
;ARGC = No. of entries
;ARGD/E = Result buffer
;ARGF = PRIV of caller                   

;EXIT : ARGB = No. of entries found
;ARGC/D = Result end ptr.

;V. similar to examine and discs. Given entry point
;to list of users and number of entries required,
;supplies info. on as many as possible, returning
;the number found and a pointer to the byte after
;the info. for use in transmitting the data
;out to client.


USUSRS JSR INITUS ;Set USTPTR and X
 LDYIM ARGB
 LDAIY ARGPTR
 STA TEMPA ;Start entry
 INY
 LDAIY ARGPTR
 STA TEMPA + 1 ;No. of entries wanted
 INY
 LDAIY ARGPTR
 STA GENPTR ;Result ptr.
 INY
 LDAIY ARGPTR
 STA GENPTR + 1

 LDAIM &FF
 STA TEMPB ;Entry pt. counter
 LDAIM 0
 STA TEMPB + 1 ;No. of entries found
          
USURLA
USURLE LDYIM UTPRIV

;First loop round finding entries in use until
;ENTRY = TEMPA = START ENTRY

USRLHA LDAIY USTPTR
 BPL USURLB

;** skip privileged users (27/9/84)
;** Report PRIV users only to a PRIV request **

 ANDIM SYSTPV        ; They are loged on so should appear LH 21/10/85
 BNE USURLB
 INC TEMPB ;Inc. current entry
 LDA TEMPB
 CMP TEMPA ;Current >= start entry ?
 BCS USURLC ;Yes => start copying to result

USURLB JSR INCUST ;Jump to next entry
 BNE USRLHA ;If not off end of table, do again
 JMP USURLX ;Otherwise, finish

USURLC TXA
 PHA
 LDXIM 0
 LDYIM UTMCNO
 LDAIY USTPTR
 STAIX GENPTR
 INY
 JSR INCGPT
 LDAIY USTPTR
 STAIX GENPTR ;Set m/c number

 JSR INCGPT
 LDYIM UTUSID ;User id. offset
USURLD LDAIY USTPTR
 STAIX GENPTR
 JSR INCGPT
 CMPIM CR ;Is terminated ??
 BEQ USURLF

 INY
 CPYIM UTUSID+MAXUNM ;Finished ?
 BNE USURLD ;** 23/4/85 **

 [ 1=1
 LDAIM CR ;If 10 chars long, terminate with zero
 STAIX GENPTR
 ; JSR INCGPT ;** 23/4/85 **
 ]

USURLF LDYIM UTPRIV ;Get priviledge byte
 LDAIY USTPTR
 ANDIM SYSTPV
 STAIX GENPTR
 JSR INCGPT ;Point to next entry
 PLA
 TAX ;Restore table entry count

 INC TEMPB + 1 ;Inc. no. found
 LDA TEMPA + 1
 CMP TEMPB + 1 ;No. found = no. requested ?
 BEQ USURLX ;Yes => stop

 JSR INCUST ;Step through table
 BNE USURLE ;Do again

USURLX LDYIM ARGB
 LDA TEMPB + 1
 STAIY ARGPTR
 INY
 LDA GENPTR
 STAIY ARGPTR
 INY
 LDA GENPTR + 1
 STAIY ARGPTR
 LDAIM 0
 JMP USEXIT


;*******************

USQUIT JSR INITUS ;setup USTPTR
USQULA LDYIM UTPRIV ;scan for inuse entries
 LDAIY USTPTR
 BEQ USQULB
 TXA ;preserve X over LOGOFF call
 PHA
 JSR USENS ;ensure all free space entries up to date
 PLA
 TAX
USQULB JSR INCUST
 BNE USQULA
 JMP USEXIT ;end of routine


USFREE ROUT ;** 6/2/85 **

 LDA USTPTR
 PHA
 LDA USTPTR+1
 PHA ;save this value over call

 JSR INITUS ;update all incarnations of a user free space
 STX USTEMP ;save counter
 
10 LDYIM ARGB
 LDAIY ARGPTR
 STA GENPTR
 INY
 LDAIY ARGPTR
 STA GENPTR+1 ;pointer to supplied name

 LDYIM UTPRIV
 LDAIY USTPTR
 ANDIM INUSE
 BEQ #50 ;not in use so skip

 LDXIM 0
 LDYIM UTUSID
20 LDAIY USTPTR
 EORIX GENPTR
 ANDIM &DF
 BNE #50
 LDAIY USTPTR
 CMPIM TERMIN
 BEQ #40 ;end of name

 INC GENPTR
 BNE #30
 INC GENPTR+1

30 INY
 CPYIM MAXID+UTUSID+1
 BNE #20 ;continue

40 LDAIM ARGD ;update the free space
 STA OFF1
 LDXIM ARGPTR
 LDAIM UTFREE
 STA OFF2
 LDYIM USTPTR
 LDAIM 4 ;arguments supplied on stack
 JSR MOVBLK

50 JSR INCUST
 DEC USTEMP
 BNE #10 ;not end of table

 PLA
 STA USTPTR+1
 PLA
 STA USTPTR

 LDAIM 0
 JMP USEXIT

 
SETUTP LDYIM ARGB ;SETUP USTPTR
 LDAIY ARGPTR
 STA USTPTR
 INY
 LDAIY ARGPTR
 STA USTPTR + 1
 RTS


CHKMC LDYIM ARGB ;SEE IF MACHINE LOGGED ON
 LDAIY ARGPTR
 STA MCNUMB ;N.B. USE MCTEMP BECAUSE MCNUMB IS USED GLOBALLY
 STA MCTEMP ;=LS(MC/NO)
 LDYIM ARGC
 LDAIY ARGPTR
 STA MCNUMB + 1
 STA MCTEMP + 1 ;=MS(MC/NO)
 JSR FINDMC
 RTS


RETRV LDYIM ARGH ;A passed in call
 STAIY NEWARG ;wild card flag

 LDYIM ARGA ;RETRIEVE DIR FOR USRMAN
 LDAIM 2 ;DIRMAN.RETRIEVE
 STAIY NEWARG
 JSR SETUSR ;MOVE USTPTR ONTO NEWARG STACK
 LDYIM ARGD
 LDA TITPTR
 STAIY NEWARG
 INY
 LDA TITPTR + 1
 STAIY NEWARG ;PTR TO DIR NAME
 INY
 LDAIM USRINF
 STAIY NEWARG
 INY
 LDAIM /(USRINF) ;ADDRESS OF DETAILS AREA
 STAIY NEWARG
 JSR DIRMAN
 BNE RETRVZ
 LDYIM ARGB
 LDAIY NEWARG
 STA USRACC ;USRACC:=ACCESS TO OBJECT
 ANDIM TYPDIR
 BNE RETRVX
 LDAIM URERRD ;RC:=OBJECT NOT A DIR
 BNE RETRVZ
RETRVX LDAIM 0 ;RC := 0
RETRVZ RTS


SETUID LDYIM UTUSID ;Copy userid from USERTB to USRUFD
SETUIL LDAIY USTPTR ;Copies all chars regardless of termination
 STAAY USRUFD -UTUSID
 INY
 CPYIM UTUSID +MAXUNM
 BNE SETUIL
 RTS


MAKHDS JSR OPEN ;MAKE HANDLES FOR UFD & SELECTED DIR
 BNE MAKHSZ

;MAKE THIS THE HANDLE FOR THE UFD

 STA UMHUFD

;NOW GET A HANDLE FOR SELECTED DIR

 JSR OPEN
 BEQ MAKHSG
 PHA
 JSR CLUFDR ;CLOSE UFD
 PLA
 JMP MAKHSZ
MAKHSG STA UMHCSD
 LDAIM 0

MAKHSZ RTS



OPEN LDYIM ARGA ;CALL RNDMAN.OPEN FOR DIR IN USRINF
 LDAIM 1 ;RNDMAN.OPEN
 STAIY NEWARG
 JSR SETUSR ;COPY USTPTR ONTO NEWARG STACK
 LDYIM ARGD
 LDAIM 0 ;MODE := 0
 STAIY NEWARG
 INY ;Y:=E
 LDA USRACC
 STAIY NEWARG
 INY ;Y:=ARGF
 LDAIM USRINF
 STAIY NEWARG
 INY
 LDAIM /(USRINF)
 STAIY NEWARG ;PTR TO OBJECT DETAILS
 JSR RNDMAN
 BNE OPENZ
 LDYIM ARGB
 LDAIY NEWARG
 LDYIM 0
OPENZ RTS


SETUSR LDYIM ARGB ;MOVE USTPTR ONTO NEWARG STACK
SETUSA LDA USTPTR
 STAIY NEWARG
 INY
 LDA USTPTR + 1
 STAIY NEWARG
 RTS


;LOGOFF: CLOSE ALL HANDLES OPENED BY M/C & FREE USERTB ENTRY

LOGOFF PHA
 LDAIM 6
 LDYIM ARGA
 STAIY NEWARG
 JSR SETUSR
 JSR RNDMAN ;*** CLOSE ALL ENTRIES **
 BEQ OFFONA

LOGFFC TAY
 PLA ;Restore stack
 TYA
 BNE LOGFFX

;NOW CLEAR USERTB ENTRY TO ZERO

OFFONA JSR USENS ;update all free space entries
 BNE LOGFFC
 LDYIM UTPRIV ;check for priv'd user
 LDAIY USTPTR ;** 27/9/84 **
 ANDIM SYSTPV
 BEQ OFFONB ;not priv'd
 DEC USSYS ;decrement counter
OFFONB LDAIM 0
 TAY
 LDXIM UTENSZ ;X := UTENSZ
LOGFFG STAIY USTPTR
 INY
 DEX
 BNE LOGFFG
 PLA
LOGFFX RTS


USENS CLC ;** 2/10/84 **
 LDYIM ARGD
 LDA USTPTR
 ADCIM UTUSID
 STAIY NEWARG ;nb ARGB,C unused here

 INY
 LDA USTPTR+1
 ADCIM /UTUSID
 STAIY NEWARG

 LDAIM UTFREE
 STA OFF1
 LDAIM ARGF
 STA OFF2
 LDXIM USTPTR
 LDYIM NEWARG
 LDAIM UTFRLN
 JSR MOVBLK

 LDAIM 8 ;ensure free store in PW file
 JSR SETRTN
 JMP AUTMAN


CLOSE LDYIM ARGD
 STAIY NEWARG
 LDYIM ARGA
 LDAIM 3 ;RNDMAN.CLOSE
 STAIY NEWARG
 JSR SETUSR ;PLACE PTR TO USERINFO ON NEWARG STACK
 JMP RNDMAN


CLUFDR LDA UMHUFD ;CLOSE UFD
 BEQ CLUFDZ
 JSR CLOSE
 PHA
 LDAIM 0
 STA UMHUFD
 PLA
CLUFDZ RTS


CLSLDR LDA UMHCSD
 BEQ CLSLDZ
 JSR CLOSE
 PHA
 LDAIM 0
 STA UMHCSD
 PLA
CLSLDZ RTS


;GETUFD: SEE IF THERE IS A UFD IN THE ROOT DIR ON
;CURRENTLY SELECTED DISC.
;IF THERE IS A UFD THEN MAKE HANDLES FOR
;THE UFD & THE CURRENTLY SELCECTED DIRECTORY.
;ALSO SEARCH FOR LIB. IF FOUND, GET HANDLE
;FOR IT, IF NOT LIB:=CSD/UFD

;EXIT: A := RC


GETUFD LDAIM ROOT
 STA USRROT
 LDAIM SEPART
 STA USRSEP
 JSR SETUID ;COPY USERID INTO USRUFD
 LDAIM TERMIN
 STA USRTER
 LDAIM USRROT
 STA TITPTR
 LDAIM /(USRROT)
 STA TITPTR + 1
 LDAIM 0 ;no wild cards here
 JSR RETRV ;RETRIEVE OBJECT
 BNE GETUFZ
 LDAIM OWNER
 ORA USRACC ;ACCESS TO DIR
 STA USRACC ;OWNER ACCESS TO UFD
 JSR MAKHDS
 BNE GETUFZ

 JSR GETLBH ;Search for lib.
GETUFZ RTS


GTROOT JSR RTROOT
 BNE GTROTZ
 JSR MAKHDS ;MAKE HANDLES
 BNE GTROTZ
 JSR GETLBH ;LOOK FOR LIB FILE
GTROTZ RTS

RTROOT LDAIM ROOT
 STA USRROT
 LDAIM TERMIN
 STA USRSEP
 LDAIM USRROT
 STA TITPTR
 LDAIM /(USRROT)
 STA TITPTR + 1
 LDAIM 0 ;no wild cards here
 JMP RETRV ;RETRIEVE ROOT DIR



GETLBH

;TRY TO RETRIEVE FILE "LIBRARY".
;IF FOUND, OPEN AND PUT HANDLE
;IN LIB. LOCATION. IF NOT, OPEN
;ROOT, WHICH WILL BE LIBRARY

;** 15/9/83 **

 LDYIM UTDISC
 LDAIY USTPTR
 PHA
 INY
 LDAIY USTPTR
 PHA ;save users disc number
 LDA USTEMP
 PHA ;save

 LDAIM 0
 STA USTEMP ;spare counter
USJL1 LDA USTEMP
 JSR DRVINF ;drive exists ?
 BNE GTLBON ;no
 JSR SUSRDI

 LDAIM DEFLIB ;PTR. TO LIB. TITLE
 STA TITPTR
 LDAIM /(DEFLIB)
 STA TITPTR + 1

 LDAIM 0 ;no wild cards here
 JSR RETRV

 BEQ GTLBOA ;OK, FOUND SO OPEN
 CMPIM DRERRC
 BNE GTLBAB ;IF ERROR NOT "NOT FOUND", ABORT

 INC USTEMP
 JMP USJL1 ;loop until all drives tried

GTLBON

;NOW CHECK IF ROOT ALREADY RETRIEVED
;(IF USING ROOT AS CSD FOR EXAMPLE),
;AND IF NOT, RETRIEVE. THEN OPEN AND RETURN
;HANDLE FOR LIB.

 LDYIM INFNAM
 LDAAY USRINF
 CMPIM ROOT
 BEQ GTLBOA ;Root retrieved, go on

 JSR RTROOT ;Otherwise, retrieve
 BNE GTLBAB

GTLBOA JSR OPEN
 BNE GTLBAB ;ABORT IF ERROR

 STA UMHLIB ;STORE HANDLE
 LDAIM 0 ;GIVE Z SET

GTLBEX TAX
 PLA
 STA USTEMP
 LDYIM UTDISC + 1 ;restore the old values
 PLA
 STAIY USTPTR
 DEY
 PLA
 STAIY USTPTR
 TXA ;restore return code
 RTS

GTLBAB PHA
 JSR CLUFDR
 JSR CLSLDR
 PLA
 BNE GTLBEX

DEFLIB = "$.library",CR

MOVHND PHA
 INY
 INY
 LDXIM 2
MHLOP LDAAX UMHUFD
 STAIY ARGPTR
 DEY
 DEX
 BPL MHLOP
 PLA
 RTS

 LNK RMAN01
