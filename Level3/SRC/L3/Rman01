 OPT RMAN01 ; FILE > Rman01
 TTL File server file RMAN01

RMNORG

 ORG RMNORG

;Set up ORG address so second pass gets
;addresses right when doing 2nd pass only

;Second pass also needs source and object
;drives correctly set.


;*********************************
;*          R N D M A N          *
;*********************************



;RNDMAN: THE RANDOM ACCESS MANAGER IS RESPONSIBLE
;FOR MAINTAINING A LIST OF OPENED OBJECTS
;(HANDTB) & FOR KEEPING VARIOUS DETAILS
;ABOUT OPENED FILES (RANDTB).
;RNDMAN PROVIDES THE FOLLOWING FUNCTIONS:-

;1) OPEN OBJECT (GIVE HANDLE)
;2) INFO (INDICATE WHETHER OPEN)
;3) CLOSE OBJECT
;4) RESTART
;5) CREATE A HANDLE FOR AN OBJECT WITH SPECD HANDLE
;6) DELETE ALL HANDLES FOR A GIVEN M/C
;7) READ BYTE FROM FILE
;8) WRITE BYTE TO FILE
;9) GETBYTES
;10) PUTBYTES
;11) Read args of open file
;12) Set args of open file
;13) Close all files for machine
;14) Set up for PUTBYTES/GETBYTES calls



;THE HANDTB CONTAINS THE FOLLOWING
;INFO:-
;0) HANDLE (1 BYTE)
;1) MC/NO (2 BYTES)
;2) TYPE AND ACCESS (1 BYTE)
;3) DISC NUMBER (2 BYTES)
;4) SIN (3 BYTES)
;5) MODE(1BYTE)-MULTIPLE READER/SINGLE WRITER
;6) RANDTB OFFSET(1 BYTE)



;********* MAIN ROUTINE ***********



RNDMAN LDXIM &F ;RNDMAN HAS 15 ENTRY POINTS
 LDAIM MODRND ;A:=NAME OF THIS MODULE
 JSR ENTRY
 LDAAX RDRTNS
 STA RDJUMP + 1
 LDAAX RDRTNS + 1
 STA RDJUMP + 2

 LDAIM &F
 JSR SETFS ;SET FRAME SIZE
 JMP RDJUMP
RDRTNS
 & RDOPEN ;1 => OPEN OBJECT (ISSUE A HANDLE)
 & RDINFO ;2 => INFO (INDICATE WHETHER OBJECT IS OPEN)
 & RDCLOS ;3 => CLOSE OBJECT (INVALIDATE HANDLE)
 & RDREST ;4 => RESTART
 & RDCOPY ;5 => GENERATE ANOTHER HANDLE FOR AN OBJECT
 & RDCLAL ;6 => DELETE ALL HANDLES FOR A USER
 & RDRDCH ;7 => READCH
 & RDWRCH ;8 => WRITECH
 & RDGBTS ;9 => GETBYTES FROM FILE
 & RDPBTS ;10 => PUTBYTES TO FILE
 & RDRDAR ;11 => Read args of file
 & RDSTAR ;12 => Set args of file
 & RDCLAF ;13 => Close all files for machine
 & RDSUBO ;14 => Set up for bytes operation
 & RDEOF ;15 => Read "end of file" status

RDJUMP JMP RDJUMP
RDEXIT JMP PREXIT



;************ RDOPEN ************


;RDOPEN: OPEN AN OBJECT & RETURN A HANDLE FOR IT.

;ENTRY: ARGB = LS(PTR TO USERINFO)
;ARGC = MS(PTR TO USERINFO)
;ARGD = MODE(HOW OBJECT SHOULD BE OPENED)
;ARGE = TYPE & ACCESS ALLOWED TO OBJECT
;ARGF = LS(PTR TO OBJECT DETAILS)
;ARGG = MS(PTR TO OBJECT DETAILS)

;NOTE:- ARGD (MODE)
;BIT 0 => READ ACCESS NEEDED
;BIT 1 => WRITE ACCESS NEEDED
;BIT 7 => FILE JUST CREATED
;RNDMAN INFORCES MULTIPLE READER - SINGLE WRITER
;INTERLOCKS.

;EXIT : ARGA = RC
;ARGB = HANDLE
;ARGC =  (LS) Station Id on 'already open' error ** 14/9/84 **
;ARGD =  (MS) Station Id on 'already open' error

;FUNCTION: MAKE HANDTB ENTRY
;IF TYPE OF OBJECT = TYPFIL
;THEN MAKE NEW RANDTB ENTRY
;FI


RDOPEN JSR INITRD ;INITIALISE MCNUMB,&GETPTR:=USERINFO,RNDPTR

;SEE IF THIS MACHINE CAN OPEN ANOTHER FILE
;AND SEE WHETHER THERE IS ANY ROOM IN THE HANDTB

 JSR GETHND ;HNDPTR:=PTR TO A FREE HANDTB ENTRY
 BNE RDOPNF
 LDYIM ARGE
 LDAIY ARGPTR ;TYPE & ACCESS

;ITS A FILE SO SEE IF THERE IS ROOM IN RANDTB


 ANDIM TYPDIR
 BNE RDOPNE ;Branch if directory

;The object is a file: must check that it can be opened
;for the requested access. (A file may be held open by
;a single writer, or by multiple readers).
;If it may be opened, then find a slot in RANDTB and
;fill it in.  A pointer to the entry in RANDTB is
;put in HANDTB (stored in 2 bytes).

 JSR RDCKAC ;Check access allowed (corrupts HNDPTR)
 BEQ RDOPJ ;all ok

 CMPIM RDERRH
 BNE RDOPNF ;special case for 'already open'

 [ 1=1
 PHA ;save the error ** 14/9/84 **
 LDYIM HTMCNO
 LDAIY HNDPTR ;get the station number
 PHA
 INY
 LDAIY HNDPTR ;both bytes

 LDYIM ARGD
 STAIY ARGPTR
 DEY
 PLA
 STAIY ARGPTR
 PLA ;restore the error

 JMP RDOPNF ;No
 ]

RDOPJ JSR GETHND ;HNDPTR := free HANDTB entry
 BNE RDOPNF ;Didn't get one

 JSR GETRND ;RTEPTR := free RANDTB entry
 BEQ RDOPNG ;got one

RDOPNF JMP RDOPNY ;FAILED


RDOPNG LDA RTEPTR ;Store RANDTB entry ptr in HANDTB entry
 LDYIM HTRPTR
 STAIY HNDPTR
 INY
 LDA RTEPTR + 1
 STAIY HNDPTR

;Fill in new RANDTB entry (currently all zero)

 LDAIM &80 ;"In use" flag + seq num zero
 LDYIM RTINUS
 STAIY RTEPTR ;Mark entry "in use"

;Current and old sequential file pointers
;already set to zero.
;High water mark and size both set from
;file size in object details.

 LDAIM RTFSZE
 STA OFF2
 JSR MOVRD3 ;Little block move routine

;High water mark used only if the object is open for
;update.  If the file is new, then leave zero, otherwise
;set to file size.

 LDYIM ARGD ;Get mode byte
 LDAIY ARGPTR
 ANDIM FILEJC ;Test file just created
 BNE RDOPNB ;Jump if new file

;File existed before: set HWM to size

 LDAIM RTHWM
 STA OFF2
 JSR MOVRD3

RDOPNB
;Leave address of cache descriptor (hint) to
;be filled in on first read/write operation
;** END OF FILE CODE **


;FIRST MARK HANDLE IN USE (IN USERTB ENTRY)

RDOPNE JSR MHINUS ;MARK HANDLE IN USE - IN USERTB ENTRY

;NOW COPY DETAILS (HANDLE,DISC NO,SIN, ETC.)
;INTO THE HANDTB (HNDPTR WAS SET BY GETHND)

 LDYIM HTHAND
 LDA RNDTMP
 STAIY HNDPTR ;HANDLE

 LDYIM HTMCNO
 LDA MCNUMB
 STAIY HNDPTR
 INY  ;Y := HTMCNO + 01
 LDA MCNUMB + 1
 STAIY HNDPTR ;MACHINE NUMBER

 LDYIM ARGE
 LDAIY ARGPTR
 LDYIM HTACC
 STAIY HNDPTR ;TYPE & ACCESS

 LDAIM INFDIS
 STA OFF1
 LDAIM HTDISC
 STA OFF2
 LDAIM  2
 JSR MOVRD2

 LDAIM INFSIN
 STA OFF1
 LDAIM HTSIN
 STA OFF2
 LDAIM  3
 JSR MOVRD2

 LDYIM ARGD
 LDAIY ARGPTR
 LDYIM HTMODE
 STAIY HNDPTR ;MODE

 LDAIM  0 ;RC := 0

RDOPNY PHA
 LDA RNDTMP  ;A:=HANDLE
 LDYIM ARGB
 STAIY ARGPTR
 PLA
 JMP RDEXIT


MOVRD2 LDXIM RNDPTR ;Move stuff from RNDPTR
 LDYIM HNDPTR ;To HNDPTR
 JMP MOVBLK


MOVRD3 LDAIM INFSZE ;Move size from
 STA OFF1 ;RNDPTR to RTEPTR (offset already set)
 LDXIM RNDPTR
 LDYIM RTEPTR
 LDAIM  3
 JMP MOVBLK


;************ RDINFO ************


;RDINFO: SEARCH THE HANDTB TO DETERMINE WHETHER
;A PARTICULAR OBJECT IS OPEN.

;ENTRY: ARGB = LS(DISC NO)
;ARGC = MS(DISC NO)
;ARGD = LS(SIN)
;ARGE = CS(SIN)
;ARGF = MS(SIN)

;EXIT : ARGA = RC (0 => OBJECT OPEN)
;     : ARGB = MODE OF ACCESS (**28/4/83**)


RDINFO JSR INITHD ;HNDPTR:=HANDTB,X:=HTENTS
 CLC
 LDA ARGPTR
 ADCIM ARGB
 STA MOVFRM
 LDA ARGPTR + 1
 ADCIM  0
 STA MOVFRM + 1 ;MOVFRM := ARGPTR + ARGB

RDINOB LDYIM HTHAND
 LDAIY HNDPTR
 BEQ RDINOL ;ENTRY IN USE ??
 CLC
 LDA HNDPTR
 ADCIM HTDISC
 STA MOVTO
 LDA HNDPTR + 1
 ADCIM  0
 STA MOVTO + 1 ;MOVTO := HNDPTR + HTDISC

 TXA
 PHA  ;PUSH X
 LDXIM  5 ;COMPARE DISC & SIN
 JSR COMPAR
 TAY
 PLA
 TAX  ;PULL X
 TYA
 BEQ RDINOY

RDINOL JSR INCHND
 BNE RDINOB
 LDAIM RDERRE ;OBJECT NOT OPEN

RDINOY PHA ;save A
 BNE RDINOZ

 LDYIM HTMODE
 LDAIY HNDPTR ;get mode from table
 LDYIM ARGB
 STAIY ARGPTR ;for return

RDINOZ PLA
 JMP RDEXIT



;************ RDCLOS ************


;RDCLOS: CLOSE - INVALIDATE A HANDLE

;ENTRY: ARGB = LS(PTR TO USER INFO)
;ARGC = MS(PTR TO USER INFO)
;ARGD = HANDLE

;EXIT : ARGA = RC


RDCLOS JSR INITRD ;SETUP GENPTR & MCNUMB
 LDYIM ARGD
 LDAIY ARGPTR ;A := HANDLE
 BNE RDCON
 LDAIM RDERRB ;BAD HANDLE
 BNE RDCLSY

RDCON STA RNDTMP ;RNDTMP := HANDLE
 JSR FNDHND ;SEARCH HANDTB FOR THE HANDLE
 BNE RDCLSY


;NOW CLEAR HANDTB (RANDTB) ENTRY
;and mark handle free in USERTB

 JSR CLRHTE

RDCLSY JMP RDEXIT



;************ RDREST ************


;RDREST: RESTART
;CREATE BOTH HANDTB & RANDTB.
;THE VARIABLES HANDTB & RANDTB ARE INITIALISED
;TO POINT TO THE FIRST ENTRY OF BOTH
;TABLES.

;NOTE - HANDLE TABLE HAS 6*USERS ENTRIES,
;AND RAND TABLE 5*USERS ENTRIES.


RDREST ROUT
 LDA USERS ;First create handle table
 LDXIM 5
 CLC
30
 ADC USERS
 BCS #40
 DEX
 BNE #30
 BEQ #10
40
 LDAIM &FF
10
 CMPIM 9
 BCS #20
 LDAIM 9
20
 PHA
 STA HTENTS
 TAX
 LDYIM HTENSZ
 JSR SETTAB ;SET HANDLE TABLE
 STY HANDTB
 STX HANDTB + 1

 PLA
 SEC
 SBC USERS
 STA RTNENT ;Store no. of RT entries
 TAX
 LDYIM RTENSZ
 JSR SETTAB
 STY RANDTB
 STX RANDTB + 1
 LDAIM  0
 JMP RDEXIT



;************ RDCOPY ************


;RDCOPY: CREATE ANOTHER HANDLE FOR AN OBJECT
;(OOF TYPE DIR).  N.B. RNDMAN.RDCOPY IS
;USED BY USRMAN WHEN SELECTING A USER'S UFD.

;ENTRY: ARGB = LS(PTR TO USERINFO)
;AFGC = MS(PTR TO USERINFO)
;ARGD = HANDLE (FOR A DIR)

;EXIT : ARGA = RC
;ARGE = NEW HANDLE


RDCOPY ROUT
 JSR INITRD ;SETUP GENPTR & MCNUMB
 LDYIM ARGD
 LDAIY ARGPTR
 JSR FNDHND
 BNE RDCPYY
 LDA HNDPTR
 STA MOVFRM
 LDA HNDPTR + 1
 STA MOVFRM + 1 ;MOVFRM := PTR TO HANDTB ENTRY
 LDYIM HTACC
 LDAIY HNDPTR
 ANDIM TYPDIR
 CMPIM TYPDIR ;IS HANDLE FOR A DIR?
 BEQ RDCPYC
 LDAIM RDERRF ;RDCOPY ONLY AVAILABLE FOR DIRECTORIES
 JSR INTERR
RDCPYC JSR GETHND ;HNDPTR:=PTR TO FREE HANDTB ENTRY
 BNE RDCPYY
 JSR MHINUS ;MARK THE HANDLE IN USE IN USERTB
 LDA HNDPTR
 STA MOVTO
 LDA HNDPTR + 1
 STA MOVTO + 1
 LDXIM HTENSZ
 JSR MOVE ;COPY OBJECT DETAILS INTO NEW USERTB ENTRY
 LDYIM ARGE
 LDA RNDTMP ;A := HANDLE TO BE USED (SETBY GETHND)
 STAIY ARGPTR
 LDYIM HTHAND
 STAIY HNDPTR ;PUT NEW HANDLE IN HANDTB ENTRY
 LDAIM  0 ;RC:=0
RDCPYY JMP RDEXIT




;************ RDCLEAR ALL *************


;RDCLAL: DELETE ALL HANDLES BELONGING
;TO A MACHINE.

;ENTRY: ARGB = LS(PTR TO USERINFO)
;ARGC = MS(PTR TO USERINFO)

;EXIT: ARGA = RETURN CODE


RDCLAL JSR INITRD ;SET GENPTR/MCNUMB/RDUPTR
 JSR INITHD ;SET HNDPTR

RDCALA LDYIM HTMCNO ;M/C NUMBER
 LDAIY HNDPTR
 CMP MCNUMB
 BNE RDCALB
 INY
 LDAIY HNDPTR
 CMP MCNUMB + 1
 BNE RDCALB

;FOUND, SO DELETE

 LDA RDUPTR
 STA GENPTR
 LDA RDUPTR + 1
 STA GENPTR + 1 ;Ensure GENPTR pointing to right place

 TXA  ;SAVE X
 PHA
 JSR CLRHTE ;CLEAR TABLE ENTRY

 BEQ RDCALJ ;ok here
 TAX
 PLA ;tidy up stack
 TXA ;**** 17/3/83 ****
 BNE RDCAEX ;exit here

RDCALJ PLA
 TAX

RDCALB JSR INCHND ;INC. PTR
 BNE RDCALA ;(X DEC'D IN INCHND)

 LDAIM  0
RDCAEX JMP RDEXIT




;GETHND: CHOOSE A HANDLE & A SLOT IN THE HANDTB
;WHICH ARE FREE.
;NOTE THAT EACH MACHINE CAN HAVE UPTO 8 HANDLES.
;THE HANDLES CURRENTLY BEING USED BY A
;PARTICULAR MACHINE ARE RECORDED IN THE USERTB.

;ENTRY: GENPTR = PTR TO USER INFO

;EXIT : A = RC
;HNDPTR = POINTER TO A FREE HANDTB ENTRY
;RNDTMP = HANDLE TO BE USED


GETHND LDYIM UTHNDB ;HANDLE BYTE HELD IN USERTB
 LDAIY GENPTR

;FIRST SEE IF THIS MACHINE HAS A FREE HANDLE

 CMPIM &FF
 BNE GETHDC
 LDAIM RDERRC ;HANDLE QUOTA EXHAUSTED
 BNE GETHDZ
GETHDC PHA  ;PUSH A (M/C'S HANDLE BYTE)
 LDAIM  1
 STA RNDTMP
 PLA  ;PULL A
GETHDD LSRA
 BCC GETHDF ;FOUND A FREE HANDLE
 ASL RNDTMP
 JMP GETHDD

;NOW SEE IF THERE IS A FREE SLOT IN HANDTB

GETHDF JSR INITHD ;HNDPTR := HANDTB
 LDYIM HTHAND
GETHDM LDAIY HNDPTR
 BEQ GETHDZ
 JSR INCHND
 BNE GETHDM
 LDAIM RDERRD ;HANDTB FULL

GETHDZ RTS


INITRD LDYIM ARGB ;INIT GENPTR,MCNUMB,RNDPTR
 LDAIY ARGPTR
 STA GENPTR
 STA RDUPTR ;Store extra copy of user pointer INY
 INY
 LDAIY ARGPTR ;(used by RDCLAL and RDCLAF)
 STA GENPTR + 1 ;GENPTR := PTR TO USERINFO
 STA RDUPTR + 1 ;Extra copy high byte

 LDYIM UTMCNO
 LDAIY GENPTR
 STA MCNUMB
 INY
 LDAIY GENPTR
 STA MCNUMB + 1 ;MCNUMB INITIALISED

 LDYIM ARGF
 LDAIY ARGPTR
 STA RNDPTR
 INY
 LDAIY ARGPTR
 STA RNDPTR + 1 ;RNDPTR := PTR TO OBJECT INFO(SEE DIRMAN.RETR)
 RTS


MHINUS LDYIM UTHNDB ;MARK A HANDLE IN USE IN USERTB
 LDA RNDTMP ;A:=HANDLE (SEE GETHND)
 ORAIY GENPTR
 STAIY GENPTR
 RTS


;Mark handle free in USERTB
;GENPTR points at USERTB entry
;A      contains handle

MHFREE LDYIM UTHNDB ;Mark handle free in USERTB
 EORIM &FF ;Invert handle in A
 ANDIY GENPTR ;Clear handle bit
 STAIY GENPTR ;Put back in USERTB
 RTS



CLRHTE   ;CLRHTE

;CLEAR HANDLE TABLE ENTRY POINTED TO
;BY HNDPTR. IF ENTRY IS FOR A FILE,
;CLEAR CORRESPONDING RANDOM TABLE ENTRY.
;The handle bit in the USERTB entry
;(pointed to by GENPTR) is cleared.

 LDYIM HTHAND ;Get handle in A
 LDAIY HNDPTR
 JSR MHFREE ;Mark handle free in USERTB

 LDYIM HTACC
 LDAIY HNDPTR
 ANDIM TYPE
 CMPIM TYPDIR
 BEQ CLRHTA
 JSR RDFLSH ;Flush object from cache
 BNE CLRHTX ;**** 17/3/83 ****
 JSR RDSFSZ ;Set size from HWM
 JSR CLRRTE ;Clear RANDTB entry

CLRHTA LDXIM HTENSZ ;X := SIZE OF HANDTB ENTRY
 LDAIM  0
 TAY
RDCLSD STAIY HNDPTR
 INY
 DEX
 BNE RDCLSD
 LDAIM  0
CLRHTX RTS



;*** RDSFSZ ***

;If the file is open for update, then set
;its size to the HWM recorded in RANDTB.

;Entry: HNDPTR points to HANDTB entry for file

;Exit:  RC in A

RDSFSZ LDYIM HTMODE ;Get mode in which open
 LDAIY HNDPTR
 ANDIM WRITAC ;Open for writing ?
 BNE RDSFSA ;Yes

 LDAIM  0
 RTS

RDSFSA JSR SETRPT ;Set RTEPTR
 LDYIM RTHWM
 LDAIY RTEPTR ;HWM LS
 STA NEWFSZ
 INY
 LDAIY RTEPTR ;HWM CS
 STA NEWFSZ + 1
 INY
 LDAIY RTEPTR ;HWM MS
 STA NEWFSZ + 2

 JMP RDCHSZ ;Change size and exit


 LNK RMAN02
