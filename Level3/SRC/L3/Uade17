 OPT  UADE17 ;FILE > Uade17
 TTL File server file UADE17

;INFO/LOGON/PRIV. OPERATIONS ETC.



CPINFO

;Get info in m/c readable format, depending on
;argument.

;1 = creation date
;2 = load/execution addresses
;3 = size
;4 = type/access
;5 = all above 4 in order load/execute/size/access/date
;
;6 = get access, cycle (sequence) number, and last
;    component of dir. title for dir. name. NOTE
;    does not use retrieve, and does not trap "NOT
;    FOUND" error.


 JSR GETUSE
 BNE CPINLX

 LDX BPTR
 LDAAX MIDRX
 BEQ CPINLK ;Zero arg => error
 CMPIM  6
 BEQ CPDINF ;=> do directory information
 BCC CPINLA ;Otherwise, is valid arg.

CPINLK LDAIM INFERA
 BNE CPINLZ ;Abort with err. msg.

CPINLA LDAIM  0
 STA MIDTX ;Set existence flag to "does not exist"
 LDAIM INFFTO
 JSR CPRETR ;Retrieve details
 BEQ CPINLC ;Ok, continue
 CMPIM DRERRC ;If not found, alter existence flag
 BNE CPINLZ ;Not "not found" => error
 LDXIM  1 ;Length of reply
 BNE CPINLE ;Exit, sending reply

CPINLC INC MIDTX ;Set flag to "is a file"
 LDX BPTR
 LDAAX MIDRX ;Check arg.
 LDXIM  1 ;Offset for COCOPY
 CMPIM  5 ;Is "all args" ?
 BNE CPINLB ;Nope, continue

 JSR CPYLXS ;Yep, copy all args
 BEQ CPINJA ;Always jump

CPINLB JSR COCOPY ;Copy relevant amount of stuff COWORK->MIDTX

CPINJA LDYIM ARGB ;check for OWNER/PUBLIC
 LDAIY NEWARG
 ANDIM OWNER
 BEQ CPINJ
 LDAIM -1
CPINJ EORIM -1 ;invert byte [Owner => 0]
 STAAX MIDTX ;put this at the end of the information
 INX

CPINLD LDYIM INFACC
 LDAAY COWORK
 ANDIM TYPDIR ;Check if is a directory
 BEQ CPINLE ;Is not -> continue
 INC MIDTX ;Is => set flag to 2 => directory

CPINLE LDAIM  0
 STA CCODE ;Set command code
 TXA ;Length of information transfered
 CLC
 ADCIM TXHDR
 JSR REPLYC ;Send reply
CPINLX JMP COMRTS

CPINLZ
 [ 1=0
 JSR EXTERR
 JMP CPINLX ;Abort
 |
 JMP ERROR
 ]

CPDINF JSR STKUSA ;Set user info. on stack
 LDAIM  3
 STA COZERO ;Offset for dir. name result
 LDAIM HDRLEN + 1 ;Offset of dir. name arg.
 LDXIM &C1 ;force directory here
 JSR DIRIN2 ;Get dir. infomation
 BNE CPINLZ

 LDYIM ARGD ;Now set access & sequence number
 LDAIM  0
 STA MIDTX +NAMLNT+ 3 ;Zero => owner, $FF => public
 STA MIDTX + 1
 LDAIM OWNER
 ANDIY NEWARG ;Check access to dir.
 BNE CPINL7 ;Is owner, continue
 DEC MIDTX +NAMLNT+ 3 ;Otherwise, give $FF

CPINL7 INY
 LDAIY NEWARG
 STA MIDTX +NAMLNT+ 4 ;Set sequence number of dir.
 LDAIM NAMLNT
 STA MIDTX + 2 ;Set length of dir. name
 LDXIM NAMLNT+ 5 ;Length of message - TXHDR
 BNE CPINLD ;Exit with reply (Note MIDTX undefined)

CPIXTB =  2 ;Table of length of data
 =  8
 =  3
 =  1

CPIATB = INFDTE  ;Offset of data in COWORK
 = INFLOA
 = INFSZE
 = INFACC



CPYLXS 

;Copy load/exec/size/access/date into MIDTX

 LDAIM  2
 JSR COCOPY ;Load/exec
 LDAIM  3
 JSR COCOPY ;Size
 LDAIM  4
 JSR COCOPY ;access
 LDAIM  1 ;creation date

;Fall through into last call of COCOPY

COCOPY

;Copy some object attribute from COWORK into MIDTX
;offset by X. Attribute length and value is determined
;by A on entry which indexes into two tables

 TAY
 LDAAY CPIXTB - 1
 STA COTEMP ;Set length to copy
 LDAAY CPIATB - 1
 TAY  ;Get offset in COWORK
COCOP1 LDAAY COWORK
 STAAX MIDTX
 INY
 INX
 DEC COTEMP
 BNE COCOP1
 RTS  ;Note assumed elsewhere always exit EQ





CPSTAT

;Set object attributes according to arg.

;1 => set load/execute/access
;2 => set load address
;3 => set execute address
;4 => set access byte
;5 => set date bytes ** 5/9/84 **

;Basically just a call to DIRMAN.SETATTRIBS


 JSR STKUSE
 BNE CPINLZ

 LDX BPTR
 LDAAX MIDRX
 BEQ ATTL1
 CMPIM 6 ;** 5/9/84 **
 BCC ATTL2 ;Arg ok, continue

ATTL1 JMP CPINLK ;Error in arg.

ATTL2 TAY
 LDAAY DRSAT2 - 1 ;Note uses table in DIPMAN to get data length
 BEQ ATTLXX ;If setting zero number of bytes, exit

 CLC
 ADCIM HDRLEN + 1 ;Get offset of file title in RX buffer
 LDYIM ARGC
 JSR SETFTP ;Set pointer to file title

 INY ;ARGF here
 LDAIM &C0
 STAIY NEWARG ;wild card flag

 LDX BPTR
ATTL3 INY
 LDAAX MIDRX ;Load arg. to DIRMAN.SETATTRIBS
 STAIY NEWARG
 INX
 CPYIM ARGH + 9
 BNE ATTL3

;Stack now all set, call DIRMAN.SETATTRIBS

 LDAIM  4
 JSR SETRTN
 JSR DIRMAN
ATTLXX JSR RCODE
 JMP COMRTS


CPDEL

;Non-command line call to delete object, and return
;object information after deletion.

 JSR STKUSE
 BNE CPDELX
 LDAIM HDRLEN ;Offset of file title
 JSR CPRETR ;Retrieve details of object to delete
 BNE CPDELX ;No good, error

 LDYIM ARGA
 JSR SETUSE ;Reset user pointer on stack
 LDAIM HDRLEN ;File title offset
 JSR SETFTP ;Set file title pointer
 LDAIM  3
 JSR SETRTN

 LDYIM ARGG
 LDAIM &80
 STAIY NEWARG ;wild card flag

 JSR DIRMAN ;** Call DIRMAN.DELETE **
 BNE CPDELX ;Error

 LDXIM  0 ;Set offset from MIDTX for file details
 JSR CPYLXS ;Copy the whole lot over
 CLC
 TXA
 ADCIM TXHDR ;Length of message
 JSR REPLYC ;Send message back
 JSR OBJCLR ;Clear object out of map
 BNE CPDELX ;error returned here
  ;**** 17/3/83 ****
 JMP COMRTS ;And finish

CPDELX JSR RCODE ;Send error return
 JMP COMRTS ;And finish




USRENV

;Return user environment information.
; 1) Call DIRMAN.EXAMINE to get dir. name, and disc
;    number of CSD.
; 3) Call MAPMAN.DISCNAME to get name of disc with
;    given disc number.
; 4) Call DIRMAN.EXAMINE to get title of LIB.

 JSR GETUSE
 BNE USRENX

 LDX BPTR
 LDAIM TERMIN
 STAAX MIDRX ;Fool DIRINF into getting CSD info.

 LDAIM  17 ;Offset from MIDTX for dir. title
 JSR DIRINF ;Read dir. information
 BNE USRENZ ;Error -> bomb out
 
 LDAIM  1 ;Offset from MIDTX for disc name
 JSR CPDNAM ;Read disc name (note assumes disc no. on stack)
 BNE USRENZ

 LDX BPTR
 LDAAX CPLIB ;Read library handle
 LDYIM UTHSLD
 STAIY USTPTR ;Set as CSD of user

 LDAIM  27 ;Offset from MIDTX of LIB name
 JSR DIRINF ;Entry point not changing CSD handle
 BNE USRENZ

 LDAIM DNAMLN ;Disc name length
 STA MIDTX
 LDAIM  0 
 STA CCODE
 LDAIM TXHDR + 37 ;Message length
 JSR REPLYC
USRENX JMP COMRTS

USRENZ
 [ 1=0
 JSR EXTERR
 JMP COMRTS
 |
 JMP ERROR
 ]




 
;*************
;* L O G O N *
;*************


LOGON

 JSR SPACES
LGONLP LDAAY MIDRX ;Step past station if present
 CMPIM "." ;Network number terminator - special case
 BEQ LGONL1
 CMPIM "0"
 BCC LGONON ;On if <0
 CMPIM ":" ;On if >9
 BCS LGONON
LGONL1 INY
 BNE LGONLP

LGONON JSR BUFTXT ;Read User
 BNE LOGRTS
 INX ;Step past CR between userid & pw
 JSR BTXTA
 BNE LOGRTS
 JSR COMEND ;Check to end of C.line
 BNE LOGRTS

 [ 1=0

 BIT MONFLG ;Do monitor message specially to avoid PW
 BPL LGONL2 ;No monitor -> carry on

 LDY QPTR ;Point to RX control block
 JSR PRTMC ;Print machine number
 JSR VSTRIN
 = ": I am "
 NOP

 LDXIM  0
LGONL4 LDAAX TXTBUF ;Which now contains userid, terminated CR
 CMPIM &7F
 BCS LGONL9
 CMPIM &20
 BCC LGONL9 ;Trap illegal chars

 JSR OSASCI
LGONL9 INX
 CMPIM CR
 BNE LGONL4
 JSR OSASCI ;New line

 ;SET UP ARGS TO LOGON IN USERMAN

LGONL2 LDYIM ARGB
 LDX QPTR
 LDAAX CBSTID
 STAIY NEWARG ;SET STATION ID (LO)
 INY
 LDAAX CBSTID + 1
 STAIY NEWARG ;STATION ID (HI)
 JSR SBUFPT ;Set ptr to buff onto stack
 LDAIM  1 ;LOGON ROUTINE NUMBER
 JSR SETRTN
 JSR USRMAN ;*** DO THE LOGON **
 BNE LOGERR ;Send error message
 |

 LDYIM ARGB
 LDX QPTR
 LDAAX CBSTID
 STAIY NEWARG
 INY
 LDAAX CBSTID+1
 STAIY NEWARG ;pass station id

 JSR SBUFPT ;pointer to TXTBUF

 LDAIM 1
 JSR SETRTN
 JSR USRMAN ;attempt logon
 BNE LOGERR ;failed

 LDYIM ARGH ;test for priv'd logon
 LDAIY NEWARG
 BNE LOGJ1 ;no monitor for priv'd users

 BIT MONFLG
 BPL LOGJ1 ;skip if monitor off anyway

 LDY QPTR
 JSR PRTMC ;output mc number
 JSR VSTRIN
 = ": I am "
 NOP

 LDXIM 0
LOGJ2 LDAAX TXTBUF
 INX
 JSR OSASCI ;print the user name
 CMPIM CR
 BNE LOGJ2

LOGJ1

 ]

 LDYIM ARGG
 LDXIM  3
LGLPAA LDAIY NEWARG ;Get UFD/CSD/LIB handles + option byte
 STAAX MIDTX
 DEY
 DEX
 BPL LGLPAA

 LDAIM CCLGON
 STA CCODE
 LDAIM TXHDR + 4 ;Message length
 JSR REPLYC ;Send handles etc. back

LOGRTS JMP COMRTS ;FINISH
LOGERR
 [ 1=0
 JSR EXTERR
 JMP LOGRTS
 |
 JMP ERROR
 ]



;***************
;* L O G O F F *
;***************


USROFF

;(LABEL USROFF TO AVOID NAME CLASH
;WITH USRMAN ROUTINE)

;SET UP ARGS FOR LOGOFF (DELETE USER)
;IN USERMAN, CALL, AND SEND APPROPRIATE
;MESSAGE BACK TO CLIENT.

 JSR COMEND
 BNE USROEX

FCBYE

;nice if this returns no error if not logged on ** 5/9/84 **

 LDY QPTR
 LDAAY CBSTID
 STA MCNUMB
 LDAAY CBSTID+1
 STA MCNUMB+1
 JSR FINDMC
 BEQ USROL1 ;check for logged on user here

 LDAIM 0
 BEQ USROEZ ;exit ok

USROL1 JSR STKUSE ;Entry by function code
 BNE USROEX

 LDAIM  2 ;LOGOFF ROUTINE NUMBER
 JSR SETRTN
 JSR USRMAN
USROEZ JSR RCODE
USROEX JMP COMRTS



CPSOPT

;Set USER OPTION in pw file
;Just call appropriate AUTMAN routine

 JSR STKUSE
 BNE CPSOEX
 LDAAX MIDRX ;Note assumes X is BPTR here
 CMPIM &10 ;Check option <16
 BCS CPSOER
 INY
 STAIY NEWARG
 LDAIM  7
 JSR SETRTN
 JSR AUTMAN ;Call AUTMAN.USEROPTION
CPSOEZ JSR RCODE
CPSOEX JMP COMRTS

CPSOER LDAIM INFERA ;Bad arg
 BNE CPSOEZ




;************************
;* S E L E C T  D I S C *
;************************


SELDSC   ;SELDSC

;ALL WORK DONE IN USRMAN.

 JSR RDTITL ;GET DISC NAME ON STACK
 BNE SELDEX

 LDYIM ARGA
 JSR SBUFPT
 LDAIM &A
 JSR SETRTN
 JSR MAPMAN ;*** GET DISC NO FOR NAME **
 BNE SELDER

 LDYIM ARGB
 LDAIY NEWARG
 PHA
 INY
 LDAIY NEWARG
 INY
 INY
 STAIY NEWARG ;MOVE DISC. NO. UP TO MAKE WAY FOR USRPTR
 DEY
 PLA
 STAIY NEWARG
 JSR STKUSE ;SET USER POINTER
 BNE SELDEX
 LDYIM ARGF
 JSR STKHND ;PUT 3 HANDLES ON STACK

 LDAIM  3
 JSR SETRTN
 JSR USRMAN ;*** SELECT DISC **
 BNE SELDER

 LDYIM ARGD
 LDXIM  2
SDISLP LDAIY NEWARG
 STAAX MIDTX
 DEY
 DEX
 BPL SDISLP

 LDAIM CCSDIS
 STA CCODE
 LDAIM TXHDR + 3 ;MESSAGE LENGTH
 JSR REPLYC
SELDEX JMP COMRTS
SELDER
 [ 1=0
 JSR EXTERR ;SEND APPROPRIATE MSG.
 JMP SELDEX
 |
 JMP ERROR
 ]



;**********************
;* S E L E C T  D I R *
;**********************


SELDIR   ;SELDIR

;ALL WORK DONE BY USERMAN AGAIN.

 JSR RDTITL
 BNE SDIREX
 JSR STKUSE
 BNE SDIREX

 JSR SBUFPT ;** 5/9/84 **
 LDYIM ARGF
 JSR STKHND ;Handles -> stack
 JSR SELHAN
 BNE SDIRER ;error in allocation

 LDAIM CCSDIR
 STA CCODE
 LDAIM TXHDR + 1 ;Message length
 JSR REPLYC
SDIREX JMP COMRTS
SDIRER
 [ 1=0
 JSR EXTERR
 JMP SDIREX
 |
 JMP ERROR
 ]

SELHAN
 LDAIM  5 ;ROUTINE NUMBER
 JSR SETRTN
 JSR USRMAN ;*** SELECT DIR. **
 BNE SELHEX ;exit if fail

 LDYIM ARGB
 LDAIY NEWARG
 STA MIDTX ;New s.dir
 LDAIM 0
SELHEX RTS

;******************************
;* S E L E C T  L I B R A R Y *
;******************************


SLIB   ;SLIB

;as for DIR but null filename is illegal
;if RETRIEVE ok then call USRMAN with LIB as CSD

 JSR RDTITL
 BNE SLIBEX
 JSR STKUSE
 BNE SLIBEX
 JSR SBUFPT
 JSR SCOWPT ;Set pointer to COWORK on stack
 LDAIM  2 ;Dirman retrieve
 JSR SETRTN

 LDYIM ARGH
 LDAIM &C0
 STAIY NEWARG ;wild card flag

 JSR DIRMAN ;*** RETRIEVE **
 BNE SLIBAB

 JSR STKUSE
 BNE SLIBEX
 JSR SBUFPT
 JSR SCOWPT ;Set pointer to COWORK on stack

 LDYIM ARGF
 JSR STKHND ;handles -> stack

 LDYIM ARGH
 LDAIY NEWARG
 DEY
 STAIY NEWARG ;LIB->CSD
 
 JSR SELHAN ;** 5/9/84 **
 BNE SLIBAB ;error in allocation

 LDAIM CCSLIB
 STA CCODE
 LDAIM TXHDR + 1 ;Set length of message
 JSR REPLYC

SLIBEX JMP COMRTS

SLIBAB
 [ 1=0
 JSR EXTERR
 JMP SLIBEX
 |
 JMP ERROR
 ]



;*********************
;* S E T A C C E S S *
;*********************


SETACC

;1) PUT USER INFO. POINTER AND FILE TITLE
;POINTER ON STACK.
;2) INTERPRET STRING SENT FROM CLIENT INTO
;AN ACCESS BYTE AND STICK ON STACK.
;3) CALL SETATTRIBS IN DIRMAN
;4) REPLY TO CLIENT


 JSR BUFTXT ;Get file name
 BNE SAEXIT
 STY COWORK ;Store cmnd. line ptr.
 JSR STKUSE
 BNE SAEXIT

 JSR SBUFPT

 LDY COWORK ;Restore cmnd. line ptr.
 JSR SPACES

 LDAIM  0
 STA COZERO ;Partial result
 DEY
SALPB INY
 LDXIM  2 ;Offset into access tables
 JSR CMPACC ;Compare letter at Y with access tables
 BEQ SALPB ;Access letter found
 CMPIM "/" ;Owner access delimiter
 BEQ SAONF
 JSR SPACER ;skip trailing spaces ** 25/5/83 **
 CMPIM CR
 BNE SAERR ;Invalid character => error
 DEY ;Point to CR so will exit after rotating COZERO

SAONF ASL COZERO ;Rotate access bits to owner position
 ASL COZERO

SALPC INY ;Increment past '/' delimiter
 LDXIM  1
 JSR CMPACC
 BEQ SALPC
 JSR SPACER ;skip trailing spaces ** 25/5/83 **
 CMPIM CR
 BNE SAERR ;If here, CR has terminated string => set access

 LDYIM ARGF
 LDAIM &C0
 STAIY NEWARG ;wild cards flag
 LDAIM  4 
 INY ;Set arg to SETATTRIBS => SETACCESS
 STAIY NEWARG
 INY
 LDA COZERO ;Restore access byte
 STAIY NEWARG ;SET ACCESS BITS
 LDAIM  4 ;SETACC ROUTINE NO.
 JSR SETRTN
 JSR DIRMAN ;*** SET ACCESS **
 JSR RCODE ;SEND REPLY
SAEXIT JMP COMRTS ;FINISH

SAERR LDAIM SAERRA ;BAD ACCESS STRING ERROR
 [ 1=0
 JSR EXTERR
 JMP SAEXIT
 |
 JMP ERROR
 ]


CMPACC LDAAY MIDRX
 EORAX OWNTAB
 ANDIM &DF ;Compare with cases forced
 BEQ CMPAEX
 DEX
 BPL CMPACC
 LDAAY MIDRX ;Exit, A = char, Z unset
 RTS

CMPAEX LDA COZERO
 ORAAX POWNTB
 STA COZERO ;Update partial result
 LDXIM  0 ;Set Z flag; note A corrupted
 RTS

OWNTAB
 = "R"
 = "W"
 = "L"

POWNTB =  1 ;OWNER READ
 =  2 ;OWNER WRITE
 =  4



;******************
;* N E W  U S E R *
;******************


NEWUSE

;ALL WORK DONE IN AUTMAN, ROUTINE NO. 1

 JSR RDTITL ;Get user name
 BNE NUEXIT
 JSR STKUSE ;Stack caller's user info
 BNE NUEXIT
 JSR SBUFPT ;Stack new user ptr.

 LDAIM  1
DOUSE JSR SETRTN ;SET ROUTINE NUMBER
 JSR AUTMAN ;DO NEW USER
 JSR RCODE ;SEND RETURN CODE
RUEXIT  ;Shared with REMUSE
SPWEXT  ;Shared with USERIN
NUEXIT JMP COMRTS ;FINISH



;************************
;* R E M O V E  U S E R *
;************************

REMUSE

;REMARKABLY SIMILAR TO NEWUSER

 JSR RDTITL
 BNE RUEXIT
 JSR STKUSE
 BNE RUEXIT
 JSR SBUFPT

 LDAIM  4
 BNE DOUSE ;Always jump


;**************************
;* S E T  P A S S W O R D *
;**************************


SETPW

;GET USER INFO AND CALL ROUTINE IN AUTMAN
;TO DO WORK.

 JSR BUFTXT ;Buffer old pw
 BNE SPWEXT
 INX  ;Ptr. to next free spot in TXTBUF
 JSR BTXTA ;Buffer new pw
 BNE SPWEXT
 JSR COMEND
 BNE SPWEXT

 BIT MONFLG ;Do monitor message specially to avoid PW
 BPL SETPW1 ;No monitor -> carry on

 LDY QPTR ;Point to RX control block
 JSR PRTMC ;Print machine number
 JSR VSTRIN
 = ": Pass",CR
 NOP

SETPW1 JSR STKUSE
 BNE SPWEXT
 JSR SBUFPT

 LDAIM  3 ;ROUTINE NUMBER
 BNE DOUSE ;Always jump



;**********************
;* C R E A T E  D I R *
;**********************


CDIRFN LDY BPTR
 INY
 JSR RDTITL
 BNE CDIREX
 LDY BPTR
 LDAAY MIDRX
 BEQ CDIRZ ;zero is a silly number
 CMPIM (:MSB: MAXDIR) +1
 BCS CDIRZ
 BCC CDIRC ;check for overflow

CDIR   ;CDIR

;PASS USER INFO AND DIRECTORY NAME
;TO DIRMAN. THEN CLEAN UP IF NECCESSARY.

 JSR RDTITL
 BNE CDIREX
 LDAIM  2 ;size of directory

CDIRC CMP CACHSZ+1 ;** 31/1/85
 BCS CDIRZ
 LDYIM ARGF
 STAIY NEWARG
 INY
 LDAIM &80 ;** 11/10/84 **
 STAIY NEWARG ;wild card flag
 JSR STKUSE
 BNE CDIREX

 JSR SBUFPT
 LDAIM  5 ;CREATE DIR. FUNCTION CODE
 JSR SETRTN

 JSR DIRMAN ;*** DO DIR. CREATE **
 PHA
 JSR RCODE

 PLA  ;TEST DIRMAN RETURN CODE
 BNE CDIREX
 JSR OBJCLR ;CLEAR OLD OBJECT
 BEQ CDIREX ;**** 17/3/83 ****
 JSR RCODE ;store RC

SPEXIT  ;Shared with SETPRIV
CDIREX JMP COMRTS

CDIRZ LDAIM DRERRP
 JMP ERROR


;******************
;* S E T  P R I V *
;******************


STPRIV

;MOST WORK DONE BY AUTMAN

 JSR BUFTXT ;MOVE USER ID.
 BNE SPEXIT
 STY COWORK
 JSR STKUSE
 BNE SPEXIT
 JSR SBUFPT

 LDY COWORK
 JSR SPACES
 ANDIM &DF ;Force upper case
 CMPIM "S" ;SYSTEM USER ???
 BEQ SPRONA
 CMPIM CR ;NON-SYSTEM USER ??
 BNE SPRIER
 LDAIM  0 ;NON-SYST. USER
 BEQ SPRONB

SPRONA INY
 JSR COMEND
 BNE SPEXIT
 LDAIM  1 ;SYSTEM USER !
SPRONB LDYIM ARGF
 STAIY NEWARG ;Set user's priv. flag

 LDAIM  5 ;SET PRIV.
 JMP DOUSE

SPRIER LDAIM SPERRA
SPRIEX
 [ 1=0
 JSR EXTERR
 JMP SPEXIT
 |
 JMP ERROR
 ]



;*************
;* D I S C S *
;*************

DISCS   ;DISCS

;Provide list of discs currently on system.

;User supplies entry (drive) number, and
;number of drives. For each drive he is interested in,
;call MAPMAN once to get disc number
;and again to get disc name.

 LDAIM  0
 STA COZERO ;No. of drives found
 LDA BBUF
 CLC
 ADCIM TXHDR + 1 ;Result buffer
 STA COZERO + 1
 LDA BBUF + 1
 ADCIM  0
 STA COZERO + 2
DSCSLA LDX BPTR
 LDAAX MIDRX
 CMP DRIVES
 BCS DSCSLB ;User drive >= drives

 PHA  ;Store drive number
 LDYIM ARGB
 STAIY NEWARG
 LDAIM  8 ;Drive -> disc no.
 JSR SETRTN
 JSR MAPMAN
 BNE DSCSLX ;Abort
 LDAIM &B ;Disc no. -> name
 JSR SETRTN
 JSR MAPMAN
 BNE DSCSLX
 PLA
 LDYIM  0
 STAIY COZERO + 1 ;Result drive no.
 INC COZERO + 1
 BNE DSCSLC
 INC COZERO + 2
DSCSLC LDA COZERO + 1
 STA MOVTO
 LDA COZERO + 2
 STA MOVTO + 1

 LDYIM ARGB
 LDAIY NEWARG ;Ptr. to name
 STA MOVFRM
 INY
 LDAIY NEWARG
 STA MOVFRM + 1
 LDXIM DNAMLN
 JSR MOVE ;Move name to result
 CLC
 LDA COZERO + 1
 ADCIM DNAMLN
 STA COZERO + 1
 LDA COZERO + 2
 ADCIM  0
 STA COZERO + 2
 INC COZERO ;No. of drives dealt with
 LDX BPTR
 INCAX MIDRX ;Next drive to do
 JMP DSCSLA

DSCSLB LDYIM ARGB
 LDA COZERO ;Set args to LSTPRY
 STAIY NEWARG
 INY
 LDA COZERO + 1
 STAIY NEWARG
 INY
 LDA COZERO + 2
 STAIY NEWARG
 LDAIM CCDSCS
 JSR LSTRPY ;Reply to client
 JMP COMRTS

DSCSLX JSR EXTERR
 PLA
 JMP COMRTS




;*************
;* U S E R S *
;*************

CPUSRS   ;CPUSRS

 JSR STKLST
 LDAIM  7
 JSR SETRTN
 JSR USRMAN
 BNE USRSAB
 LDAIM CCUSRS
 JSR LSTRPY
 JMP COMRTS
USRSAB
 [ 1=0
 JSR EXTERR
 JMP COMRTS
 |
 JMP ERROR
 ]



;***********
;* D A T E *
;***********

CPSETD  ;Set the date ** 20/9/83 **
 LDA DATE
 PHA
 LDA DATE +1
 PHA ;SAVE DATE IN CASE WE NEED IT!
 LDY BPTR ;check flag
 LDAAY MIDRX
 STA DATE
 LDAAY MIDRX + 1
 STA DATE + 1
 JSR CHKDTE
 BNE DTENGD
 LDY BPTR
 LDAAY MIDRX +2
 CMPIM 24
 BCS DTENGD
 STA HRS
 LDAAY MIDRX +3
 CMPIM 60
 BCS DTENGD
 STA MINS
 LDAAY MIDRX +4
 CMPIM 60
 BCS DTENGD
 STA SECS
 JSR SETTME
 JSR PRDTE ;display new date
 PLA
 PLA ;REMOVE SAVED DATE
 LDAIM TXHDR ;Rx header only
 BNE DATOUT
DTENGD PLA
 STA DATE +1
 PLA
 STA DATE
 LDAIM DTERR
 JSR RCODE
 JMP COMRTS

CPDATE

;No user check since doesn't involve
;files.
 JSR PRTIM
 LDA DATE ;read date
 STA MIDTX
 LDA DATE + 1
 STA MIDTX + 1

;Now check if real-time clock is available,
;and if so, supply extra 3 bytes of time

 LDA HRS
 STA MIDTX + 2
 LDA MINS
 STA MIDTX + 3
 LDA SECS
 STA MIDTX + 4 ;Time = zero if clock not present

 LDAIM TXHDR + 5 ;Message length

DATOUT LDXIM  0
 STX CCODE ;0 command code
 JSR REPLYC ;Message length in A here
 JMP COMRTS



;*****************
;* V E R S I O N *
;*****************


CPVERN   ;CPVERN

 LDYIM  0
CPVLP LDAAY VERSN
 STAAY MIDTX
 INY
 CMPIM 13 ;end of version number character
 BNE CPVLP

 TYA
 CLC
 ADCIM TXHDR
 JMP DATOUT ;Send reply, zero c. code
 LNK UADE18
