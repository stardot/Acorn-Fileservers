 OPT UADE19 ;File > Uade19
 TTL File server file UADE19


;**********
;* GETBYT *
;**********

;Read single byte from file.
;All work done by RNDMAN.

;Entry: BPTR is offset of buffer in RXBUF
;QPTR is offset of control block in RXCBV

GETBYT JSR STKUSE ;Put user info ptr on stack
 BNE GTBYTZ

 LDX BPTR
 LDAAX RXBUF + 2 ;Get file handle
 LDYIM ARGD
 STAIY NEWARG

 LDX QPTR ;Get seq no. from control block
 LDAAX RXCBV
 ANDIM  1 ;Mask out reception flag
 INY
 STAIY NEWARG

 LDAIM  7 ;RNDMAN.RDCH
 LDYIM ARGA
 STAIY NEWARG

 JSR RNDMAN ;*** Call RNDMAN.RDCH **
 BNE GTBYTX ;Failed

 LDYIM ARGB
 LDAIY NEWARG ;Get byte read
 STA MIDTX ;Put in TX buffer

 INY
 LDAIY NEWARG ;Get EOF flag
 STA MIDTX + 1 ;Put in TX buffer
 LDAIM TXHDR + 2 ;Message length

;Note that sequence no. is still in control block

 JSR REPLYC ;Send reply

GTBYTZ JMP COMRTS ;exit

GTBYTX
 [ 1=0
 JSR EXTERR ;Abort
 JMP GTBYTZ
 |
 JMP ERROR
 ]



;**********
;* PUTBYT *
;**********

;Write single byte to file.
;All work done by RNDMAN.

;Entry: BPTR is offset of buffer in RXBUF
;QPTR is offset of control block in RXCBV

PUTBYT JSR STKUSE ;Put user info ptr on stack
 BNE PTBYTZ

 LDX BPTR
 LDAAX RXBUF + 2 ;Get file handle
 LDYIM ARGD
 STAIY NEWARG

 LDX QPTR ;Get seq no. from control block
 LDAAX RXCBV
 ANDIM  1 ;Mask out reception flag
 INY
 STAIY NEWARG

 LDX BPTR
 LDAAX RXBUF + 3 ;Get byte to be written
 INY
 STAIY NEWARG ;Put on call stack

 LDAIM  8 ;RNDMAN.WRCH
 LDYIM ARGA
 STAIY NEWARG

 JSR RNDMAN ;*** Call RNDMAN.WRCH **

;Note that sequence no. is still in control block

 JSR RCODE ;Send return code

PTBYTZ JMP COMRTS ;exit



;* CPRDAR *

;Read specified part of file info

;Most work done in RNDMAN.

CPRDAR JSR GETUSE ;USTPTR := USERTB entry
 BEQ CPRDAA ;OK, continue
 JMP CPRDAX

CPRDAB JMP ERROR

CPRDAA JSR SETUSR ;Copy user info to NEWARG stack
 LDX BPTR ;Offset of request buffer
 LDAAX MIDRX ;Get handle
 LDYIM ARGD
 STAIY NEWARG ;Put handle on NEWARG stack

 LDAIM &B ;RNDMAN.RDAR
 LDYIM ARGA
 STAIY NEWARG
 JSR RNDMAN ;*** Call RNDMAN.RDAR **
 BNE CPRDAB ;Not OK, send error code and exit

;Have now got sequential file ptr, file hwm,
;and file size on NEWARG stack.
;The one to be sent back is determined by
;arg in request block.
;Arg is 0,1,2 resp. to get the above.

;Set Y to appropriate offset on NEWARG stack

 LDX BPTR ;Offset of request buffer
 LDAAX MIDRX + 1 ;Arg from request

 CMPIM  0 ;Test arg
 BNE CPRDAC ;Not 0

 LDYIM ARGB ;Offset of file ptr
 BNE CPRDAF ;Always jumps

CPRDAC CMPIM  1 ;Test arg
 BNE CPRDAD ;Not 0 or 1

 LDYIM ARGE ;Offset of file HWM
 BNE CPRDAF ;Always jumps

CPRDAD CMPIM  2 ;Test arg
 BNE CPRDAE ;Not 0, 2, or 1

 LDYIM ARGH ;Offset of file size
 BNE CPRDAF ;Always jumps

;Invalid arg in request

CPRDAE LDAIM ARGERR ;"Bad arg to RDAR"
 JMP CPRDAB ;Send error and exit

;Y now contains the offset on NEWARG
;of the required 3 bytes.

CPRDAF LDAIY NEWARG ;LS byte
 STA MIDTX ;Put in TX buffer
 INY
 LDAIY NEWARG ;CS byte
 STA MIDTX + 1
 INY
 LDAIY NEWARG ;MS byte
 STA MIDTX + 2
 LDAIM TXHDR + 3 ;Mesage length
 JSR REPLYC ;Send reply

CPRDAX JMP COMRTS ;Exit



;* CPSTAR *

;Set sequential file pointer

CPSTAR JSR GETUSE ;USTPTR := ptr to user info
 BEQ CPSTAA ;OK, continue

 JMP CPRDAX ;exit

CPSTAA JSR SETUSR ;Copy user info to stack
 LDX BPTR ;Offset of request buffer
 LDAAX MIDRX ;Get handle
 LDYIM ARGD
 STAIY NEWARG ;Put handle on stack

;Put arg saying what to set on stack

 LDAAX MIDRX + 1
 INY
 STAIY NEWARG

;Put value to be set on stack

 LDAAX MIDRX + 2 ;value (LS)
 INY
 STAIY NEWARG
 LDAAX MIDRX + 3 ;value (CS)
 INY
 STAIY NEWARG
 LDAAX MIDRX + 4 ;value (MS)
 INY
 STAIY NEWARG
 LDAAX MIDRX + 5 ;Some vals have 4 bytes
 INY
 STAIY NEWARG

 LDAIM &C ;RNDMAN.STAR
 LDYIM ARGA
 STAIY NEWARG
 JSR RNDMAN ;*** Call RNDMAN.STAR **
 JSR RCODE ;Transmit reply

 JMP COMRTS ;Exit



;************
;* PUTBYTES *
;************

;Write several bytes to specified file offset.

;1) Set up pointer to user info
;2) (abolished)
;3) Send first reply, giving data port
;and max. blocksize.
;4) LOOP: receive block into big buffer
;5) LOOP: write to disc (RNDMAN.PUTBYTES)
;unless disc error flag set
;6) LOOP: If disc error, then set flag but
;continue to receive.
;7) LOOP: If more to receive, adjust OFFSET
;and loop to 4).
;8) Send final RC (disc error flag)

;Entry: BPTR is offset of buffer in RXBUF
;QPTR is offset of control block in RXCBV

PBYTES JSR GETUSE ;USTPTR := ptr to user info
 BNE PBYTEK ;not logged on ** 6/9/84 **

 JSR RMSUBO ;Prepare for some PUTBYTES calls
 BEQ PBYTEJ

PBYTEC JSR EXTERR ;Not OK, send RC
PBYTEK JMP PBYTEZ ;Exit

;Send first reply, giving data port and max blocksize

PBYTEJ LDAIM PSAVD ;Use same data port as SAVE
 STA MIDTX

 LDAIM BUFSZ ;Big buffer size (2 bytes)
 STA MIDTX + 1
 LDAIM /BUFSZ
 STA MIDTX + 2

 LDAIM  0 ;RTCODE := CCODE := 0
 STA RTCODE
 STA CCODE

 LDAIM TXHDR + 3 ;Message length

 JSR REPLY ;Send message
 BEQ PBYTEB ;OK, continue

 JMP PBYTEZ ;Lost contact - abort

;Ready to receive data, so set up for
;reception loop.

PBYTEB LDAIM  0 ;DATAIN := 0 (3 bytes)
 STA DATAIN
 STA DATAIN + 1
 STA DATAIN + 2
 STA DSCERR ;Clear disc err flag
 STA FINFLG ;Clear end-of-transfer flag

;Test specially for transfer of zero bytes,
;to prevent 64K net control block being
;set up! Jump straight to final reply.

 LDX BPTR
 LDAAX MIDRX + 2 ;Ls byte of size
 ORAAX MIDRX + 3 ;CS
 ORAAX MIDRX + 4 ;MS
 BNE PBLOOP ;Not zero bytes
 JMP PBYTED ;Jump straight to final reply

PBLOOP
;Loop which receives data and writes it to disc

;Set buffer pointers in RX control block

 LDY QPTR ;Buffer start = BBUF
 LDA BBUF
 STAAY CBBUF
 LDA BBUF + 1
 STAAY CBBUF + 1

 LDA BBEND ;Buffer end = BBEND
 STAAY CBBUFE
 LDA BBEND + 1
 STAAY CBBUFE + 1

 LDAIM PSAVD ;Set data port
 STAAY CBPORT

;Station already set from first reception

 JSR WAIT ;Wait for reception
 BEQ PBLOOA ;OK, continue

 JMP PBYTEZ ;No contact => abort

;Now subtract buffer limits to see how
;much data was received.

PBLOOA LDY QPTR
 SEC  ;COWORK := CBBUFE-CBBUF
 LDAAY CBBUFE
 SBCAY CBBUF
 STA COWORK ;LS byte
 LDAAY CBBUFE + 1
 SBCAY CBBUF + 1
 STA COWORK + 1 ;MS byte

;Add amount received to total number of bytes
;received.

 CLC ;DATAIN +:= COWORK
 LDA COWORK ;LS byte
 ADC DATAIN
 STA DATAIN
 LDA COWORK + 1 ;CS byte
 ADC DATAIN + 1
 STA DATAIN + 1
 LDAIM  0 ;MS byte of received length always 0
 ADC DATAIN + 2
 STA DATAIN + 2

;Compare total amount received (in DATAIN)
;with total number of bytes to be written.
;(in original message buffer).
;Set FINFLG if exactly the right amount
;has been received.
;If too much has been received, then send
;a return code.

 LDX BPTR
 SEC
 LDAAX MIDRX + 2 ;LS byte of size
 SBC DATAIN
 STA BREGA ;Use BREGA as workspace
 LDAAX MIDRX + 3 ;CS byte of size
 SBC DATAIN + 1
 STA BREGA + 1
 LDAAX MIDRX + 4 ;MS byte
 SBC DATAIN + 2

;Carry set if received <= size

 ORA BREGA ;OR 3 bytes of result
 ORA BREGA + 1 ;for zero test
 BEQ PBLOOC ;Equal => last block
 BCS PBLOOD ;Recd < size => carry on

;Client sent too much data.
;Send error code and stop.

 LDAIM PBERRA ;Error code
 JMP PBYTEC ;Send RC and exit

PBLOOC LDAIM &FF ;Last block; set FINFLG
 STA FINFLG

;If disc error flag set, ignore received data,
;and jump round disc write.

PBLOOD LDA DSCERR ;Disc error flag
 BNE PBLOOE ;Jump if error

;Set up for call of RNDMAN


 LDX BPTR
 LDAAX MIDRX ;Get file handle
 LDYIM ARGD
 STAIY NEWARG ;Put on call stack

 LDA BBUF ;Buffer addr (Big Buffer)
 INY
 STAIY NEWARG
 LDA BBUF + 1
 INY
 STAIY NEWARG

 LDA COWORK ;No. of bytes (calculated above)
 INY
 STAIY NEWARG ;LS byte
 LDA COWORK + 1
 INY
 STAIY NEWARG ;MS byte

 LDAIM &A ;RNDMAN.PUTBYTES
 LDYIM ARGA
 STAIY NEWARG

 JSR SETUSE ;Stack user info

 JSR RNDMAN ;*** RNDMAN.PUTBYTES **
 BEQ PBLOOE ;OK, continue
 STA DSCERR ;Store error code

;If FINFLG is set, then we have just written
;the last block.
;Otherwise, adjust the file offset and carry on.

PBLOOE LDA FINFLG ;Finished?
 BNE PBYTED ;Exit from loop if yes

;Send ack to client's ack port

 LDY BPTR
 LDXAY CPUFD ;Ack port
 LDAIM  1 ;Message length

 JSR REPLYB ;Send byte (random contents)
 BNE PBYTEZ ;Contact lost => abort

PBLOOF JMP PBLOOP ;Round loop again

PBYTED
;Have received all the data.
;Final RC is in DSCERR.
;If RC is zero, send back amount xferred (always amount requested
;if no error). If non-zero, send error.

 LDA DSCERR
 STA RTCODE
 BNE PBYTEX ;RC <> 0 => error
 STA CCODE ;Set command code = 0
 STA MIDTX+4 ;send 32 bit number
 LDX BPTR
 LDAAX MIDRX + 2
 STA MIDTX + 1
 LDAAX MIDRX + 3
 STA MIDTX + 2
 LDAAX MIDRX + 4 ;Move length of data to MIDTX
 STA MIDTX + 3
 LDAIM TXHDR + 5
 JSR REPLYC ;Send reply (note MIDTX undefined)

PBYTEZ JMP COMRTS ;Exit from command

PBYTEX JSR RCODE ;Send error reply
 JMP PBYTEZ



;************
;* GETBYTES *
;************

;Read several bytes from specified file offset.

;1) Set up pointer to user info
;2) Save size of transfer.
;SEND first RC to client
;3) LOOP: read chunk into big buffer (RNDMAN.GETBYTES)
;unless disc error flag set
;4) LOOP: If disc error, then set flag but
;continue to send data.
;5) LOOP: send to client
;6) LOOP: If more to send, adjust OFFSET
;and loop to 3).
;7) Send final RC (disc error flag)

;Entry: BPTR is offset of buffer in RXBUF
;QPTR is offset of control block in RXCBV

GBYTES LDAIM  0
 STA GBBXFD ;GBBXFD := 0
 STA GBBXFD + 1
 STA GBBXFD + 2
 STA GBEFLG ;GBEFLG := 0

 JSR GETUSE ;USTPTR := ptr to user info
 BNE GBYTEC ;OK, continue ** 6/9/84 **

 JSR RMSUBO ;Set up RNDMAN for GETBYTES calls
 BEQ GBYTEF

GBYTEG JSR EXTERR ;Not OK, send RC
GBYTEC JMP GBYTEZ ;Exit

GBYTEF JSR RCODE ;Send "OK" rc
 BNE GBYTEC ;lost contect so ABORT

;TOSEND := size of transfer

GBYTED LDX BPTR
 LDAAX MIDRX + 2 ;Size (LS)
 STA TOSEND
 LDAAX MIDRX + 3 ;Size (CS)
 STA TOSEND + 1
 LDAAX MIDRX + 4 ;Size (MS)
 STA TOSEND + 2

;Use the big buffer.
;Read from disc chunks of size BUFSZ, and transmit
;them to the client.
;Note that, in general, each chunk will be badly
;aligned with respect to disc blocks. RNDMAN tries
;to be efficient about this for each chunk.
;It may be worth adding extra optimization here if
;very large (> BUFSZ) transfers are common.

 LDAIM  0
 STA DSCERR ;No disc error yet
 STA FINFLG ;Not finished yet

;Test specially for transfer of zero
;bytes to prevent 64K net control
;block being set up!

 LDA TOSEND ;Size (LS)
 ORA TOSEND + 1 ;CS
 ORA TOSEND + 2 ;MS
 BNE GBLOOP ;OK - not zero bytes
 JMP GBYTEB ;Jump straight to final reply


;Loop, sending data to client in blocks of
;size BUFSZ.  TOSEND is the amount left to
;send, OFFSET the current file position.
;If an error occurs, the error code is put
;in DSCERR and the loop continues, padding
;out the transmission until the right
;amount of data has been sent.
;FINFLG gets set on the last time round
;the loop.

GBLOOP SEC  ;COWORK := TOSEND - BUFSZ
 LDA TOSEND
 SBCIM BUFSZ
 STA COWORK
 LDA TOSEND + 1
 SBCIM /BUFSZ
 STA COWORK + 1
 LDA TOSEND + 2
 SBCIM  0 ;BUFSZ only 2 bytes
 STA COWORK + 2

 ORA COWORK ;OR 3 bytes for zero test
 ORA COWORK + 1
 BEQ GBLOOA ;TOSEND = BUFSZ
 BCS GBLOOB ;TOSEND < BUFSZ

;BUFSZ >= TOSEND: send remaining data
;and set finish flag.

GBLOOA LDA TOSEND ;OUTBSZ := TOSEND
 STA OUTBSZ
 LDA TOSEND + 1
 STA OUTBSZ + 1
 DEC FINFLG ;Set loop finish flag to $FF
 JMP GBLOOC

GBLOOB LDAIM BUFSZ ;OUTBSZ := BUFSZ
 STA OUTBSZ
 LDAIM /BUFSZ
 STA OUTBSZ + 1

GBLOOC
;The size of the block to send is in OUTBSZ.
;Call RNDMAN.GETBYTES to get the data into
;the big buffer.

 LDX BPTR
 LDAAX MIDRX ;Get file handle
 LDYIM ARGD
 STAIY NEWARG ;Put handle on stack

 LDA BBUF ;Put buffer address on stack
 INY
 STAIY NEWARG
 LDA BBUF + 1
 INY
 STAIY NEWARG

 LDA OUTBSZ ;Put no. of bytes on stack
 INY
 STAIY NEWARG
 LDA OUTBSZ + 1
 INY
 STAIY NEWARG

 LDAIM  9 ;RNDMAN.GETBYTES
 LDYIM ARGA
 STAIY NEWARG

 JSR SETUSE

 JSR RNDMAN ;*** Call RNDMAN.GETBYTES **
 BEQ GBLOOD ;OK, continue
 STA DSCERR ;Otherwise set error code

GBLOOD

;Add number of bytes actually read to
;GBBXFD, and OR end-of-file flag
;into GBEFLG.

 CLC
 LDYIM ARGB
 LDAIY NEWARG ;Bytes xferred (LS)
 ADC GBBXFD
 STA GBBXFD ;LS total
 INY
 LDAIY NEWARG
 ADC GBBXFD + 1
 STA GBBXFD + 1 ;CS total
 LDAIM  0 ;Only 2 bytes from RNDMAN
 ADC GBBXFD + 2
 STA GBBXFD + 2 ;MS total

 INY
 LDAIY NEWARG ;EOF flag
 ORA GBEFLG ;OR with flag so far
 STA GBEFLG

 LDY BPTR
 LDAAY CPUFD ;Get client's data port
 JSR SENDBB ;Send big block (size in OUTBSZ)
 BEQ GBLOOE ;OK, continue
 JMP GBYTEZ ;Contact lost with client; give up

GBLOOE
;End of loop. Test finish flag, and set
;TOSEND from COWORK.

 BIT FINFLG ;Test finish flag
 BMI GBYTEB ;Exit from loop if finished

 LDA COWORK ;TOSEND := COWORK
 STA TOSEND
 LDA COWORK + 1
 STA TOSEND + 1
 LDA COWORK + 2
 STA TOSEND + 2

 JMP GBLOOP ;Loop return

;Exit from GBLOOP: RC in DSCERR

GBYTEB LDA DSCERR
 BNE GBYTEE ;Jump if error

;Send back end-of-file flag and
;count of bytes actually read.

 LDA GBEFLG ;EOF flag
 STA MIDTX ;Put in TX buffer
 LDA GBBXFD ;Bytes xferred (LS)
 STA MIDTX + 1
 LDA GBBXFD + 1
 STA MIDTX + 2 ;CS
 LDA GBBXFD + 2
 STA MIDTX + 3 ;MS
 LDAIM 0
 STA MIDTX+4 ;send 32 bit number ** 26/2/85 **
 LDAIM TXHDR + 5 ;Message length
 JSR REPLYC ;Send reply
 JMP GBYTEZ ;Exit from command

GBYTEE JSR RCODE ;Send return code

GBYTEZ JMP COMRTS ;Exit from command



;*** Call RNDMAN to set up bytes operation

RMSUBO LDYIM ARGA
 LDAIM &E ;**** RNDMAN.SUBO ***
 STAIY NEWARG
 JSR SETUSE
 LDX BPTR
 LDAAX MIDRX + 0 ;Get file handle
 INY
 STAIY NEWARG

 LDX QPTR ;Get seq no from control block
 LDAAX RXCBV
 ANDIM  1 ;Get just seq bit
 INY
 STAIY NEWARG

;The flag, no of bytes, and offset
;are in the correct order in rx block

 LDX BPTR
RMSUBA LDAAX MIDRX + 1
 INY
 STAIY NEWARG
 INX
 CPYIM ARGL
 BNE RMSUBA ;More to copy

 JMP RNDMAN ;**** Call RNDMAN.SUBO & return ***

CPWHO ROUT ;** 19/3/85 **

;Yet another interface - this one allows an application
;to determine the userid under which it is logged-on

;This is probably most useful for MAILing type progs

 JSR GETUSE
 BNE #20 ;nb this will deal with the error

 LDXIM 0
 LDYIM UTUSID
10 LDAIY USTPTR ;copy the user name
 STAAX MIDTX
 INY
 INX
 CMPIM CR ;copy only upto CR (pw follows - dont want that)
 BNE #10

 TXA
 CLC
 ADCIM TXHDR ; Add TX header length *** LH 28/8/85 ***
 [ 1=1
 JMP DATOUT
 |
 JSR REPLYC ;return the answer with zero RC
 ]
20 JMP COMRTS
 
 LNK UADE20
