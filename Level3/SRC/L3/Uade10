 OPT UADE10 ;> Uade10
 TTL File server file UADE10



;**********************************
;*           M A P M A N          *
;**********************************

;THE MAP TABLE (MAPTB) CONTAINS :-
;0) DISC NUMBER (2 BYTES)
;1) NO. OF SECTORS?TRACKS ON DISC (2 BYTES)
;2) SIN OF ROOT DIRE CTORY (3 BYTES)
;3) DATE ROOT CREATED (2 BYTES)
;DRIVE NUMBER PROVIDES THE OFFSET IN MAPTB.
;POSSIBLE STATES ARE :-

MAPMAN

 [ 1=0
 TSX
 STX TSTACK ;Store stack pointer
 ]

 LDXIM 14 ;MAPMAN HAS 14 ENTRY POINTS
 LDAIM MODMAP ;A := NAME OF THIS MODULE
 JSR ENTRY
 LDAAX MPRTNS ;GET ADDRESS OF ROUTINE TO JUMP TO
 STA MPJUMP + 1
 LDAAX MPRTNS + 1
 STA MPJUMP + 2 ;N.B.NO NEED FOR SETFS
 LDAIM 20
 JSR SETFS
 JMP MPJUMP ;JUMP TO CORRECT ROUTINE

;ADDRESSES OF ENTRY POINTS FOR EACH ROUINE
MPRTNS
 & MPCRSP ;1 => CREATE SPACE
 & MPFRSP ;2 => FREE SPACE
 & MPCHSZ ;3 => CHANGE SIZE
 & MPSNRT ;4 => SIN OF ROOT
 & MPSZIN ;5 => SIZE OF CHAIN
 & MPENSR ;6 => WRITE MAP TO DISC
 & MPREST ;7 => START
 & MPDSNB ;8 => RETURN DISC NUMBER FOR A GIVEN DRIVE
 & MPREDR ;9 => RESTART ONE DRIVE
 & MPDNNA ;10 => RETURN NUMBER FOR GIVEN DISC NAME
 & MPNADN ;11 => RETURN NAME FOR GIVEN DISC NO.
 & MPFREE ;12 => FREE AREA ON DISC
 & MPZDSK ;13 => ZERO AREA OF DISC
 & MPCHSJ ;14 => changesize without space check

MPJUMP JMP MPJUMP ;OVER-WRITTEN TO PROVIDE JUMP TO ROUTINE
MPEXIT JMP PREXIT

;MPCRSP: CREATE SPACE

;ENTRY: ARGB = LS(DISC NUMBER)
;ARGC = MS(DISC NUMBER)
;ARGD = LS(NUMBER OF BYTES WANTED)
;ARGE = CS(NUMBER OF BYTES WANTED)
;ARGF = MS(NUMBER OF BYTES WANTED)

;EXIT:  ARGA = RC
;ARGB = LS(DISC NUMBER)
;ARGC = MS(DISC NUMBER)
;ARGD = LS(SIN)
;ARGE = CS(SIN)
;ARGF = MS(SIN)
;ARGG = LS ptr to user info
;ARGH = MS ptr to user info

;FUNCTION: MAPTB IS SEARCHED TO FIND THE RELEVANT ENTRY. IF THE SECTOR MAP
;IS NOT IN STORE, IT IS READ IN. THE FREE SPACE COUNT IS CHECKED TO SEE IF
;THE SPACE IS AVAILABLE. A CHAIN IS CREATED, THE FREE COUNT IS DECREMENTED
;AND THE MAP IS MARKED DIRTY. THE SIN OF THE FIRST BLOCK OF THE CHAIN IS
;RETURNED.

MPCRSP LDYIM ARGG
 JSR MPMKFR ;make pointer
 LDAIM ARGD
 STA MAPTMP
 LDAIM UTFREE
 STA MAPTMP+1
 LDXIM -(UTFRLN-1)
 SEC

MPCRSA LDY MAPTMP+1
 LDAIY GENPTR
 LDY MAPTMP
 SBCIY ARGPTR
 STAAX MPNWFR - :LSB: -(UTFRLN-1) ;save this result
 INC MAPTMP
 INC MAPTMP+1
 INX
 BNE MPCRSA

 LDY MAPTMP+1
 LDAIY GENPTR
 SBCIM 0 ;extra length byte
 STA MPNWFR +(UTFRLN-1)

 LDAIM MPERRN ;error code to return with insufficient free space
 BCC MPCRSX

 LDAIM  0
 STA ERRTYP ;NO ERRORS YET!!!
 STA DNDLTE
 JSR FNDMAP ;GET POINTER TO MAPTB
 BEQ MPCSS2
MPCRSX JMP MPCRND
MPCSS2 LDYIM ARGD ;NUMBER OF BYTES REQUIRED
 LDAIY ARGPTR
 STA DIVPAR
 INY
 LDAIY ARGPTR
 STA DIVPAR+ 1
 INY
 LDAIY ARGPTR
 STA DIVPAR+ 2
 JSR DVDE ;TO FIND MOST LIKELY NUMBER OF BLOCKS
 BCC MPCSZ1
 JMP MPCSR2
MPCSZ1 LDYIM MPCYMP ;READY TO CHECK IF ENOUGH ROOM
 LDAIY MAPPTR
 STA MPCYPT
 INY
 LDAIY MAPPTR
 STA MPCYPT + 1
 SEC
 LDYIM  0
 LDAIY MPCYPT
 SBC DIVTMP ;FOR NUMBER OF BLOCKS
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 SBC DIVTMP + 1
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 SBC DIVTMP+ 2
 STAIY MPCYPT
 BCS MPCSS1 ;BRANCH IF NO ROOM
 JMP MPNORM
MPCSS1 JSR FNDCY ;FIND LARGEST CYCLINDER
 JSR RDBTMP ;READ IN THE BIT MAP
 JSR ALBLK ;ALLOCATE ONE BLOCK AS MAP BLOCK
 LDA MPTMPA
 LDYIM ARGD
 STAIY ARGPTR ; SAVE SIN OF NEW FILE
 INY
 LDA MPTMPA + 1
 STAIY ARGPTR
 INY
 LDA MPTMPA+ 2
 STAIY ARGPTR
 SEC
 LDA DIVTMP ;ONE LESS BLOCK REQUIRED
 SBCIM  1
 STA DIVTMP
 LDA DIVTMP+ 1
 SBCIM  0
 STA DIVTMP+ 1
 LDA DIVTMP+ 2
 SBCIM  0
 STA DIVTMP+ 2
 SEC
 JSR RDMPBK ;ALLOCATE SPACE FOR MAP BLOCK
 LDA DIVTMP + 2
 ORA DIVTMP+ 1
 ORA DIVTMP ;CHECK IF ONLY ONE BLOCK REQUIRED
 BEQ MPCSJD ;BRANCH IF JUST ONE BLOCK
 LDA MAPTMP
 STA MPMBPT
 LDA MAPTMP + 1
 STA MPMBPT + 1
 LDA MPTMPB ;POINTS TO CYCLINDER MAP
 STA MPCYPT
 LDA MPTMPB+ 1
 STA MPCYPT + 1
 LDYIM  0
 LDAIY MPCYPT ;CHECK FOR NO FREE SPACR
 INY
 ORAIY MPCYPT
 BEQ MPCSSK ;BRANCH TO GET NEW CYLINDER
 JSR ABLKS ; ALLOCATE THE REST OF THE BLOCKS
MPCSSK LDA DIVTMP
 ORA DIVTMP+ 1
 ORA DIVTMP+ 2 ;CHECK IF ALL BLOCKS ALLOCATED
 BEQ MPCSOB ;OK IF THEY HAVE
 JSR FLBLKS ;OTHERWISE CONTINUE ALLOCATING BLOCKS
 BCC MPCSOB ;CARRY CLEAR IF OK
MPCSDE LDA ERRTYP
 STA DNDLTE
 JSR MPDLTE ;CLEAR ALL BLOCKS
 JSR ULMB
 JSR ENSMB
 JSR ENSBM
 JMP MPNORM ;INDICATE NO ROOM
MPCSJD
MPCSOB LDYIM ARGD
 LDAIY ARGPTR
 STA MPTMPA
 INY
 LDAIY ARGPTR
 STA MPTMPA + 1
 INY
 LDAIY ARGPTR
 STA MPTMPA + 2
 CLC
 JSR RDMPBK
 LDA MAPTMP
 STA MPSCPT
 STA CBSTA
 LDA MAPTMP+ 1
 STA MPSCPT+ 1
 STA CBSTA + 1

 LDYIM BLKSN
 LDXIM 5 ;mapblock identifier text
MPJLTX LDAAX MPBLTX
 STAIY MPSCPT
 INY
 DEX
 BPL MPJLTX

 LDYIM BILB
 LDA DIVPAR ;FILL IN ODD BYTES
 STAIY MPSCPT
 INY
 LDA DIVPAR + 1
 STAIY MPSCPT
 JSR MMBWT
 JSR ENSBM ;ENSURE THE BIT MAPS
 JSR ENSMB ;ENSURE THE MAP BLOCKS
 LDA ERRTYP
 BEQ MPCSR1
 JMP MPCSDE
MPCSR1 LDAIM  0
 JMP MPCRND ;INDICATES ALL WAS WELL
MPNORM CLC
 LDYIM  0
 LDAIY MPCYPT
 ADC DIVTMP
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 ADC DIVTMP + 1
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 ADC DIVTMP + 2
 STAIY MPCYPT
 LDA ERRTYP
 BEQ MPCSR2
 SEC
 LDYIM  0
 LDAIY MPCYPT
 SBCIM  1
 STAIY MPCYPT ;MAP BLOCK LEFT!
 INY
 LDAIY MPCYPT
 SBCIM  0
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 SBCIM  0
 STAIY MPCYPT
 LDAIM MPERRC
 BNE MPCRND
MPCSR2 LDAIM MPERRB
MPCRND LDYIM ARGG
 JSR MPSETF ;update the user free store if operation ok
 JMP MPEXIT


;MPCHSZ: CHANGE THE SIZE OF A CHAIN ON DISC

;ENTRY: ARGB = LS(DISC NO)
;ARGC = MS(DISC NO)
;ARGD = LS(SIN)
;ARGE = CS(SIN)
;ARGF = MS(SIN)
;ARGG = LS(NEW SIZE IN BYTES)
;ARGH = CS(NEW SIZE IN BYTES)
;ARGI = MS(NEW SIZE IN BYTES)
;ARGJ = LS ptr to user info
;ARGK = MS ptr to user info

;EXIT:  ARGA = RC

;FUNCTION: MAPTB IS SCANNED TO FIND THE RELEVANT ENTRY. IF NECESSARY
;THE SECTOR MAP IS READ INTO STORE. THE CURRENT SIZE IS DISCOVERED AND IT
;IS DECIDED WHETHER IT IS AN INCREASE OR A DECREASE IN SIZE.
;THE RELEVANT NUMBER OF BLOCKS ARE THEN ALLOCATED/DEALLOCATED.



MPCHSZ LDYIM ARGJ
 JSR MPFRAD ;get size of chain
 BNE MPCHJX ;catch errors

 LDXIM -3
 LDYIM ARGG
 SEC
MPCHJA LDAAX MPNWFR - :LSB:-3
 SBCIY ARGPTR
 STAAX MPNWFR - :LSB: -3
 INY
 INX
 BNE MPCHJA ;calculate new size required

 LDA MPNWFR+3
 SBCIM 0
 STA MPNWFR+3

 LDAIM MPERRN
 BCC MPCHJX ;exit 'cos there's no room

MPCHSJ JSR FNDMAP
 BEQ MPCSCN
MPCHJX JMP MPCHEN
MPCSCN LDAIM  0 ;CLEAR VARIABLES
 STA ERRTYP ;NO ERRORS
 STA DNDLTE
 STA MPTMPB
 STA MPTMPB + 1
 STA MPTMPB + 2
 STA SAVSC ;FIRST BLOCK FLAGGED
 LDYIM ARGD ;GET SIN
 LDAIY ARGPTR
 STA MPTMPA
 INY
 LDAIY ARGPTR
 STA MPTMPA + 1
 INY
 LDAIY ARGPTR
 STA MPTMPA + 2
 INY
 LDAIY ARGPTR ;GET LENGTH IN BYTES
 STA DIVPAR
 INY
 LDAIY ARGPTR
 STA DIVPAR + 1
 INY
 LDAIY ARGPTR
 STA DIVPAR + 2
 CLC
 JSR RDMPBK ;READ IN RELEVANT MAP BLOCK
 LDA ERRTYP
 BEQ MPCSR3
 LDAIM MPERRC
 JMP MPCHEN ;REPORT DISC ERROR
MPCSR3 JSR DVDE ;DIVIDE BYTES TO GET BLOCKS
 BCC MPCSZ2
 JMP MPCSR5
MPCSZ2 SEC ;DECREMENT SINCE NO MAP BLOCK REQUIRED
 LDA DIVTMP
 SBCIM  1
 STA DIVTMP
 LDA DIVTMP + 1
 SBCIM  0
 STA DIVTMP + 1
 LDA DIVTMP + 2
 SBCIM  0
 STA DIVTMP + 2
 LDA MAPTMP ;ADDRESS OF MAP BLOCK
 STA MPMBPT
 LDA MAPTMP + 1
 STA MPMBPT + 1
 CLC
 LDA MPMBPT ;GET TO POINT AT ENTRIES
 ADCIM MBENTS
 STA MPMBPT
 LDA MPMBPT + 1
 ADCIM /(MBENTS )
 STA MPMBPT + 1
 LDAIM  0
 STA MPTMPB
 STA MPTMPB + 1
 STA MPTMPB + 2
REPLP1 LDYIM  0
 LDAIY MPMBPT ;CHECK IF NEXT POINTER IS ZERO
 INY
 ORAIY MPMBPT
 INY
 ORAIY MPMBPT
 BNE CSSK1
 JMP NDLP1
CSSK1 CLC
 LDA MAPTMP
 ADCIM LSTENT
 TAX
 LDA MAPTMP + 1
 ADCIM /(LSTENT )
 CPX MPMBPT
 BNE CSES1
 CMP MPMBPT + 1
 BNE CSES1
 LDYIM  0 ;YES, SO THIS POINTER IS SIN OF MAP BLOCK
 LDAIY MPMBPT
 STA MPTMPA ;PREPARE TO READ NEW MAP BLOCK
 INY
 LDAIY MPMBPT
 STA MPTMPA + 1
 INY
 LDAIY MPMBPT
 STA MPTMPA + 2
 CLC
 JSR RDMPBK ;READ IN NEW MAP BLOCK
 LDA MAPTMP
 STA MPMBPT
 LDA MAPTMP + 1 ;TRANSFER ADDRESS
 STA MPMBPT + 1
 CLC
 LDA MPMBPT ; POINT TO ENTRIES
 ADCIM MBENTS
 STA MPMBPT
 LDA MPMBPT + 1
 ADCIM /(MBENTS )
 STA MPMBPT + 1
CSES1 CLC ; KEEP ADDING UP NUMBER OF BLOCKS
 LDYIM  3
 LDAIY MPMBPT
 ADC MPTMPB
 STA MPTMPB
 INY
 LDAIY MPMBPT
 ADC MPTMPB + 1
 STA MPTMPB + 1
 LDA MPTMPB + 2
 ADCIM  0
 STA MPTMPB + 2
 LDA MPTMPB
 CMP DIVTMP ;CHECK IF ENOUGH BLOCKS FOUND
 LDA MPTMPB + 1
 SBC DIVTMP + 1
 LDA MPTMPB + 2
 SBC DIVTMP + 2
 BCS NDLP1 ;BRANCH IF ENOUGH FOUND
 CLC ;HERE IF JUST LOOK AT NEXT ENTRY
 LDA MPMBPT
 ADCIM ENSZ
 STA MPMBPT ; LOOK AT NEXT ENTRY
 LDA MPMBPT + 1
 ADCIM /(ENSZ )
 STA MPMBPT + 1
 JMP REPLP1
NDLP1 LDA MPTMPB ;NOW SEE ABOUT THE SIZE
 CMP DIVTMP
 LDA MPTMPB + 1
 SBC DIVTMP + 1
 LDA MPTMPB + 2
 SBC DIVTMP + 2
 BCS CSSK2 ;BRANCH IF MORE SPACE REQUIRED
 JMP NEEDMR
CSSK2 LDA MPTMPB
 CMP DIVTMP
 BNE DARGP ;IF THESE ARE NOT THE SAME, ODD BLOCKS MUST BE DISCARDED
 LDA MPTMPB + 1
 CMP DIVTMP + 1
 BNE DARGP
 LDA MPTMPB + 2
 CMP DIVPAR + 2
 BNE DARGP ;THEY ARE EQUAL SO NO PART GROUPS TO DEALLOCATE
 JMP DARST
DARGP SEC ;FIND ODD NUMBER FOR DEALLOCATION
 LDA MPTMPB
 SBC DIVTMP
 STA MPTMPB
 LDA MPTMPB + 1
 SBC DIVTMP + 1
 STA MPTMPB + 1
 LDA MPTMPB + 2
 SBC DIVTMP + 2
 STA MPTMPB + 2
 LDYIM  3
 SEC ;GET NUMBER OF THIS GROUP TO DEALLOCATE
 LDAIY MPMBPT
 SBC MPTMPB
 STA MPTMPD
 STAIY MPMBPT
 INY
 LDAIY MPMBPT
 SBC MPTMPB + 1
 STA MPTMPD + 1
 STAIY MPMBPT
 LDAIM  0
 SEC
 SBC MPTMPB + 2
 STA MPTMPD + 2
 LDA MAPTMP
 STA CBSTA
 LDA MAPTMP + 1
 STA CBSTA + 1
 JSR MMBWT
 LDYIM  0
 CLC ; FIND DISC ADDRESS FOR DEALLOCATION
 LDAIY MPMBPT
 ADC MPTMPD
 STA MPTMPE
 INY
 LDAIY MPMBPT
 ADC MPTMPD + 1
 STA MPTMPE + 1
 INY
 LDAIY MPMBPT
 ADC MPTMPD + 2
 STA MPTMPE + 2
 INY
 LDAIY MPMBPT
 INY
 ORAIY MPMBPT
 BNE NBZ
 LDYIM  0
 TYA
 STAIY MPMBPT
 INY
 STAIY MPMBPT
 INY
 STAIY MPMBPT
NBZ ;FIND CYLINDER NUMBER
 LDAIM  0
 STA MPTMPC ;ZERO CYLINDER COUNT
 STA MPTMPC + 1
CNTLP SEC
 LDYIM MPSPCY
 LDA MPTMPE
 SBCIY MAPPTR
 STA MPTMPE
 INY
 LDA MPTMPE + 1
 SBCIY MAPPTR
 STA MPTMPE + 1
 LDA MPTMPE + 2
 SBCIM  0
 STA MPTMPE + 2
 BCC CYFD ; FOUND IF GONE NEGATIVE
 INC MPTMPC
 BNE CNTLP
 INC MPTMPC + 1
 JMP CNTLP
CYFD JSR RDBTMP ;READ THE RELEVANT BIT MAP
 JSR MBMLKD
 LDYIM MPSPCY
 CLC
 LDA MPTMPE
 ADCIY MAPPTR
 STA MPTMPD
 INY
 LDA MPTMPE + 1
 ADCIY MAPPTR
 STA MPTMPD + 1
 LDYIM  0
DECLP LDA MPTMPD + 1
 BNE DECCT ; CANNOT OF GOT TO THE RIGHT PLACE IF THIS NON-ZERO
 LDA MPTMPD
 CMPIM  8 ;CHECK FOR LESS THAN EIGHT
 BCC DECFN ;IF LESS GO AND FIND ACTUAL BIT
DECCT SEC
 LDA MPTMPD ; KEEP DECREMENTING
 SBCIM  8
 STA MPTMPD
 LDA MPTMPD + 1
 SBCIM  0
 STA MPTMPD + 1
 INY
 JMP DECLP
DECFN LDA MPTMPB
 PHA ; SAVE THIS COUNT
 LDA MPTMPB + 1
 PHA
 LDXIM  9 ; X TRACKS POSITION IN CURRENT BYTE
 LDAIY MPSCPT ; GET THE BYTE
FNLP RORA ; KEEP ROTATING FOR POSITION
 DEX
 DEC MPTMPD
 BPL FNLP
DANX SEC ;MARK BLOCK FREE
 RORA
 PHP ; SAVE THESE VALUES
 PHA
 DEX
 BEQ TSTNX ; CHECK FOR END OF THIS BYTE
DECNX SEC
 LDA MPTMPB
 SBCIM  1 ;CHECK IF ALL BLOCKS HAVE BEEN FREED
 STA MPTMPB
 LDA MPTMPB + 1
 SBCIM  0
 STA MPTMPB + 1
 ORA MPTMPB
 BEQ ALLDN ; ZERO WHEN ALL DEALLOCATED
 PLA
 PLP ;GET VALUES BACK
 JMP DANX ;JUMP BACK TO FREE NEXT
TSTNX STAIY MPSCPT ;SAVE THIS VALUE
 LDXIM  8 ;SET UP FOR WHOLE BYTE
 INY ;POINT TO NEXT ENTRY IN BIT MAP
 PLA
 PLP ;JUST TO GET RID OF THEM
 LDAIY MPSCPT ; GET NEW BYTE
 RORA ;SET UP FOR FREEING BLOCKS
 PHP
 PHA
 JMP DECNX
ALLDN PLA
 PLP ;CLEAR VALUES ON STACK
CSRT RORA
 DEX
 BNE CSRT
 STAIY MPSCPT ; AND SAVE HIS VALUE
 PLA ; RETRIEVE BLOCK COUNT
 STA MPTMPB + 1
 PLA
 STA MPTMPB
 JSR ADDFR ; ADD FREED BLOCKS TO BLOCK COUNT
 LDA MPSCPT
 STA CBSTA
 LDA MPSCPT +1
 STA CBSTA +1
 JSR MBMWT
DARST LDYIM ENSZ ; NOW REST OF ENTRIES CAN BE DEALLOCATED
 LDAIY MPMBPT ;CHECK FOR LAST ENTRY
 INY
 ORAIY MPMBPT
 INY
 ORAIY MPMBPT
 BNE CSSK3 ;IF NONE LEFT WE'VE FINSHED
 JMP CSENS
CSSK3 SEC
 LDA MPMBPT ; RETRIEVE ADDRESS OF MAP BLOCK
 SBC MAPTMP ; AND GET OFFSET
 STA MPSCPT
 LDA MPMBPT + 1
 SBC MAPTMP + 1
 STA MPSCPT + 1
 CLC ;NOW POINT AT NEXT ENTRY
 LDA MPSCPT
 ADCIM ENSZ
 STA MPSCPT
 LDA MPSCPT + 1
 ADCIM /(ENSZ )
 STA MPSCPT + 1
 LDAIM 0
 STA MPTMPE ;don't delete this map block
 JSR CLRBLK
CSENS JSR ULBM
 JSR ENSMB
 JSR ENSBM
 LDA ERRTYP
 BEQ MPCSR4
 LDAIM MPERRC
 JMP MPCHEN
MPCSR4 JMP CSEND ;FINISH REDUCTION
;
; SIZE TO BE INCREASED
;
NEEDMR SEC ;GET THE POINTER
 LDA MPMBPT
 SBC MAPTMP
 STA SAVPTA ;SAVE THE OFFSET IN THE MAP BLOCK IN CASE IT NEEDS TO BE RESTORED
 LDA MPMBPT + 1
 SBC MAPTMP + 1
 STA SAVPTA + 1
 LDA MPTMPA ;SAVE THE SIN OF THE MAP BLOCK
 STA SAVPTB
 LDA MPTMPA + 1
 STA SAVPTB + 1
 LDA MPTMPA + 2
 STA SAVPTB + 2
 SEC ;DISCOVER HOW MUCH NEEDS TO BE ALLOCATED
 LDA DIVTMP
 SBC MPTMPB
 STA DIVTMP
 LDA DIVTMP + 1
 SBC MPTMPB + 1
 STA DIVTMP + 1
 LDA DIVTMP + 2
 SBC MPTMPB + 2
 STA DIVTMP + 2
 LDYIM MPCYMP ;GET ADDRESS OF CYLINDER MAP
 LDAIY MAPPTR
 STA MAPGEN
 INY
 LDAIY MAPPTR
 STA MAPGEN + 1
 SEC
 LDYIM  0 ; CHECK IF THERE IS ENOUGH SPACE
 LDAIY MAPGEN
 SBC DIVTMP
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 SBC DIVTMP + 1
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 SBC DIVTMP + 2
 STAIY MAPGEN
 BCS RPRM
 JMP RPNRM ; BRANCH IF THERE IS NO ROOM
RPRM LDA SAVPTA
 CMPIM MBENTS
 BNE NMNB
 LDA SAVPTA + 1
 BEQ NMUS ; EMPTY MAP BLOCK SO ALLOCATE FROM SIN
NMNB SEC
 LDA MPMBPT
 SBCIM ENSZ
 STA MPMBPT
 LDA MPMBPT + 1
 SBCIM /(ENSZ )
 STA MPMBPT + 1
 LDYIM  0 ; GET A CURRENT DISC ADDRESS
 LDAIY MPMBPT
 STA MPTMPA
 INY
 LDAIY MPMBPT
 STA MPTMPA + 1
 INY
 LDAIY MPMBPT
 STA MPTMPA + 2
 CLC
 LDA MPMBPT
 ADCIM ENSZ
 STA MPMBPT
 LDA MPMBPT + 1
 ADCIM /(ENSZ )
 STA MPMBPT + 1
NMUS JSR DIVSEC ; FIND CYLINDER FROM SIN
 LDA MPTMPB ;GET CYLINDER TO SOMEWHERE USEFUL
 STA MPTMPC
 LDA MPTMPB + 1
 STA MPTMPC + 1
 JSR GTCYPS ; FIND A CLOSE CYLINDER WITH FREE BLOCKS
 LDA MPTMPE
 STA MPTMPC
 LDA MPTMPE + 1
 STA MPTMPC + 1
 JSR RDBTMP
 LDA MAPGEN
 STA MPCYPT ; READY TO ALLOCATE BLOCKS
 LDA MAPGEN + 1
 STA MPCYPT + 1
 JSR ABLKS ; ALLOCATE ONE LOT OF BLOCKS
 BCS GTRD ; BRANCH IF FAILED
 LDA DIVTMP
 ORA DIVTMP + 1
 ORA DIVTMP + 2
 BEQ CSEND ; CHECK IF FINISHED
 JSR FLBLKS ; FILL IN THE REST OF THE BLOCKS
 BCS GTRD ; BRANCH IF ALL WENT WELL
 JSR ENSBM
 JMP CSEND
GTRD LDA SAVPTB ; IT FAILED SO DEALLOCATE ANY BLOCKS STILL ALLOCATED
 STA MPTMPA ; GET SIN BACK
 LDA SAVPTB + 1
 STA MPTMPA + 1
 LDA SAVPTB + 2
 STA MPTMPA + 2
 LDA SAVPTA ; GET OFFSET BACK
 STA MPSCPT
 LDA SAVPTA + 1
 STA MPSCPT + 1
 LDAIM  0 ; LEAVE CURRENT MAP BLOCK ALONE
 STA MPTMPE
 JSR CLRBLK ; TIDY UP
RPNRM CLC
 LDYIM  0
 LDAIY MAPGEN
 ADC DIVTMP
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADC DIVTMP + 1
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADC DIVTMP + 2
 STAIY MAPGEN
 LDA ERRTYP
 BEQ MPCSR5
 LDAIM MPERRC
 JMP MPCHEN
MPCSR5 LDAIM MPERRB ; FLAG NO ROOM
 JMP MPCHEN
CSEND LDYIM ARGD ; FILL IN ODD BYTES
 LDAIY ARGPTR ; GET POINTERS BACK
 STA MPTMPA
 INY
 LDAIY ARGPTR
 STA MPTMPA + 1
 INY
 LDAIY ARGPTR
 STA MPTMPA + 2
 CLC
 JSR RDMPBK
 LDA MAPTMP
 STA MPMBPT
 STA CBSTA
 LDA MAPTMP + 1
 STA MPMBPT + 1
 STA CBSTA + 1
 LDYIM BILB ; POSITION OF ODD BYTES
 LDA DIVPAR ; BYTES FROM DIVISION
 STAIY MPMBPT
 INY
 LDA DIVPAR + 1
 STAIY MPMBPT
 JSR MMBWT
 JSR ENSMB
 JSR ENSBM
 LDAIM  0 ; INDICATE SUCCESS

MPCHEN BNE MPCHXX
 LDYIM ARGA
 LDAIY ARGPTR
 EORIM 14 ;detect special case
 BEQ MPCHXX
 LDYIM ARGJ
 LDAIM 0
 JSR MPSETF
MPCHXX JMP MPEXIT

;MPREST:

;FUNCTION: LOADS THE MAP TABLE FROM DISC.
;CHECKS THAT ALL MAPS ARE O.K. ALSO
;SETS UP TABLE FOR FREE STORE MANAGEMENT

MPREST LDAIM  0 ;CLEAR ALL VARS.
 STA ERRTYP
 STA MAPTMP
 STA MAPTMP + 1
 STA MPTMPA
 STA MPTMPA + 1
 STA MPTMPB
 STA MPDRVE
 LDX DRIVES ;FOR LOOP
 LDYIM MPTBSZ
 JSR SETTAB ;SET MAP TABLE AND CLEAR STORE
 STY MAPTB
 STY MAPPTR
 STX MAPTB + 1
 STX MAPPTR + 1

 LDXIM NTSIZE
 LDYIM NTENSZ
 JSR SETTAB ;SET NAME TABLE
 STY NAMETB
 STX NAMETB + 1

 STY DNMPTR
 STX DNMPTR + 1
 LDXIM NTSIZE
 LDAIM UNUSED
 LDYIM NTUSED

;MARK ALL NAME TABLE ENTRIES UNUSED

MPRELP STAIY DNMPTR
 PHA
 JSR INAMPT
 PLA
 DEX
 BNE MPRELP

 LDXIM  1
 STX NXTDNO
 DEX
 STX NXTDNO + 1 ;SET DISC ALLOCATION NO.
 JSR INBKMN

 LDAIM  0
 STA MPDRVE
 STA LDRNB
MPRENG LDA MPDRVE
 STA DRIVNO
 LDA FREPTR
 STA MPSCPT ;GENERAL PTR. TO SEC. ZERO DATA
 LDA FREPTR + 1
 STA MPSCPT + 1
 LDA DRIVNO ;CURRENT DRIV NUMBER

 JSR RDDATA ;GET INFO FROM DISC
 JSR CHKDSC ;CHECK IS FS DISC
 BEQ MPRES1 ;NOPE, ISN'T
MPRES2 JMP MPREND
MPRES1
;NOW SET MAP TABLE ENTRY FOR THIS DRIVE

 JSR SMAPEN

 JSR CHDNAM ;PUT IN NAME TABLE
 BNE MPRES2

;NOW CREATE CYCLINDER MAP FOR THIS DISC'S MAP
 JSR MPMPSZ ;GET SIZE OF MAP
 JSR DIVSEC ; GET NO. OF TRACKS
 LDYIM MPNOCY
 CLC
 LDA MPTMPB ;CALCULATE SIZE OF CY.MAP
 STAIY MAPPTR ; SAVE NO. OF TRACKS
 INY
 ROLA
 STA MPTMPB ; MULTIPLY TRACKS BY TWO
 LDA MPTMPB+ 1
 STAIY MAPPTR
 ROLA
 STA MPTMPB+ 1
 CLC ;NOW INCREASE SIZE TO HOLD FREE SPACE COUNT
 LDA MPTMPB
 ADCIM  3
 TAY
 LDA MPTMPB+ 1
 ADCIM  0
 TAX
 JSR GETVEC ; GET SPACE FOR CYCLINDER MAP
 TYA ; SAVE ADDRESS OF CY.MAP
 LDYIM MPCYMP
 STAIY MAPPTR
 INY
 TXA
 STAIY MAPPTR
 JSR MPSTCY
 LDYIM MPADFT
 CLC
 LDA MPDRVE
 ADCIY MAPPTR
 STA MPDRVE
 JSR MPADMP
 INC LDRNB
 LDA LDRNB
 CMP DRIVES
 BEQ MPREOK
 JMP MPRENG


MPREOK LDAIM  0 ;RC
MPREND JMP MPEXIT

;MPSZIN: RETURNS THE LENGTH OF A CHAIN IN BYTES AND BLOCKS

;ENTRY: ARGB = LS(DISC NO)
;ARGC = MS(DISC NO)
;ARGD = LS(SIN)
;ARGE = CS(SIN)
;ARGF = MS(SIN)

;EXIT:  ARGA = RC
;ARGB = LS(SIZE IN BYTES)
;ARGC = CS(SIZE IN BYTES)
;ARGD = MS(SIZE IN BYTES)
;ARGE = LS(SIZE IN BLOCKS)
;ARGF = MS(SIZE IN BLOCKS)

;FUNCTION: GETS THE RELEVANT ENTRY IN MAPTB. CHECKS THAT
;THE SIN POINTS TO THE START OF A CHAIN. RETURNS THE LENGTH OF THE CHAIN.

MPSZIN JSR FNDMAP ;GET MAP TO MAPPTR
 BNE MPSZND
 LDYIM ARGD
 LDAIY ARGPTR ;FIRST BYTE OF SIN
 STA MPTMPA
 INY
 LDAIY ARGPTR ;GET SECOND BYTE
 STA MPTMPA + 1
 INY
 LDAIY ARGPTR
 STA MPTMPA + 2
 CLC
 JSR RDMPBK
 BEQ MPSZOK
 LDAIM MPERRC ;ERROR RETURN OF NOT START
 JMP MPEXIT ;AND RETURN
MPSZOK LDA MAPTMP
 STA MPMBPT
 LDA MAPTMP + 1
 STA MPMBPT + 1
 JSR MPGTSZ ;GET SIZE OF MAP
 LDYIM ARGB
 LDA MPTMPA ;SIZE IS IN MPTMPA
 STAIY ARGPTR
 INY
 LDA MPTMPA + 1
 STAIY ARGPTR
 INY
 LDA MPTMPA + 2
 STAIY ARGPTR
 LDYIM ARGE
 LDA MPTMPD
 STAIY ARGPTR ;SAVE NUMBER OF BLOCKS
 INY
 LDA MPTMPD + 1
 STAIY ARGPTR
 LDAIM  0 ;RC
MPSZND JMP MPEXIT

;MPSNRT: RETURNS THE SIN OF THE ROOT DIRECTORY
;ENTRY: ARGB = LS(DISC NO)
;ARGC = MS(DISC NO)

;EXIT:  ARGA = RC
;ARGB = LS(SIN OF ROOT DIRECTORY)
;ARGC = CS(SIN OF ROOT DIRECTORY)
;ARGD = MS(SIN OF ROOT DIRECTORY)
;ARGE = DATE ROOT CREATED (LO)
;ARGF =  ""   ""    ""    (HI)


MPSNRT JSR FNDMAP
 BNE MPSNND
 LDYIM MPRTSN
MPSNLA LDAIY MAPPTR
 PHA
 INY
 CPYIM MPRTSN + 5
 BNE MPSNLA

 LDYIM ARGF
MPSNLB PLA
 STAIY ARGPTR
 DEY
 CPYIM ARGA
 BNE MPSNLB

 LDAIM  0
MPSNND JMP MPEXIT


 LNK UADE11
