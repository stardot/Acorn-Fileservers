 OPT UADE10 ;> Uade10
 TTL File server file UADE10


;**********************************
;*           M A P M A N          *
;**********************************

;THE MAP TABLE (MAPTB) CONTAINS :-
;0) DISC NUMBER (2 BYTES)
;1) NO. OF SECTORS/TRACKS ON DISC (2 BYTES)
;2) SIN OF ROOT DIRECTORY (3 BYTES)
;3) DATE ROOT CREATED (2 BYTES)
;DRIVE NUMBER PROVIDES THE OFFSET IN MAPTB.
;POSSIBLE STATES ARE :-

MAPMAN ROUT

 LDXIM 16 ;MAPMAN ENTRY POINTS
 LDAIM MODMAP ;A := NAME OF THIS MODULE
 JSR ENTRY
 LDAAX MPRTNS
 STA MPJUMP+1
 LDAAX MPRTNS+1
 STA MPJUMP+2
 LDAIM 20
 JSR SETFS
MPJUMP JMP MPJUMP ;JUMP TO CORRECT ROUTINE

;ADDRESSES OF ENTRY POINTS FOR EACH ROUINE
MPRTNS
 & MPCRSP ;1 => CREATE SPACE
 & MPFRSP ;2 => FREE SPACE
 & MPCHSZ ;3 => CHANGE SIZE
 & MPSNRT ;4 => SIN OF ROOT
 & MPSZIN ;5 => SIZE OF CHAIN
 & MPENSR ;6 => WRITE MAP TO DISC
 & MPREST ;7 => START
 & MPDSNB ;8 => RETURN DISC NUMBER FOR A GIVEN DRIVE
 & MPREDR ;9 => RESTART ONE DRIVE
 & MPDNNA ;10 => RETURN NUMBER FOR GIVEN DISC NAME
 & MPNADN ;11 => RETURN NAME FOR GIVEN DISC NO.
 & MPFREE ;12 => FREE AREA ON DISC
 & MPZDSK ;13 => ZERO AREA OF DISC
 & MPCHSJ ;14 => changesize without space check
 & MPDRNB ;15 => return drive number from disc number
 & MPFLSH ;16 => flush bit map and map block caches

MPENSR LDAIM 0 ;Null routine now
MPEXIT JMP PREXIT

;MPCRSP: CREATE SPACE

;ENTRY:
;ARGB-C DISC NUMBER
;ARGD-F NUMBER OF BYTES WANTED
;ARGG-H Ptr to user info

;EXIT:
;ARGA = RC
;ARGB-C DISC NUMBER
;ARGD-F SIN
;ARGG-H Ptr to user info

;FUNCTION: MAPTB IS SEARCHED TO FIND THE RELEVANT ENTRY. IF THE SECTOR MAP
;IS NOT IN STORE, IT IS READ IN. THE FREE SPACE COUNT IS CHECKED TO SEE IF
;THE SPACE IS AVAILABLE. A CHAIN IS CREATED, THE FREE COUNT IS DECREMENTED
;AND THE MAP IS MARKED DIRTY. THE SIN OF THE FIRST BLOCK OF THE CHAIN IS
;RETURNED.

MPBLTX = "paMseJ" ;Mapblocktext

MPCRSP LDYIM ARGG
 JSR MPMKFR ;make pointer
 LDAIM ARGD
 STA MAPTMP
 LDAIM UTFREE
 STA MAPTMP+1
 LDXIM :LSB:(1-UTFRLN)
 SEC

10 LDY MAPTMP+1
 LDAIY GENPTR
 LDY MAPTMP
 SBCIY ARGPTR
 STAAX MPNWFR-:LSB:(1-UTFRLN) ;save this result
 INC MAPTMP
 INC MAPTMP+1
 INX
 BNE #10

 LDY MAPTMP+1
 LDAIY GENPTR
 SBCIM 0 ;extra length byte
 STA MPNWFR+(UTFRLN-1)

 LDAIM MPERRN ;error code to return with insufficient free space
 BCC #20

 LDAIM 0
 STA ERRTYP ;NO ERRORS YET!!!
 STA DNDLTE
 JSR FNDMAP ;GET POINTER TO MAPTB
 BEQ #25
20 JMP #90
25 LDA Mpdrve ;**24/2/88** test for write protect
 JSR Testdv
 BNE #20
 LDYIM ARGD ;NUMBER OF BYTES REQUIRED
 LDAIY ARGPTR
 STA DIVPAR
 INY
 LDAIY ARGPTR
 STA DIVPAR+1
 INY
 LDAIY ARGPTR
 STA DIVPAR+2
 JSR DVDE ;TO FIND MOST LIKELY NUMBER OF BLOCKS
 BCC #30
 JMP #85
30 LDYIM MPCYMP ;READY TO CHECK IF ENOUGH ROOM
 LDAIY MAPPTR
 STA MPCYPT
 INY
 LDAIY MAPPTR
 STA MPCYPT+1
 SEC
 LDYIM 0
 LDAIY MPCYPT
 SBC DIVTMP ;FOR NUMBER OF BLOCKS
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 SBC DIVTMP+1
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 SBC DIVTMP+2
 STAIY MPCYPT
 BCS #40
35 JMP #80 ;BRANCH IF NO ROOM
40 JSR FNDCY ;FIND LARGEST CYCLINDER
 JSR RDBTMP ;READ IN THE BIT MAP
 BNE #35 ;**25/12/86** Disc fault - say no room
 JSR ALBLK ;ALLOCATE ONE BLOCK AS MAP BLOCK
 LDA MPTMPA
 LDYIM ARGD
 STAIY ARGPTR ; SAVE SIN OF NEW FILE
 INY
 LDA MPTMPA+1
 STAIY ARGPTR
 INY
 LDA MPTMPA+2
 STAIY ARGPTR
 LDA DIVTMP ;ONE LESS BLOCK REQUIRED
 BNE #42
 LDA DIVTMP+1
 BNE #41
 DEC DIVTMP+2
41 DEC DIVTMP+1
42 DEC DIVTMP

 SEC
 JSR RDMPBK ;ALLOCATE SPACE FOR MAP BLOCK
 LDA DIVTMP+2
 ORA DIVTMP+1
 ORA DIVTMP ;CHECK IF ONLY ONE BLOCK REQUIRED
 BEQ #60 ;BRANCH IF JUST ONE BLOCK
 LDA MAPTMP
 STA MPMBPT
 LDA MAPTMP+1
 STA MPMBPT+1
 LDA MPTMPB ;POINTS TO CYCLINDER MAP
 STA MPCYPT
 LDA MPTMPB+1
 STA MPCYPT+1
 LDYIM 0
 LDAIY MPCYPT ;CHECK FOR NO FREE SPACR
 INY
 ORAIY MPCYPT
 BEQ #45 ;BRANCH TO GET NEW CYLINDER
 JSR ABLKS ; ALLOCATE THE REST OF THE BLOCKS
45 LDA DIVTMP
 ORA DIVTMP+1
 ORA DIVTMP+2 ;CHECK IF ALL BLOCKS ALLOCATED
 BEQ #60 ;OK IF THEY HAVE
 JSR FLBLKS ;OTHERWISE CONTINUE ALLOCATING BLOCKS
 BCC #60 ;CARRY CLEAR IF OK
50 LDA ERRTYP
 STA DNDLTE
 JSR MPDLTE ;CLEAR ALL BLOCKS
 JSR ULMB
 JSR ENSMB
 JSR ENSBM
 JMP #80 ;INDICATE NO ROOM

60 JSR RDmpbd ;**8/5/87** Read block at ARGD
 LDA MAPTMP
 STA MPSCPT
 STA CBSTA
 LDA MAPTMP+1
 STA MPSCPT+1
 STA CBSTA+1

 LDYIM BLKSN
 LDXIM 5 ;mapblock identifier text
70 LDAAX MPBLTX
 STAIY MPSCPT
 INY
 DEX
 BPL #70

 LDYIM BILB
 LDA DIVPAR ;FILL IN ODD BYTES
 STAIY MPSCPT
 INY
 LDA DIVPAR+1
 STAIY MPSCPT
 JSR MMBWT
 JSR ENSBM ;ENSURE THE BIT MAPS
 JSR ENSMB ;ENSURE THE MAP BLOCKS
 LDA ERRTYP
 BNE #50
 BEQ #90 ;INDICATES ALL WAS WELL

80 CLC
 LDYIM 0
 LDAIY MPCYPT
 ADC DIVTMP
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 ADC DIVTMP+1
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 ADC DIVTMP+2
 STAIY MPCYPT
 LDA ERRTYP
 BEQ #85
 SEC
 LDYIM 0
 LDAIY MPCYPT
 SBCIM 1
 STAIY MPCYPT ;MAP BLOCK LEFT!
 INY
 LDAIY MPCYPT
 SBCIM 0
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 SBCIM 0
 STAIY MPCYPT
 LDAIM MPERRC
 BNE #90

85 LDAIM MPERRB
90 LDYIM ARGG
 JSR MPSETF ;update the user free store if operation ok
 JMP MPEXIT

;MPFLSH; Flush bit map and map block caches.  This is done when a disc is to be
;        Changed, otherwise we can get confused over who's blocks are cached.

MPFLSH ROUT ;**26/2/87**
 JSR ENSBM ;Ensure all bitmaps
 JSR ENSMB ;Ensure all map blocks
 JSR SETBM ;Scan all bit map CBs and mark idle
 JSR #50
 JSR SETMB ;Scan all map block CBs and mark idle
 JSR #50
 JMP MPEXIT

50 LDX NCBDB
60 LDYIM CAFLG
 LDAIM 0
 STAIY GNCBPT ;Zero all flags
 JSR ADGNCB
 DEX
 BNE #60
 TXA
 RTS



;MPCHSZ: CHANGE THE SIZE OF A CHAIN ON DISC

;ENTRY:
;ARGB-C DISC NO
;ARGD-F SIN
;ARGG-I NEW SIZE IN BYTES
;ARGJ-K Ptr to user info

;EXIT:  ARGA = RC

;FUNCTION: MAPTB IS SCANNED TO FIND THE RELEVANT ENTRY. IF NECESSARY
;THE SECTOR MAP IS READ INTO STORE. THE CURRENT SIZE IS DISCOVERED AND IT
;IS DECIDED WHETHER IT IS AN INCREASE OR A DECREASE IN SIZE.
;THE RELEVANT NUMBER OF BLOCKS ARE THEN ALLOCATED/DEALLOCATED.


MPCHSZ ROUT
 JSR FNDMAP ;find map entry, set MPDRVE  ** 16/1/86 **
 BNE #10
 LDYIM ARGJ
 JSR MPFRAD ;get size of chain
 BNE #10 ;catch errors

 LDXIM :LSB:-3
 LDYIM ARGG
 SEC
05 LDAAX MPNWFR-:LSB:-3
 SBCIY ARGPTR
 STAAX MPNWFR-:LSB:-3
 INY
 INX
 BNE #05 ;calculate new size required

 LDA MPNWFR+3
 SBCIM 0
 STA MPNWFR+3

 LDAIM MPERRN
 BCC #10 ;exit 'cos there's no room
 BCS #08       

MPCHSJ JSR FNDMAP
 BNE #10
08 LDAIM 0
 STA ERRTYP ;NO ERRORS
 STA DNDLTE
 STA MPTMPB
 STA MPTMPB+1
 STA MPTMPB+2
 STA SAVSC ;FIRST BLOCK FLAGGED
 JSR MPsetd ;**8/5/87** MPTMPA->ARGD
 LDAIY ARGPTR ;GET LENGTH IN BYTES
 STA DIVPAR
 INY
 LDAIY ARGPTR
 STA DIVPAR+1
 INY
 LDAIY ARGPTR
 STA DIVPAR+2
 CLC
 JSR RDMPBK ;READ IN RELEVANT MAP BLOCK
 LDA ERRTYP
 BEQ #13
 LDAIM MPERRC
10 JMP MPCHEN ;REPORT DISC ERROR

13 JSR DVDE ;DIVIDE BYTES TO GET BLOCKS
 BCC #16
 LDAIM MPERRB
 BNE #10

16 LDA DIVTMP ;DECREMENT SINCE NO MAP BLOCK REQUIRED
 BNE #18
 LDA DIVTMP+1
 BNE #17
 DEC DIVTMP+2
17 DEC DIVTMP+1
18 DEC DIVTMP

 LDAIM 0
 STA MPTMPB
 STA MPTMPB+1
 STA MPTMPB+2

19 LDA MAPTMP ;ADDRESS OF MAP BLOCK
 STA MPMBPT
 LDA MAPTMP+1
 STA MPMBPT+1
 CLC
 LDA MPMBPT ;GET TO POINT AT ENTRIES
 ADCIM :LSB:MBENTS
 STA MPMBPT
 LDA MPMBPT+1
 ADCIM :MSB:MBENTS
 STA MPMBPT+1
20 LDYIM 0
 LDAIY MPMBPT ;CHECK IF NEXT POINTER IS ZERO
 INY
 ORAIY MPMBPT
 INY
 ORAIY MPMBPT
 BEQ #30
 CLC
 LDA MAPTMP
 ADCIM :LSB:LSTENT
 TAX
 LDA MAPTMP+1
 ADCIM :MSB:LSTENT
 CPX MPMBPT
 BNE #26
 CMP MPMBPT+1
 BNE #26
 LDYIM 0 ;YES, SO THIS POINTER IS SIN OF MAP BLOCK
 LDAIY MPMBPT
 STA MPTMPA ;PREPARE TO READ NEW MAP BLOCK
 INY
 LDAIY MPMBPT
 STA MPTMPA+1
 INY
 LDAIY MPMBPT
 STA MPTMPA+2
 CLC
 JSR RDMPBK ;READ IN NEW MAP BLOCK
 JMP #19 ;**8/5/87**

26 CLC ; KEEP ADDING UP NUMBER OF BLOCKS
 LDYIM 3
 LDAIY MPMBPT
 ADC MPTMPB
 STA MPTMPB
 INY
 LDAIY MPMBPT
 ADC MPTMPB+1
 STA MPTMPB+1
 BCC #28
 INC MPTMPB+2
28 LDA MPTMPB
 CMP DIVTMP ;CHECK IF ENOUGH BLOCKS FOUND
 LDA MPTMPB+1
 SBC DIVTMP+1
 LDA MPTMPB+2
 SBC DIVTMP+2
 BCS #30 ;BRANCH IF ENOUGH FOUND
 CLC ;HERE IF JUST LOOK AT NEXT ENTRY
 LDA MPMBPT
 ADCIM :LSB:ENSZ
 STA MPMBPT ; LOOK AT NEXT ENTRY
 LDA MPMBPT+1
 ADCIM :MSB:ENSZ
 STA MPMBPT+1
 JMP #20

30 LDA MPTMPB ;NOW SEE ABOUT THE SIZE
 CMP DIVTMP
 LDA MPTMPB+1
 SBC DIVTMP+1
 LDA MPTMPB+2
 SBC DIVTMP+2
 BCS #33 ;BRANCH IF MORE SPACE REQUIRED
 JMP NEEDMR
33 LDA MPTMPB
 CMP DIVTMP
 BNE #36 ;IF THESE ARE NOT THE SAME, ODD BLOCKS MUST BE DISCARDED
 LDA MPTMPB+1
 CMP DIVTMP+1
 BNE #36
 LDA MPTMPB+2
 CMP DIVPAR+2
 BNE #36 ;THEY ARE EQUAL SO NO PART GROUPS TO DEALLOCATE
 JMP #80
36 SEC ;FIND ODD NUMBER FOR DEALLOCATION
 LDA MPTMPB
 SBC DIVTMP
 STA MPTMPB
 LDA MPTMPB+1
 SBC DIVTMP+1
 STA MPTMPB+1
 LDA MPTMPB+2
 SBC DIVTMP+2
 STA MPTMPB+2
 LDYIM 3
 SEC ;GET NUMBER OF THIS GROUP TO DEALLOCATE
 LDAIY MPMBPT
 SBC MPTMPB
 STA MPTMPD
 STAIY MPMBPT
 INY
 LDAIY MPMBPT
 SBC MPTMPB+1
 STA MPTMPD+1
 STAIY MPMBPT
 LDAIM 0
 SEC
 SBC MPTMPB+2
 STA MPTMPD+2
 LDA MAPTMP
 STA CBSTA
 LDA MAPTMP+1
 STA CBSTA+1
 JSR MMBWT
 LDYIM 0
 CLC ; FIND DISC ADDRESS FOR DEALLOCATION
 LDAIY MPMBPT
 ADC MPTMPD
 STA MPTMPE
 INY
 LDAIY MPMBPT
 ADC MPTMPD+1
 STA MPTMPE+1
 INY
 LDAIY MPMBPT
 ADC MPTMPD+2
 STA MPTMPE+2
 INY
 LDAIY MPMBPT
 INY
 ORAIY MPMBPT
 BNE #40
 LDYIM 0
 TYA
 STAIY MPMBPT
 INY
 STAIY MPMBPT
 INY
 STAIY MPMBPT
40 ;FIND CYLINDER NUMBER
 LDAIM 0
 STA MPTMPC ;ZERO CYLINDER COUNT
 STA MPTMPC+1
43 SEC
 LDYIM MPSPCY
 LDA MPTMPE
 SBCIY MAPPTR
 STA MPTMPE
 INY
 LDA MPTMPE+1
 SBCIY MAPPTR
 STA MPTMPE+1
 LDA MPTMPE+2
 SBCIM 0
 STA MPTMPE+2
 BCC #46 ; FOUND IF GONE NEGATIVE
 INC MPTMPC
 BNE #43
 INC MPTMPC+1
 JMP #43

46 JSR RDBTMP ;READ THE RELEVANT BIT MAP
 BEQ #47
 JMP MPCHEN ;**23/2/87** failed, attempt recovery

47 JSR MBMLKD
 LDYIM MPSPCY
 CLC
 LDA MPTMPE
 ADCIY MAPPTR
 STA MPTMPD
 INY
 LDA MPTMPE+1
 ADCIY MAPPTR
 STA MPTMPD+1
 LDYIM 0
50 LDA MPTMPD+1
 BNE #53 ; CANNOT OF GOT TO THE RIGHT PLACE IF THIS NON-ZERO
 LDA MPTMPD
 CMPIM 8 ;CHECK FOR LESS THAN EIGHT
 BCC #56 ;IF LESS GO AND FIND ACTUAL BIT
53 INY
 SEC
 LDA MPTMPD ; KEEP DECREMENTING
 SBCIM 8
 STA MPTMPD
 BCS #50
 DEC MPTMPD+1
 JMP #50

56 LDA MPTMPB
 PHA ; SAVE THIS COUNT
 LDA MPTMPB+1
 PHA
 LDXIM 9 ; X TRACKS POSITION IN CURRENT BYTE
 LDAIY MPSCPT ; GET THE BYTE
60 RORA ; KEEP ROTATING FOR POSITION
 DEX
 DEC MPTMPD
 BPL #60
63 SEC ;MARK BLOCK FREE
 RORA
 PHP ; SAVE THESE VALUES
 PHA
 DEX
 BEQ #70 ; CHECK FOR END OF THIS BYTE
66 LDA MPTMPB ;CHECK IF ALL BLOCKS HAVE BEEN FREED
 BNE #67
 DEC MPTMPB+1
67 SEC
 SBCIM 1
 STA MPTMPB
 ORA MPTMPB+1
 BEQ #73 ; ZERO WHEN ALL DEALLOCATED
 PLA
 PLP ;GET VALUES BACK
 JMP #63 ;JUMP BACK TO FREE NEXT

70 STAIY MPSCPT ;SAVE THIS VALUE
 LDXIM 8 ;SET UP FOR WHOLE BYTE
 INY ;POINT TO NEXT ENTRY IN BIT MAP
 PLA
 PLP ;JUST TO GET RID OF THEM
 LDAIY MPSCPT ; GET NEW BYTE
 RORA ;SET UP FOR FREEING BLOCKS
 PHP
 PHA
 JMP #66

73 PLA
 PLP ;CLEAR VALUES ON STACK
76 RORA
 DEX
 BNE #76
 STAIY MPSCPT ; AND SAVE HIS VALUE
 PLA ; RETRIEVE BLOCK COUNT
 STA MPTMPB+1
 PLA
 STA MPTMPB
 JSR ADDFR ; ADD FREED BLOCKS TO BLOCK COUNT
 LDA MPscor ;**23/1/87**
 STA CBSTA
 LDA MPscor+1
 STA CBSTA+1
 JSR MBMWT
80 LDYIM ENSZ ; NOW REST OF ENTRIES CAN BE DEALLOCATED
 LDAIY MPMBPT ;CHECK FOR LAST ENTRY
 INY
 ORAIY MPMBPT
 INY
 ORAIY MPMBPT
 BEQ #90 ;IF NONE LEFT WE'VE FINSHED
 SEC
 LDA MPMBPT ; RETRIEVE ADDRESS OF MAP BLOCK
 SBC MAPTMP ; AND GET OFFSET
 STA MPSCPT
 LDA MPMBPT+1
 SBC MAPTMP+1
 STA MPSCPT+1
 CLC ;NOW POINT AT NEXT ENTRY
 LDA MPSCPT
 ADCIM :LSB:ENSZ
 STA MPSCPT
 LDA MPSCPT+1
 ADCIM :MSB:ENSZ
 STA MPSCPT+1
 LDAIM 0
 STA MPTMPE ;don't delete this map block
 JSR CLRBLK
90 JSR ULBM
 JSR ENSMB
 JSR ENSBM
 LDA ERRTYP
 BEQ #95
 LDAIM MPERRC
 JMP MPCHEN

95 JMP CSEND ;FINISH REDUCTION
;
; SIZE TO BE INCREASED
;
NEEDMR ROUT
 SEC ;GET THE POINTER
 LDA MPMBPT
 SBC MAPTMP
 STA SAVPTA ;SAVE THE OFFSET IN THE MAP BLOCK IN CASE IT NEEDS TO BE RESTORED
 LDA MPMBPT+1
 SBC MAPTMP+1
 STA SAVPTA+1
 LDA MPTMPA ;SAVE THE SIN OF THE MAP BLOCK
 STA SAVPTB
 LDA MPTMPA+1
 STA SAVPTB+1
 LDA MPTMPA+2
 STA SAVPTB+2
 SEC ;DISCOVER HOW MUCH NEEDS TO BE ALLOCATED
 LDA DIVTMP
 SBC MPTMPB
 STA DIVTMP
 LDA DIVTMP+1
 SBC MPTMPB+1
 STA DIVTMP+1
 LDA DIVTMP+2
 SBC MPTMPB+2
 STA DIVTMP+2
 LDYIM MPCYMP ;GET ADDRESS OF CYLINDER MAP
 LDAIY MAPPTR
 STA MAPGEN
 INY
 LDAIY MAPPTR
 STA MAPGEN+1
 SEC
 LDYIM 0 ; CHECK IF THERE IS ENOUGH SPACE
 LDAIY MAPGEN
 SBC DIVTMP
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 SBC DIVTMP+1
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 SBC DIVTMP+2
 STAIY MAPGEN
 BCS #10
 JMP #50 ; BRANCH IF THERE IS NO ROOM
10 LDA SAVPTA
 CMPIM MBENTS
 BNE #20
 LDA SAVPTA+1
 BEQ #30 ; EMPTY MAP BLOCK SO ALLOCATE FROM SIN
20 SEC
 LDA MPMBPT
 PHA
 SBCIM :LSB:ENSZ
 STA MPMBPT
 LDA MPMBPT+1
 PHA
 SBCIM :MSB:ENSZ
 STA MPMBPT+1
 LDYIM 0 ; GET A CURRENT DISC ADDRESS
 LDAIY MPMBPT
 STA MPTMPA
 INY
 LDAIY MPMBPT
 STA MPTMPA+1
 INY
 LDAIY MPMBPT
 STA MPTMPA+2
 PLA
 STA MPMBPT+1 ;**1/7/88** restore pointer
 PLA
 STA MPMBPT
30 JSR DIVSEC ; FIND CYLINDER FROM SIN
 LDA MPTMPB ;GET CYLINDER TO SOMEWHERE USEFUL
 STA MPTMPC
 LDA MPTMPB+1
 STA MPTMPC+1
 JSR GTCYPS ; FIND A CLOSE CYLINDER WITH FREE BLOCKS
 LDA MPTMPE
 STA MPTMPC
 LDA MPTMPE+1
 STA MPTMPC+1
 JSR RDBTMP
 BNE #55 ;**23/2/87** Failed, attempt to report error
 LDA MAPGEN
 STA MPCYPT ; READY TO ALLOCATE BLOCKS
 LDA MAPGEN+1
 STA MPCYPT+1
 JSR ABLKS ; ALLOCATE ONE LOT OF BLOCKS
 BCS #40 ; BRANCH IF FAILED
 LDA DIVTMP
 ORA DIVTMP+1
 ORA DIVTMP+2
 BEQ CSEND ; CHECK IF FINISHED
 JSR FLBLKS ; FILL IN THE REST OF THE BLOCKS
 BCS #40 ; BRANCH IF ALL WENT WELL
 JSR ENSBM
 JMP CSEND

40 LDA SAVPTB ; IT FAILED SO DEALLOCATE ANY BLOCKS STILL ALLOCATED
 STA MPTMPA ; GET SIN BACK
 LDA SAVPTB+1
 STA MPTMPA+1
 LDA SAVPTB+2
 STA MPTMPA+2
 LDA SAVPTA ; GET OFFSET BACK
 STA MPSCPT
 LDA SAVPTA+1
 STA MPSCPT+1
 LDAIM 0
 STA MPTMPE ; LEAVE CURRENT MAP BLOCK ALONE
 JSR CLRBLK ; TIDY UP
50 CLC
 LDYIM 0
 LDAIY MAPGEN
 ADC DIVTMP
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADC DIVTMP+1
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADC DIVTMP+2
 STAIY MAPGEN
 LDA ERRTYP
 BEQ #60
 LDAIM MPERRC
55 BNE MPCHEN

60 LDAIM MPERRB ; FLAG NO ROOM
 BNE MPCHEN

CSEND JSR RDmpbd ;**8/5/87** Read block at ARGD
 LDA MAPTMP
 STA MPMBPT
 STA CBSTA
 LDA MAPTMP+1
 STA MPMBPT+1
 STA CBSTA+1
 LDYIM BILB ; POSITION OF ODD BYTES
 LDA DIVPAR ; BYTES FROM DIVISION
 STAIY MPMBPT
 INY
 LDA DIVPAR+1
 STAIY MPMBPT
 JSR MMBWT
 JSR ENSMB
 JSR ENSBM
 LDAIM 0 ; INDICATE SUCCESS

MPCHEN BNE #80
 LDYIM ARGA
 LDAIY ARGPTR
 EORIM 14 ;detect special case
 BEQ #80
 LDYIM ARGJ
 LDAIM 0
 JSR MPSETF
80 JMP MPEXIT

;MPREST:
;FUNCTION: LOADS THE MAP TABLE FROM DISC.
;CHECKS THAT ALL MAPS ARE O.K. ALSO
;SETS UP TABLE FOR FREE STORE MANAGEMENT

MPREST ROUT ;CLEAR ALL VARS.
 LDAIM 0
 STA ERRTYP
 STA MAPTMP
 STA MAPTMP+1
 STA MPTMPA
 STA MPTMPA+1
 STA MPTMPB
 LDX DRIVES ;FOR LOOP
 LDYIM MPTBSZ
 JSR SETTAB ;SET MAP TABLE AND CLEAR STORE
 STY MAPTB
 STY MAPPTR
 STX MAPTB+1
 STX MAPPTR+1

 LDXIM NTSIZE
 LDYIM NTENSZ
 JSR SETTAB ;SET NAME TABLE
 STY NAMETB
 STX NAMETB+1

 STY DNMPTR
 STX DNMPTR+1
 LDXIM NTSIZE
 LDAIM UNUSED
 LDYIM NTUSED

;MARK ALL NAME TABLE ENTRIES UNUSED

10 STAIY DNMPTR
 PHA
 JSR INAMPT
 PLA
 DEX
 BNE #10

 LDXIM 1
 STX NXTDNO
 DEX
 STX NXTDNO+1 ;SET DISC ALLOCATION NO.
 JSR INBKMN

 LDAIM 0
 STA MPDRVE
 STA LDRNB
20 LDA FREPTR
 STA MPSCPT ;GENERAL PTR. TO SEC. ZERO DATA
 LDA FREPTR+1
 STA MPSCPT+1
 LDA MPDRVE
 STA DRIVNO

 JSR RDDATA ;GET INFO FROM DISC
 BNE #50 ;Ignore if disc error ** 14/06/86 **
 JSR CHKDSC ;CHECK IS FS DISC
 BNE #50 ;NOPE, ISN'T

;NOW SET MAP TABLE ENTRY FOR THIS DRIVE

 JSR SMAPEN

 JSR CHDNAM ;PUT IN NAME TABLE
 BEQ #30
25 LDAIM 0 ;Couldn't (duplicate disc name??)
 LDYIM Mpnocy
 STAIY Mapptr ;... so mark map entry unused
 INY
 STAIY Mapptr ;by saying it has no cylinders
 BNE #50 ; ** 14/10/86 **

;NOW CREATE CYLINDER MAP FOR THIS DISC'S MAP
30 JSR MPRESZ ;**5/3/88** get number of cylinders
 CLC ;NOW INCREASE SIZE TO HOLD FREE SPACE COUNT
 LDA MPTMPB
 ADCIM 3
 TAY
 LDA MPTMPB+1
 ADCIM 0
 TAX
 JSR GETVEC ;get space for cylinder map
 TYA ; SAVE ADDRESS OF CY.MAP
 LDYIM MPCYMP
 STAIY MAPPTR
 INY
 TXA
 STAIY MAPPTR
 JSR MPSTCY
 LDYIM MPADFT
 CLC
50 INC MPDRVE ; ** 14/06/86 ** drives contiguously numbered
 JSR MPADMP
 INC LDRNB
 LDA LDRNB
 CMP DRIVES
 BNE #20
 LDAIM 0 ;RC
 JMP MPEXIT

MPRESZ ROUT ;**5/3/88*** calculate number of cylinders
 JSR MPMPSZ ;total number of sectors 
 LDAIM 0
 STA MPTMPB
 STA MPTMPB+1
 LDYIM MPDSCS
 LDAIY MAPPTR
 TAX
10 LDYIM MPNOCY
 CLC
 LDAIY MAPPTR
 ADC MPTMPB
 STA MPTMPB
 INY
 LDAIY MAPPTR
 ADC MPTMPB+1
 STA MPTMPB+1
 DEX
 BNE #10
 STAIY MAPPTR ;restore total count
 DEY
 LDA MPTMPB
 STAIY MAPPTR
 CLC
 ROL MPTMPB ;multiply cyls by two   
 ROL MPTMPB+1
 RTS

;MPSZIN: RETURNS THE LENGTH OF A CHAIN IN BYTES AND BLOCKS

;ENTRY:
;ARGB-C DISC NO
;ARGD-F SIN

;EXIT:
;ARGA = RC
;ARGB-D SIZE IN BYTES
;ARGE-F SIZE IN BLOCKS

;FUNCTION: GETS THE RELEVANT ENTRY IN MAPTB. CHECKS THAT
;THE SIN POINTS TO THE START OF A CHAIN. RETURNS THE LENGTH OF THE CHAIN.

MPSZIN ROUT
 JSR FNDMAP ;GET MAP TO MAPPTR
 BNE #20
 JSR RDmpbd ;**8/5/87** Read block at ARGD
 BEQ #10
 LDAIM MPERRC ;ERROR RETURN OF NOT START
 BNE #20 ;AND RETURN

10 LDA MAPTMP
 STA MPMBPT
 LDA MAPTMP+1
 STA MPMBPT+1
 JSR MPGTSZ ;GET SIZE OF MAP
 LDYIM ARGB
 LDA MPTMPA ;SIZE IS IN MPTMPA
 STAIY ARGPTR
 INY
 LDA MPTMPA+1
 STAIY ARGPTR
 INY
 LDA MPTMPA+2
 STAIY ARGPTR
 LDYIM ARGE
 LDA MPTMPD
 STAIY ARGPTR ;SAVE NUMBER OF BLOCKS
 INY
 LDA MPTMPD+1
 STAIY ARGPTR
 LDAIM 0 ;RC
20 JMP MPEXIT

;MPSNRT: RETURNS THE SIN OF THE ROOT DIRECTORY
;ENTRY:
;ARGB-C DISC NO

;EXIT:
;ARGA = RC
;ARGB-D SIN OF ROOT DIRECTORY
;ARGE-F DATE ROOT CREATED


MPSNRT ROUT
 JSR FNDMAP
 BNE #30
 LDYIM MPRTSN
10 LDAIY MAPPTR
 PHA
 INY
 CPYIM MPRTSN+5
 BNE #10

 LDYIM ARGF
20 PLA
 STAIY ARGPTR
 DEY
 CPYIM ARGA
 BNE #20

 LDAIM 0
30 JMP MPEXIT

 LNK UADE11
