 OPT UADE0C ;FILE > Uade0C
 TTL File server file UADE0C

;**********************************
;*           D I R M A N          *
;**********************************

;DIRMAN: THE DIRECTORY MANAGER.
;1) PRESERVE SIN OF AN OBJECT IN A DIR
;2) RETRVE SIN OF AN OBJ WITH GIVEN FILE TITLE
;3) DELETE - REMOVE A DIR ENTRY
;4) SETATTRIBS
;5) CREATE DIR
;6) CHANGE OBJECT SIZE
;7) EXAMINE
;8) FORMATTED DETAILS OF DIR ENTRY
;9) MAKE DIRECTORY removed ** 3/10/84 **
;10) GIVE DISC NAME FROM FILE TITLE
;11) Remove a directory ** 24/9/84 **  
;12) Preserve object (without DELCHK) ** 25/9/84 **
;13) Check if object will preserve **23/3/88**

DIRMAN LDXIM 13
 LDAIM MODDIR
 JSR ENTRY
 LDAAX DRRTNS
 STA DRJUMP+1
 LDAAX DRRTNS+1
 STA DRJUMP+2
 LDAIM &19
 JSR SETFS
DRJUMP JMP DRJUMP
DRRTNS
 & DRPRES ;1 => PRESERVE OBJECT
 & DRRETR ;2 => RETRIEVE OBJECT
 & DRDELT ;3 => DELETE OBJECT
 & DRSACC ;4 => SET ATTRIBUTES
 & DRCRDR ;5 => CREATE DIRECTORY
 & DRCHSZ ;6 => CHANGE SIZE OF OBJECT
 & DREXAM ;7 => GIVE DETAILS FOR EXAMINE
 & DRINFO ;8 => DETAILS OF OBJECT(CHAR STRING FORMAT)
 & DRMAKE ;9 => MAKE A DIR (DON'T PRESERVE)
 & DRFTDN ;10 => FILE TITLE -> DISC NO.
 & DRDELT ;11 => Remove a directory
 & DRPRES ;12 => Preserve object without delchk
 & DRPRES ;13 => Check if object will preserve
DREXIT JMP PREXIT ;**25/12/86**

;*********** DRPRES ***********

;DRPRES: PRESERVE THE SIN OF AN OBJECT WITH A GIVEN TITLE

;ENTRY:
;ARGB-C PTR TO USERINFO
;ARGD-E PTR TO FILE TITLE
;ARGF-I LOAD ADDR
;ARGJ-M EXEC ADDR
;ARGN = TYPE AND ACCESS (TLWR/WR)
;ARGO-P DATE CREATED
;ARGQ-S SIN
;ARGT = WILD CARD FLAG

;EXIT :
;ARGA = RC
;ARGB-C DISC NO
;ARGD-E SIN OF OBJECT TO BE DELETED
;ARGG = Access byte

;N.B. IF ARGD!ARGE!ARGF = 0 THEN NO DELETE NEEDED


DRPRES ROUT
 LDYIM ARGT ;get wild card flag
 LDAIY ARGPTR
 STA DIRWC ;save flag for decoding routines
 JSR INITDV ;INIT VARIABLES
 BNE #10

;CHECK FOR OWNER ACCESS

 JSR TSTOWN
 BNE #10

;RETRIEVE APPROPRIATE DIR

 JSR RETDIR
 BNE #10

 LDYIM ARGA
 LDAIY ARGPTR ;check entry code
 EORIM 12 ;dont do DELCHK in retain
 JSR RETA12 ;special case
10 PHA ;**25/12/86**
 LDA OBJACC
 LDYIM ARGG
 STAIY ARGPTR
 PLA
 JMP DREXIT ;**25/12/86**


;************ DRRETR ************

;DRRETR: RETRIEVE DETAILS OF A SPECIFIED OBJECT

;ENTRY:
;ARGB-C PTR TO USERINFO
;ARGD-E PTR TO FILE TITLE
;ARGF-G ADDRESS OF STORE AREA TO CONTAIN DETAILS
;ARGH = Wild card flag

;EXIT: ARGA = RC
;ARGB = TYPE OF OBJECT & MAX ACCESS ALLOWED TO IT
;       Also contains "lock" bit and OWNER/PUBLIC bit

;DETAILS INCLUDE:-
;FILE TITLE (10 BYTES)
;LOAD ADDR (4BYTES),
;EXEC ADDR (4BYTES),
;ACC INFO (1 BYTE),
;CREATION DATE (2 BYTE),
;SIN (3BYTES),
;DISC NO (2BYTES),      Set after any non-syntax error ** 14/10/86 **
;SIZE (3BYTES).


DRRETR ROUT
 JSR DRRET2 ;**4/4/88** call as subroutine
 JMP DREXIT

DRRET2 LDYIM ARGH
 LDAIY ARGPTR
 ORAIM &02 ;**2/6/87** "^" allowed at end
 STA DIRWC ;get wild card flag
 JSR INITDV
 BEQ #00
 JMP #60

00 JSR SETINF ;**08/02/87**

 LDYIM INFDIS ;in case fail later still make some details
 LDA DRDISC ;point to disc number (if any) as this is
 STAIY INFPTR ;needed by RENAME
 INY
 LDA DRDISC+1
 STAIY INFPTR ;end ** 14/10/86 **

;RETRIEVE RELEVENT DIR

 JSR TSTROT ;TEST FOR <root><terminator>
 BNE #20

;SUPPLY DETAILS OF ROOT DIR

 LDAIM ROOT ;**4/4/88** Set up name
 JSR OUTCH
 LDXIM 9
 JSR OUTSPS
 JSR SETINF ;Reset INFPTR

05 LDYIM INFLOA
 LDXIM 8
 LDAIM 0
10 STAIY INFPTR ;LOAD ADDRESS:=EXEC ADDR:=0
 INY
 DEX
 BNE #10

 LDA DIRACC
 LDYIM ARGB
 STAIY ARGPTR ;ACCESS TO ROOT DIR
 LDYIM INFACC
 LDAIM TYPDIR+LOCKED
 STAIY INFPTR
 INY
 LDA TDATE ;(DATE OF CREATION ROOT)
 STAIY INFPTR
 INY
 LDA TDATE+1
 STAIY INFPTR
 LDA DIRSIN
 INY
 STAIY INFPTR
 LDA DIRSIN+1
 INY
 STAIY INFPTR
 LDA DIRSIN+2
 INY
 STAIY INFPTR
 JSR DIROBJ ;**08/02/87** Copy DIRSIN to OBJSIN
 JSR RETDSZ ;PLACE DISC NO & SIZE IN INFPTR
 JMP #50

20 JSR TSTPAR ;**23/1/87** check if ^ for parent
 BNE #25
; JSR RETPAR ;**23/1/87** retrieve parent directory
; BNE #40
; JSR UNLOCK
21 CLC ;**20/5/87** copy name of parent directory
 LDA DIRSTA
 ADCIM DRNAME
 STA MOVFRM
 LDA DIRSTA+1
 ADCIM 0
 STA MOVFRM+1
 LDYIM NAMLNT-1
22 LDAIY MOVFRM
 STAIY INFPTR
 DEY
 BPL #22
 BMI #05 ;**23/1/87** complete info entry a la root

 [ Pseudods = Yes
25 LDYIM 1 ;**20/5/87** check lone pseudo-directory
 LDAIY NAMPTR
 CMPIM TERMIN
 BNE #27
 DEY
 LDAIY NAMPTR
 JSR Testpd
 BNE #27
 JSR LOADDR ;**20/5/87** load directory
 BNE #60
 |
25 BNE #27
 ]
26 JSR UNLOCK
 JMP #21 ;**20/5/87** go update details  
 
27 LDYIM ARGH ;get flag
 LDAIY ARGPTR
 RORA
 BCC #30
 JSR RETEND ;get directory
 JMP #40
30 JSR RETENT
40 BNE #60
 JSR Tsparn ;**2/6/87** parent at end?
 BEQ #26 ;**2/6/87** yes, extract details now

;COPY DETAILS INTO STORE AREA POINTED TO BY INFPTR

 JSR DETALS
 PHA ;Push return code

;NOW CALCULATE CALLER'S ACCESS TO THE OBJECT

 JSR MAXACC

 LDYIM ARGB
 STAIY ARGPTR ;TYPE & MAX ACCESS ALLOWED TO OBJECT
 JSR UNLOCK ;STRMAN.UNLOCK (DIR)
 PLA ;Pull DETALS return code
 BNE #60 ;Error

50 LDAIM 0 ;RC:=0
60 RTS ;**4/4/88**

;MAKE INFPTR POINT TO DETAILS AREA

SETINF ROUT
 LDYIM ARGF
 LDAIY ARGPTR
 STA INFPTR
 INY
 LDAIY ARGPTR
 STA INFPTR+1
 INY
 RTS



;************ DRDELT ************


;DRDELT: DELETE

;ENTRY:
;ARGB-C PTR TO USERINFO
;ARGD-E PTR TO FILE TITLE

;EXIT :
;ARGA = RC
;ARGB-C DISC NO
;ARGD-F SIN OF OBJECT TO BE DELETED


DRDELT ROUT
 LDYIM ARGG
 LDAIY ARGPTR
 STA DIRWC ;get wild card flag
 JSR INITDV ;INIT VARIABLES
 BNE #20

;CHECK FOR OWNER ACCESS

 JSR TSTOWN
 BNE #20

;RETRIEVE APPROPRIATE DIR ENTRY

 JSR RETENT ;RETRIEVE REQ'D ENTRY
 BNE #20

;FIRST CHECK THAT ENTRY MAY BE DELETED

 LDYIM ARGA ;check entry code
 LDAIY ARGPTR ;** 24/9/84 **
 CMPIM 11
 BEQ #10 ;skip delete check if 'remove' called

 JSR DELCHK
 BEQ #10
 JSR UNLOCK
 BNE #20

;NOW REMEMBER DISC NO & SIN OF OBJECT TO BE DELETED

10 JSR CRNSIN ;OBJSIN := SIN OF CRNTEN
 JSR ARGDSN ;PLACE DISC NO & SIN ON ARGPTR STACK

;NOW UNCHAIN CURRENT DIR ENTRY & PLACE
;IT ON THE FREE CHAIN

 LDYIM DRLINK
 LDAIY CRNTEN
 STAIY PREVEN
 INY
 LDAIY CRNTEN
 STAIY PREVEN ;[PREVEN] := [CRNTEN]

 JSR FREECH ;PLACE CRNTEN ENTRY ON FREE CHAIN

;NOW DECREMENT COUNT OF NUMBER OF DIR ENTRIES

 JSR SETGEN ;GENPTR := [DIRSTA]
 SEC
 LDYIM DRENTS
 LDAIY GENPTR
 SBCIM 1
 STAIY GENPTR
 INY
 LDAIY GENPTR
 SBCIM 0
 STAIY GENPTR ;[DIRSTA + DRENTS] -:= 1

;ENSURE UPTO DATE ON DISC

 JSR ENSRIT

20 JMP DREXIT ;**25/12/86**


;************ DRSACC ************


;DRSACC: SET ATTRIBUTES

;ENTRY:
;ARGB-C PTR TO USERINFO
;ARGD-E PTR TO FILE TITLE
;ARGG = FN
;     FN = 1 => SET LOAD/EXEC & ACCESS
;     FN = 2 => SET LOAD ADDR
;     FN = 3 => SET EXEC ADDR
;     FN = 4 => SET ACCESS BYTE
;     FN = 5 => SET DATE
;ARGH +n (depending on ARGF) = ATTRIBUTES TO SET

;EXIT : ARGA = RC


;FORMAT OF ACCESS BYTE:-

;BIT0->PUBLIC HAS READ ACCESS
;BIT1->PUBLIC HAS WRITE ACCESS
;BIT2->OWNER HAS READ ACCESS
;BIT3->OWNER HAS WRITE ACCESS
;BIT4->ENTRY IS LOCKED

DRSAT1 = DRLOAD ;Offsets in directory entry
 = DRLOAD
 = DREXEC
 = DRACCS
 = DRDATE

DRSAT2 =  9 ;Length of data
 =  4
 =  4
 =  1
 =  2

DRSACC ROUT
 LDAIM 0
 STA DMTEMP+2 ;save space for Access arg
 LDYIM ARGF
 LDAIY ARGPTR
 STA DIRWC ;get wild card flag
 JSR INITDV ;INITIALISE VARIABLES
 BNE #50

 LDYIM ARGG ;CHECK IF JUST DATE UPDATE
 LDAIY ARGPTR
 CMPIM 5
 BEQ #10 ;NO NEED FOR OWNER ACCESS

;CHECK FOR OWNER ACCESS

 JSR TSTOWN
 BNE #50

;RETRIEVE APPROPRIATE DIR ENTRY

10 JSR RETENT
 BNE #50

20 LDYIM ARGG
 LDAIY ARGPTR
 STA DMTEMP+1 ;Store for later
 LDYIM ARGH ;Position of access if A=4
 CMPIM 4 ;If SETACCESS, must mask off access bits
 BEQ #25 ;Is SETACCESS -> check access byte
 CMPIM 5 ;** 31/1/85 **
 BEQ #55
 CMPIM 1
 BNE #40 ;Is "all attribs" so check access
 LDYIM ARGP ;Position of access if A = 1

25 STY DMTEMP ;Store offset of access
 LDAIY ARGPTR ;Read access byte
 ANDIM ACCMSK ;Mask off access bits
 ORA DMTEMP+2
 STA DMTEMP+2
 STAIY ARGPTR
 TAX  ;Store for later

;** 15/11/84 ** w/ access illegal
 ANDIM &0C ;owner bits set
 BEQ #35
 ANDIM &04 ;at least r bit set
 BNE #35
 LDAIM SAERRA ;'bad attribute' error
 BNE #45

35 JSR ISDIR
 BNE #55 ;Is not a directory, so continue
 TXA
 ANDIM ACCMSK-RWMSK ;just the lock bit
 ORAIM TYPDIR ;Or in directory info. if a dir. 
 LDY DMTEMP
 STAIY ARGPTR ;Stuff access argument
 LDA DMTEMP+1 ;Load function no.
 CMPIM 1
 BNE #55 ;Check not setting load/exec. of a dir.

40 JSR ISDIR ;Check if is directory
 BNE #55 ;Cannot set load/exec address of dir., so error
 LDAIM DRERRF ;Bad arg.

45 JSR UNLOCK ;Otherwise, error
50 JMP #65 ;Error exit

55 LDYIM ARGG ;Here, all checks made, so set attribs
 LDAIY ARGPTR 
 TAY
 LDAIM ARGH ;Set args for block move from stack
 STA OFF1 ;to some offset in CRNTEN
 LDAAY DRSAT1-1 ;Get offset in dir. entry
 STA OFF2 ;"Move to" offset
 LDAAY DRSAT2-1 ;Length to move
 LDXIM ARGPTR ;"Move from" ptr.
 LDYIM CRNTEN ;"Move to" ptr.
 JSR MOVBLK ;Move args to stack

 LDYIM ARGG
 LDAIY ARGPTR
 CMPIM 5 ;DON'T SET ALL DATES
 BEQ #60

 JSR FNDTEZ ;try for any more entries
 BNE #60
 JMP #20

60 JSR ENSRIT ;Ensure directory and exit

65 JMP DREXIT ;**25/12/86**



;************ DRCRDR ************


;DRCRDR: CREATE & PRESERVE A NEW DIRECTORY

;ENTRY:
;ARGB-C PTR TO USERINFO
;ARGD-E PTR TO FILE TITLE
;ARGF = Size of directory ** 15/9/83 **
;ARGG = Wild card flag

;EXIT :
;ARGA = RC
;ARGB-C DISC NO
;ARGD-F SIN OF OBJECT TO BE DELETED

DRCRDR ROUT
 LDYIM ARGG
 LDAIY ARGPTR
 STA DIRWC ;get wild card flag
 JSR INITDV
 BNE #40

;CHECK FOR OWNER ACCESS

 JSR TSTOWN
 BNE #40

;Load parent directory and save SIN  **23/1/87**

 JSR RETDIR
 BNE #40
 LDA DIRSIN
 STA EXRTN
 LDA DIRSIN+1
 STA EXRTN+1
 LDA DIRSIN+2
 STA EXRTN+2
 JSR UNLOCK ;release parent pro tem
 JSR TSTPAR ;prohibit new name of "^"
 BEQ #50
 [ Pseudods = Yes
 LDYIM 0 ;**20/5/87** prohibit new names of "&", "%", "@"
 LDAIY NAMPTR
 JSR Testpd
 BNE #15
 JSR TSTTER
 BEQ #50
 ]
15 LDYIM ARGG
 LDAIY ARGPTR
 STA DIRWC ;**24/7/87** get wild card flag again
 JSR INITDV ;reinitialise variables
 BNE #40

;CREATE A VIRGIN DIRECTORY

 LDYIM ARGF
 LDAIY ARGPTR
 STA DIRTMP+1 ;DIRTMP := SIZE OF DIRECTORY REQD.
 LDAIM 0
 STA DIRTMP
 STA DIRTMP+2
 JSR MAKDIR ;SETUP ARGPTR ARGUMENTS FOR DIRMAN.PRESERVE
 BNE #40

;NOW UNLOCK THE CREATED DIR - THE RETAIN RTN
;ENSURES THAT ITS UPTO DATE ON DISC

 JSR UNLOCK

;NOW HAVE IT RETAINED

 JSR INITDV ;REINITIALISE VARIABLES
 BEQ #30

;OBJSIN:=SIN OF NEW DIR(RETAIN DESTROYS OBJSIN)
20 JSR DELOBJ ;**** 17/3/83 ****
 JMP #40

;LOAD APPROPRATE DIR

30 JSR RETDIR
 BNE #20

;NOW HAVE IT RETAINED IN THIS DIR

 JSR RETAIN
 BNE #20
40 JMP DREXIT

50 LDAIM DRERRA ;Can't use name "^"
 BNE #40



;************ DRCHSZ ************

;DRCHSZ: CHANGE SIZE OF A FILE

;ENTRY: ARGB = LS
;ARGC = MS(PTR TO USERINFO)
;ARGD = LS
;ARGE = MS(PTR TO FILE TITLE)
;ARGF = LS
;ARGG = CS
;ARGH = MS(NEW SIZE)

;EXIT : ARGA = RC

;FUNCTION:-
;REMOVE ALL OF THE OBJECT FROM THE CACHE;
;IF TYPE OF OBJECT = FILE
;THEN CHECK FOR WRITE ACCESS;
;CHECK THAT FILE IS NOT OPEN;
;CHANGE SIZE;
;ENSURE OBJECT MAP UPTO DATE ON DISC
;ELIF TYPE OF OBJECT = DIR
;THEN RC:=WRONG TYPE #AUTOMATICALLY DONE IN RETAIN#
;FI

DRCHSZ ROUT
 [ 1=1
 LDAIM IERRAC ;Not used in FileStore ** 29/09/86 **
 JMP INTERR
 |
 LDYIM ARGI
 LDAIY ARGPTR
 STA DIRWC ;get wild card flag
 JSR INITDV
 BNE #40

;RETRIEVE DIR ENTRY

 JSR RETENT
 BNE #40

 JSR CRNSIN ;OBJSIN := SIN OF CURRENT DIR ENTRY
 JSR MAXACC ;OBJACC := TYPE & ACCESS HELD FOR OBJECT
 JSR UNLOCK ;UNLOCK DIR
 JSR REMOVE ;REMOVE OBJSIN FROM THE CACHE
 BNE #40 ;error trap **** 17/3/83 ****
 LDA OBJACC
 ANDIM TYPE
 CMPIM TYPDIR
 BNE #10
 LDAIM DRERRF ;WRONG TYPE
 BNE #40

;DEAL WITH A FILE

10 LDA OBJACC
 ANDIM WRITAC
 BNE #20
 LDAIM DRERRL ;NO WRITE ACCESS !
 BNE #40

;CHECK THAT THE FILE IS NOT OPEN

20 LDAIM 2 ;RNDMAN.INFO
 JSR SETDSA ;PLACE ARG, OBJECT DISC NO & SIN ONTO NEWARG STACK
 JSR RNDMAN
 BNE #30
 LDAIM DRERRI
 BNE #40

;NOW CALL MAPMAN TO HAVE THE SIZE CHANGED

30 LDAIM 3
 JSR SETDSA
 LDYIM ARGF
 LDAIY ARGPTR
 LDYIM ARGB
 STAIY NEWARG ;LS(NEW SIZE)
 LDYIM ARGG
 LDAIY ARGPTR
 LDYIM ARGC
 STAIY NEWARG ;CS(NEW SIZE)
 LDYIM ARGH
 LDAIY ARGPTR
 LDYIM ARGD
 STAIY NEWARG ;MS(NEW SIZE)

 JSR JUSINF ;** 3/10/84 pass userinfo ptr

 JSR MAPMAN
 BNE #40
 JSR ENSOMP ;ENSURE OBJECT MAP

40 JMP DREXIT
 ]

;******** EXAMINE ROUTINE ********

;DREXAM : GIVE DETAILS OF ENTRY(S) IN A DIR.
;ENTRY:
;ARGB/C PTR TO USER INFO
;ARGD/E PTR TO FILE TITL
;ARGF/G ADDRESS OF STORE FOR RESULT
;ARGH = TYPE OF RESULT REQURIED
;0 => ALL INFO, M/C READABLE
;1 => ALL INFO, CHAR STRING
;2 => FILE TITLE + FILE NAME LENGTH, M/C
;3 => ACCESS+FILE TITLE, CHAR STRING
;4 => GIVE LAST COMPONENT F.T. ONLY
;ARGI = ENTRY POINT TO DIR.
;ARGJ = NO. OF ENTRIES (0=> ALL DIR.)
;ARGK = wild card flag

;EXIT :
;ARGB/C PTR TO BYTE AFTER RESULT END
;ARGD = NO. OF ENTRIES
;ARGE = SEQ. NO. OF DIRECTORY BEING EXAMINED

;WHEN ARGH IS 4, ARGD IS MAX. ACCESS TO DIR,
;ARGE IS SEQUENCE NUMBER OF DIR., AND
;ARGF/G ARE DISC. NO LO/HI

;TABLE OF EXAMINE ROUTINE ENTRY POINTS

DEXTAB & EXRTNA
 & EXRTNB
 & EXRTNC
 & EXRTND

DREXAM ROUT
 LDAIM 0
 STA DIRFLG
 LDYIM ARGK
 LDAIY ARGPTR
 ORAIM &02 ;**2/6/87** "^" allowed at end of name
 STA DIRWC ;get wild card flag
 RORA ;look at bit0
 BCC #10
 LDAIM &80
 STA DIRFLG
10 JSR INITDV
 BNE #20

 JSR SETINF ;STORE RESULT PTR.

 LDAIY ARGPTR
 CMPIM 5
 BCC #15 ;IF <5, OK
 LDAIM DRERRO ;BAD ARG. TO EXAMINE
 BNE #20

15 STA EXARG ;TYPE OF RESULT
 INY
 LDAIY ARGPTR
 STA EXENTR ;ENTRY TO DIR.
 INY
 LDAIY ARGPTR
 JSR CHKENS
 BCC #25 ;OK
 LDAIM DRERRN ;TOO MANY ENTRIES REQUESTED
20 JMP #75

25 STA EXENTS ;NO. OF ENTRIES
 JSR GETDRD ;LOAD APPROPRIATE DIR
 BNE #20
 LDAIM 4
 CMP EXARG
 BNE #35

;IF HERE, COPY FILE NAME FROM DIRECTORY
;INTO RESULT AREA.

 LDYIM DRNAME ;OFFSET IN DIR.
 LDXIM 0
30 LDAIY DPTRLD
 STAIX INFPTR
 INY
 JSR INCIPT
 CPYIM DRFREE
 BNE #30

 LDYIM DRSQNO
 LDAIY DPTRLD ;Read dir. sequence number
 PHA ;Store for later use

 LDA DIRACC
 LDYIM ARGD
 STAIY ARGPTR
 PLA ;Pull sequence number
 INY
 STAIY ARGPTR
 LDA DRDISC
 INY
 STAIY ARGPTR
 INY
 LDA DRDISC+1
 STAIY ARGPTR
 JMP #70

35 JSR INTPRE ;PREVEN := DIRSTA

;FOR I=0 TO EXENTR DO
;$( SET CURRENT := NEXT(PREV. ENTRY)
;IF END OF DIR...EXIT WITH RC SET
;PREVENTRY := CURRENT ENTRY
;$)

40 JSR SETCRN
 BEQ #60 ;Zero => end of dir => exit
 LDA EXENTR
 DEC EXENTR
 TAX
 BEQ #45 ;LOOP FINISHED
 JSR MOVCRN ;PREVEN := CRNTEN
 JMP #40

;SET ROUTINE TO BE USED, DEPENDING
;ON EXARG.
;EXRTN := JMP <examine routine>

45 LDA EXARG
 ASLA
 TAX
 LDAAX DEXTAB
 STA EXRTN+1
 LDAAX DEXTAB+1
 STA EXRTN+2
 LDAIM JMPINS
 STA EXRTN
 LDAIM 0 ;NO. OF ENTRIES

;LOOP ROUND EXAMINE ROUTINE, DECREMENTING
;EXENTS, AND CHAINING THROUGH DIR.

50 PHA  ;STORE NO. OF ENTRIES
 JSR EXRTN ; call routine
 BEQ #55
 TAX
 PLA ;Restore stack
 TXA
 JSR UNLOCK
 BNE #75 ;Error -> exit [always jump]

55 PLA
 CLC
 ADCIM 1 ;ADD NO. OF ENTS.
 PHA
 LDA CRNTEN
 STA PREVEN
 LDA CRNTEN+1
 STA PREVEN+1
 JSR SETCRN ;CURRENT := NEXT(PREV)
 BEQ #65 ;NOT OK, FINISH LOOP
 PLA
 CMP EXENTS
 BNE #50

;FINALLY, SET END OF BLOCK INDICATOR.
60 PHA
65 LDAIM EXTERM
 LDYIM 0
 STAIY INFPTR
 JSR INCIPT ;INCREMENT POINTER TO END OF BLOCK (USED IN TXCB).
 LDYIM ARGB
 LDA INFPTR
 STAIY ARGPTR
 INY
 LDA INFPTR+1
 STAIY ARGPTR
 INY
 PLA  ;GET NO. OF ENTRIES
 STAIY ARGPTR

 LDYIM DRSQNO
 LDAIY DPTRLD ;Get sequence no. of examined dir.
 LDYIM ARGE
 STAIY ARGPTR ;And return it

70 JSR UNLOCK

 LDAIM 0 ;OK EXIT
75 JMP DREXIT



;******** DRINFO ********

;DRINFO: RETRIEVE DETAILS OF A GIVEN OBJECT IN
;FORMATTED FORM.

;ENTRY:
;ARGB-C PTR TO USER INFO
;ARGD-E PTR TO FILE TITLE
;ARGF-G ADDRESS OF RESULT AREA
;ARGH   Wild Card Flag

;EXIT:
;ARGB-C ADDRESS OF BYTE AFTER RESULT AREA

;BYTE AFTER RESULT AREA IS USED TO
;SET UP BUFFER POINTERS IN TXCB AFTER
;DETAILS CALL.


DRINFO ROUT
 JSR DRRET2 ;**4/4/88** Retrieve info to output area
 BNE #40

 JSR SETINF ;Set pointer to result area
 LDA INFPTR ;Set up to copy details
 STA MOVFRM ;(as we will overwrite output area)
 LDA INFPTR+1
 STA MOVFRM+1
 SEC
 LDAIM :LSB:DETNAM
 STA MOVTO
 SBCIM :LSB:DRTITL
 STA CRNTEN ;Save for use in EXAM routines
 LDAIM :MSB:DETNAM
 STA MOVTO+1
 SBCIM :MSB:DRTITL
 STA CRNTEN+1
 LDXIM INFNXT ;Move all details
 JSR MOVE

 JSR MOVEFT ;Copy info as text, name first
 JSR OUTSP
 JSR OUTLEX
 LDAIM 0
 STA FILLFL
 LDA DETSZ+2
 JSR OUTBYT
 LDA DETSZ+1
 JSR OUTBYT
 LDA DETSZ
 JSR OUTBYT
 LDXIM 3 
 JSR OUTSPS
 JSR OUTEN2 ;Rest of entry common with EXAM

;END OF ENTRY. PUT CR AT END TO FORCE
;A NEW LINE IF OSASCII'ING AT THE
;CLIENT END, AND EXTERM CHAR. TO
;INDICATE END OF DATA.

 LDAIM CR
 JSR OUTCH
 LDAIM EXTERM
 JSR OUTCH

 LDYIM ARGB ;PUT INFPTR ON STACK AS RESULT
 LDA INFPTR
 STAIY ARGPTR
 INY
 LDA INFPTR+1
 STAIY ARGPTR

 LDAIM 0

40 JMP DREXIT

;Copy DIRSIN to OBJSIN

DIROBJ ROUT
 LDA DIRSIN
 STA OBJSIN ;SET SIN FOR SIZE ROUTINE
 LDA DIRSIN+1
 STA OBJSIN+1
 LDA DIRSIN+2
 STA OBJSIN+2
 RTS



;************ DRMAKE ************


;DRMAKE: MAKE THE ROOT DIRECTORY-BUT DON'T RETAIN IT.
;USED IN DISC INITIALISATION.

;ENTRY: ARGB-ARGD = APPROX SIZE OF DIR(IN BYTES)
;N.B. DRDISC MUST = DISC NUMBER

;EXIT : ARGA = RC
;ARGF-ARGS SAME AS DIRMAN.PRESERVE'S ENTRY ARGS

DRMAKE ROUT
 [ 1=0
 LDAIM 0
 STA DIRWC ;get wild card flag
 LDYIM ARGB
 LDAIY ARGPTR
 STA DIRTMP
 INY
 LDAIY ARGPTR
 STA DIRTMP+1
 INY
 LDAIY ARGPTR
 STA DIRTMP+2
 LDAIM 0
 STA EXRTN ;**23/1/87** no parent directory
 STA EXRTN+1
 STA EXRTN+2
 JSR MAKDIR

;MOVE "$" INTO THE HEADER

 BNE #40
 LDXIM NAMLNT
 LDYIM DRNAME
 LDAIM ROOT
10 STAIY DPTRLD
 LDAIM SPACE
 INY
 DEX
 BNE #10

;NOW ENSURE THE DIR UPTO DATE ON DISC AND ENSURE
;THE DISC MAP

 JSR ENSRIT ;ENSURE & UNLOCK IT
 BEQ #30

20 JSR DELOBJ ;DELETE IT
 JMP #40

30 JSR ENSOMP ;OBJSIN MUST = SIN OF DIR
 BNE #20
40 JMP DREXIT
 |
 LDAIM &FF
 JMP DREXIT ;**3/10/84**
 ]

;************* DRFTDN ****************

;GIVEN FILE TITLE, ANALYSE TO GET DISC NUMBER
;AND RETURN. USED BY SAVE IN C.PROC TO
;RESOLVE ON WHAT DISC TO SAVE A FILE

;ENTRY:
;ARGB-C PTR TO USER INFO
;ARGD-E PTR TO FILE TITLE

;EXIT:
;ARGB-C DISC NUMBER

DRFTDN ROUT
 LDYIM ARGF
 LDAIY ARGPTR
 STA DIRWC ;get wild card flag
 JSR INITDV
 BNE #10
 LDYIM ARGB
 LDA DRDISC
 STAIY ARGPTR
 INY
 LDA DRDISC+1
 STAIY ARGPTR
 LDAIM 0 ;=> success
10 JMP DREXIT

 LNK UADE0D
