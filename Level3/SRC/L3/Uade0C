 OPT UADE0C ;FILE > Uade0C
 TTL File server file UADE0C

;**********************************
;*           D I R M A N          *
;**********************************

;DIRMAN: THE DIRECTORY MANAGER.
;DIRMAN HAS 10 ENTRY POINTS:-
;1) PRESERVE SIN OF AN OBJECT IN A DIR
;2) RETRVE SIN OF AN OBJ WITH GIVEN FILE TITLE
;3) DELETE - REMOVE A DIR ENTRY
;4) SETATTRIBS
;5) CREATE DIR
;6) CHANGE OBJECT SIZE
;7) EXAMINE
;8) FORMATTED DETAILS OF DIR ENTRY
;9) MAKE DIRECTORY removed ** 3/10/84 **
;10) GIVE DISC NAME FROM FILE TITLE
 [ 1=0
;11) EXAMINE A DIRECTORY
 ]
;11) Remove a directory ** 24/9/84 **  
;12) Preserve object (without DELCHK) ** 25/9/84 **

DIRMAN LDXIM 12
 LDAIM MODDIR
 JSR ENTRY
 LDAAX DRRTNS
 STA DRJUMP + 1
 LDAAX DRRTNS + 1
 STA DRJUMP + 2
 LDAIM &19
 JSR SETFS
 JMP DRJUMP
DRRTNS
 & DRPRES ;1 => PRESERVE OBJECT
 & DRRETR ;2 => RETRIEVE OBJECT
 & DRDELT ;3 => DELETE OBJECT
 & DRSACC ;4 => SET ATTRIBUTES
 & DRCRDR ;5 => CREATE DIRECTORY
 & DRCHSZ ;6 => CHANGE SIZE OF OBJECT
 & DREXAM ;7 => GIVE DETAILS FOR EXAMINE
 & DRINFO ;8 => DETAILS OF OBJECT(CHAR STRING FORMAT)
 & DRMAKE ;9 => MAKE A DIR (DON'T PRESERVE)
 & DRFTDN ;10 => FILE TITLE -> DISC NO.
 & DRDELT ;11 => Remove a directory
 & DRPRES ;12 => Preserve object without delchk
DRJUMP JMP DRJUMP
DREXIT JMP EXIT

;*********** DRPRES ***********

;DRPRES: PRESERVE THE SIN OF AN OBJECT WITH A GIVEN TITLE

;ENTRY: ARGB = LS
;ARGC = MS(PTR TO USERINFO)
;ARGD = LS
;ARGE = MS(PTR TO FILE TITLE)
;ARGF = LS
;ARGG = B1
;ARGH = B2
;ARGI = MS(LOAD ADDR)
;ARGJ = LS
;ARGK = B1
;ARGL = B2
;ARGM = MS(EXEC ADDR)
;ARGN = TYPE AND ACCESS (TLWR/WR)
;ARGO = LS
;ARGP = MS(DATE CREATED)
;ARGQ = LS(SIN)
;ARGR = CS(SIN)
;ARGS = MS(SIN)
;ARGT = WILD CARD FLAG

;EXIT : ARGA = RC
;ARGB = LS(DISC NO)
;ARGC = MS(DISC NO)
;ARGD = LS(SIN)
;ARGE = CS(SIN)
;ARGF = MS(SIN OF OBJECT TO BE DELETED)
;ARGG = Access byte

;N.B. IF ARGD!ARGE!ARGF = 0 THEN NO DELETE NEEDED


DRPRES LDYIM ARGT ;get wild card flag
 LDAIY ARGPTR
 STA DIRWC ;save flag for decoding routines
 JSR INITDV ;INIT VARIABLES
 BNE DRPRSY

;CHECK FOR OWNER ACCESS

 JSR TSTOWN
 BNE DRPRSY

;RETRIEVE APPROPRIATE DIR

 JSR RETDIR
 BNE DRPRSY

 LDYIM ARGA
 LDAIY ARGPTR ;check entry code
 EORIM 12 ;dont do DELCHK in retain

 JSR RETA12 ;special case
DRPRSY LDYIM ARGA
 STAIY ARGPTR
 PHA
 LDA OBJACC
 LDYIM ARGG
 STAIY ARGPTR
 PLA
 JMP DREXIT



;************ DRRETR ************


;DRRETR: RETRIEVE DETAILS OF A SPECIFIED OBJECT

;ENTRY: ARGB = LS(PTR TO USERINFO)
;ARGC = MS(PTR TO USERINFO)
;ARGD = LS(PTR TO FILE TITLE)
;ARGE = MS(PTR TO FILE TITLE)
;ARGF = LS(ADDRESS OF STORE AREA TO CONTAIN DETAILS)
;ARGG = MS(PTR TO STORE AREA)

;EXIT: ARGA = RC
;ARGB = TYPE OF OBJECT & MAX ACCESS ALLOWED TO IT
;       Also contains "lock" bit and OWNER/PUBLIC bit

;DETAILS INCLUDE:-
;FILE TITLE (10 BYTES)
;LOAD ADDR (4BYTES),
;EXEC ADDR (4BYTES),
;ACC INFO (1 BYTE),
;CREATION DATE (2 BYTE),
;SIN (3BYTES),
;DISC NO (2BYTES),
;SIZE (3BYTES).


DRRETR LDYIM ARGH
 LDAIY ARGPTR
 STA DIRWC ;get wild card flag
 JSR INITDV
 BNE DRRELB

;MAKE INFPTR POINT TO DETAILS AREA

 LDYIM ARGF
 LDAIY ARGPTR
 STA INFPTR
 INY
 LDAIY ARGPTR
 STA INFPTR + 1

;RETRIEVE RELEVENT DIR

 JSR TSTROT ;TEST FOR <root><terminator>
 BNE DRRERD

;SUPPLY DETAILS OF ROOT DIR

 LDYIM INFLOA
 LDXIM  8
 LDAIM  0
DRRERB STAIY INFPTR ;LOAD ADDRESS:=EXEC ADDR:=0
 INY
 DEX
 BNE DRRERB

 LDA DIRACC
 LDYIM ARGB
 STAIY ARGPTR ;ACCESS TO ROOT DIR
 LDYIM INFDTE
 LDA TDATE ;(DATE OF CREATION ROOT)
 STAIY INFPTR
 LDA TDATE + 1
 STAIY INFPTR
 LDYIM INFACC
 LDAIM TYPDIR
 STAIY INFPTR
 LDA DIRSIN
 STA OBJSIN
 LDYIM INFSIN
 STAIY INFPTR
 LDA DIRSIN + 1
 STA OBJSIN + 1
 INY
 STAIY INFPTR
 LDA DIRSIN + 2
 STA OBJSIN + 2
 INY
 STAIY INFPTR
 JSR RETDSZ ;PLACE DISC NO & SIZE IN INFPTR
 JMP DRRERX

DRRERD LDYIM ARGH ;get flag
 LDAIY ARGPTR
 RORA
 BCC DRRELA
 JSR RETEND ;get directory
 JMP DRRELB
DRRELA JSR RETENT
DRRELB BNE DRRERY

;COPY DETAILS INTO STORE AREA POINTED TO BY INFPTR

 JSR DETALS
 PHA ;Push return code

;NOW CALCULATE CALLER'S ACCESS TO THE OBJECT

 JSR MAXACC

 LDYIM ARGB
 STAIY ARGPTR ;TYPE & MAX ACCESS ALLOWED TO OBJECT
 JSR UNLOCK ;STRMAN.UNLOCK (DIR)
 PLA ;Pull DETALS return code
 BNE DRRERY ;Error

DRRERX LDAIM  0 ;RC:=0
DRRERY LDYIM ARGA
 STAIY ARGPTR
 JMP DREXIT




;************ DRDELT ************


;DRDELT: DELETE

;ENTRY: ARGB = LS(PTR TO USERINFO)
;ARGC = MS(PTR TO USERINFO)
;ARGD = LS(PTR TO FILE TITLE)
;ARGE = MS(PTR TO FILE TITLE)

;EXIT : ARGA = RC
;ARGB = LS(DISC NO)
;ARGC = MS(DISC NO)
;ARGD = LS(SIN)
;ARGE = CS(SIN)
;ARGF = MS(SIN OF OBJECT TO BE DELETED)


DRDELT LDYIM ARGG
 LDAIY ARGPTR
 STA DIRWC ;get wild card flag
 JSR INITDV ;INIT VARIABLES
 BNE DRDLTY

;CHECK FOR OWNER ACCESS

 JSR TSTOWN
 BNE DRDLTY

;RETRIEVE APPROPRIATE DIR ENTRY

 JSR RETENT ;RETRIEVE REQ'D ENTRY
 BNE DRDLTY

;FIRST CHECK THAT ENTRY MAY BE DELETED

 LDYIM ARGA ;check entry code
 LDAIY ARGPTR ;** 24/9/84 **
 CMPIM 11
 BEQ DRDLTC ;skip delete check if 'remove' called

 JSR DELCHK
 BEQ DRDLTC
 JSR UNLOCK
 BNE DRDLTY

;NOW REMEMBER DISC NO & SIN OF OBJECT TO BE DELETED

DRDLTC JSR CRNSIN ;OBJSIN := SIN OF CRNTEN
 JSR ARGDSN ;PLACE DISC NO & SIN ON ARGPTR STACK

;NOW UNCHAIN CURRENT DIR ENTRY & PLACE
;IT ON THE FREE CHAIN

 LDYIM DRLINK
 LDAIY CRNTEN
 STAIY PREVEN
 INY
 LDAIY CRNTEN
 STAIY PREVEN ;[PREVEN] := [CRNTEN]

 JSR FREECH ;PLACE CRNTEN ENTRY ON FREE CHAIN

;NOW DECREMENT COUNT OF NUMBER OF DIR ENTRIES

 JSR SETGEN ;GENPTR := [DIRSTA]
 SEC
 LDYIM DRENTS
 LDAIY GENPTR
 SBCIM  1
 STAIY GENPTR
 INY
 LDAIY GENPTR
 SBCIM  0
 STAIY GENPTR ;[DIRSTA + DRENTS] -:= 1

;ENSURE UPTO DATE ON DISC

 JSR ENSRIT

DRDLTY LDYIM ARGA
 STAIY ARGPTR
 JMP DREXIT


;************ DRSACC ************


;DRSACC: SET ATTRIBUTES

;ENTRY: ARGB = LS(PTR TO USERINFO)
;ARGC = MS(PTR TO USERINFO)
;ARGD = LS(PTR TO FILE TITLE)
;ARGE = MS(PTR TO FILE TITLE)

;ARGG = FN
;     FN = 1 => SET LOAD/EXEC & ACCESS
;     FN = 2 => SET LOAD ADDR
;     FN = 3 => SET EXEC ADDR
;     FN = 4 => SET ACCESS BYTE
;     FN = 5 => SET DATE
;ARGH +n (depending on ARGF) = ATTRIBUTES TO SET

;EXIT : ARGA = RC


;FORMAT OF ACCESS BYTE:-

;BIT0->PUBLIC HAS READ ACCESS
;BIT1->PUBLIC HAS WRITE ACCESS
;BIT2->OWNER HAS READ ACCESS
;BIT3->OWNER HAS WRITE ACCESS
;BIT4->ENTRY IS LOCKED


DRSACC LDAIM  0
 STA DMTEMP + 2 ;save space for Access arg
 LDYIM ARGF
 LDAIY ARGPTR
 STA DIRWC ;get wild card flag
 JSR INITDV ;INITIALISE VARIABLES
 BNE DRSAC5

 LDYIM ARGG ;CHECK IF JUST DATE UPDATE
 LDAIY ARGPTR
 CMPIM 5
 BEQ DRSACA ;NO NEED FOR OWNER ACCESS

;CHECK FOR OWNER ACCESS

 JSR TSTOWN
 BNE DRSAC5

;RETRIEVE APPROPRIATE DIR ENTRY

DRSACA JSR RETENT
 BNE DRSAC5

DRSACL LDYIM ARGG
 LDAIY ARGPTR
 STA DMTEMP + 1 ;Store for later
 LDYIM ARGH ;Position of access if A=4
 CMPIM 4 ;If SETACCESS, must mask off access bits
 BEQ DRSAC4 ;Is SETACCESS -> check access byte
 CMPIM 5 ;** 31/1/85 **
 BEQ DRSAC2
 CMPIM 1
 BNE DRSAC1 ;Is "all attribs" so check access
 LDYIM ARGP ;Position of access if A = 1

DRSAC4 STY DMTEMP ;Store offset of access
 LDAIY ARGPTR ;Read access byte
 ANDIM ACCMSK ;Mask off access bits
 ORA DMTEMP + 2
 STA DMTEMP + 2
 STAIY ARGPTR
 TAX  ;Store for later

;** 15/11/84 ** w/ access illegal
 ANDIM &0C ;owner bits set
 BEQ DRSAC8
 ANDIM &04 ;at least r bit set
 BNE DRSAC8
 LDAIM SAERRA ;'bad attribute' error
DRSAC9 BNE DRSAC3

DRSAC8 LDYIM DRACCS
 LDAIY CRNTEN
 ANDIM TYPDIR
 BEQ DRSAC2 ;Is not a directory, so continue
 TXA
 ANDIM ACCMSK-RWMSK ;just the lock bit
 ORAIM TYPDIR ;Or in directory info. if a dir. 
 LDY DMTEMP
 STAIY ARGPTR ;Stuff access argument
 LDA DMTEMP + 1 ;Load function no.
 CMPIM  1
 BNE DRSAC2 ;Check not setting load/exec. of a dir.

DRSAC1 LDYIM DRACCS
 LDAIY CRNTEN ;Check if is directory
 ANDIM TYPDIR
 BEQ DRSAC2 ;Cannot set load/exec address of dir., so error
 LDAIM DRERRF ;Bad arg.

DRSAC3 JSR UNLOCK ;Otherwise, error
DRSAC5 JMP DRSACY ;Error exit

DRSAC2 LDYIM ARGG ;Here, all checks made, so set attribs
 LDAIY ARGPTR 
 TAY
 LDAIM ARGH ;Set args for block move from stack
 STA OFF1 ;to some offset in CRNTEN
 LDAAY DRSAT1 - 1 ;Get offset in dir. entry
 STA OFF2 ;"Move to" offset
 LDAAY DRSAT2 - 1 ;Length to move
 LDXIM ARGPTR ;"Move from" ptr.
 LDYIM CRNTEN ;"Move to" ptr.
 JSR MOVBLK ;Move args to stack

 LDYIM ARGG
 LDAIY ARGPTR
 CMPIM 5 ;DON'T SET ALL DATES
 BEQ DRDSET

 JSR FNDTEZ ;try for any more entries
 BNE DRDSET
 JMP DRSACL

DRDSET JSR ENSRIT ;Ensure directory and exit

DRSACY LDYIM ARGA
 STAIY ARGPTR
 JMP DREXIT

DRSAT1 = DRLOAD ;Offsets in directory entry
 = DRLOAD
 = DREXEC
 = DRACCS
 = DRDATE

DRSAT2 =  9 ;Length of data
 =  4
 =  4
 =  1
 =  2


;************ DRCRDR ************


;DRCRDR: CREATE & PRESERVE A NEW DIRECTORY

;ENTRY: ARGB = LS(PTR TO USERINFO)
;ARGC = MS(PTR TO USERINFO)
;ARGD = LS(PTR TO FILE TITLE)
;ARGE = MS(PTR TO FILE TITLE)
;ARGF = Size of directory ** 15/9/83 **

;EXIT : ARGA = RC
;ARGB = LS(DISC NO)
;ARGC = MS(DISC NO)
;ARGD = LS(SIN)
;ARGE = CS(SIN)
;ARGF = MS(SIN OF OBJECT TO BE DELETED)

DRCRDR LDYIM ARGG
 LDAIY ARGPTR
 STA DIRWC ;get wild card flag
 JSR INITDV
 BEQ DRCRRA
 JMP DRCRRY

;CHECK FOR OWNER ACCESS

DRCRRA JSR TSTOWN
 BEQ DRCRRB
 JMP DRCRRY

;CREATE A VIRGIN DIRECTORY

DRCRRB LDYIM ARGF
 LDAIY ARGPTR
 STA DIRTMP + 1 ;DIRTMP := SIZE OF DIRECTORY REQD.
 LDAIM  0
 STA DIRTMP
 STA DIRTMP + 2
 JSR MAKDIR ;SETUP ARGPTR ARGUMENTS FOR DIRMAN.PRESERVE
 BNE DRCRRY

;NOW UNLOCK THE CREATED DIR - THE RETAIN RTN
;ENSURES THAT ITS UPTO DATE ON DISC

 JSR UNLOCK

;NOW HAVE IT RETAINED

 JSR INITDV ;REINITIALISE VARIABLES
 BEQ DRCRRJ

DRCRRI  ;OBJSIN:=SIN OF NEW DIR(RETAIN DESTROYS OBJSIN)
 JSR DELOBJ ;**** 17/3/83 ****
 JMP DRCRRY

;LOAD APPROPRATE DIR

DRCRRJ JSR RETDIR
 BNE DRCRRI

;NOW HAVE IT RETAINED IN THIS DIR

 JSR RETAIN
 BNE DRCRRI
DRCRRY LDYIM ARGA
 STAIY ARGPTR
 JMP DREXIT


;************ DRCHSZ ************


;DRCHSZ: CHANGE SIZE OF A FILE

;ENTRY: ARGB = LS
;ARGC = MS(PTR TO USERINFO)
;ARGD = LS
;ARGE = MS(PTR TO FILE TITLE)
;ARGF = LS
;ARGG = CS
;ARGH = MS(NEW SIZE)

;EXIT : ARGA = RC

;FUNCTION:-
;REMOVE ALL OF THE OBJECT FROM THE CACHE;
;IF TYPE OF OBJECT = FILE
;THEN CHECK FOR WRITE ACCESS;
;CHECK THAT FILE IS NOT OPEN;
;CHANGE SIZE;
;ENSURE OBJECT MAP UPTO DATE ON DISC
;ELIF TYPE OF OBJECT = DIR
;THEN RC:=WRONG TYPE #AUTOMATICALLY DONE IN RETAIN#
;FI


DRCHSZ LDYIM ARGI
 LDAIY ARGPTR
 STA DIRWC ;get wild card flag
 JSR INITDV
 BNE DRCHZY

;RETRIEVE DIR ENTRY

 JSR RETENT
 BNE DRCHZY

 JSR CRNSIN ;OBJSIN := SIN OF CURRENT DIR ENTRY
 JSR MAXACC ;OBJACC := TYPE & ACCESS HELD FOR OBJECT
 JSR UNLOCK ;UNLOCK DIR
 JSR REMOVE ;REMOVE OBJSIN FROM THE CACHE
 BNE DRCHZY ;error trap **** 17/3/83 ****
 LDA OBJACC
 ANDIM TYPE
 CMPIM TYPDIR
 BNE DRCHZL
 LDAIM DRERRF ;WRONG TYPE
 BNE DRCHZY

;DEAL WITH A FILE

DRCHZL LDA OBJACC
 ANDIM WRITAC
 BNE DRCHZG
 LDAIM DRERRL ;NO WRITE ACCESS !
 JMP DRCHZY

;CHECK THAT THE FILE IS NOT OPEN

DRCHZG LDYIM ARGA
 LDAIM  2 ;RNDMAN.INFO
 STAIY NEWARG
 JSR SETDSN ;PLACE OBJECT DISC NO & SIN ONTO NEWARG STACK
 JSR RNDMAN
 BNE DRCHZI
 LDAIM DRERRI
 JMP DRCHZY

;NOW CALL MAPMAN TO HAVE THE SIZE CHANGED

DRCHZI LDYIM ARGA
 LDAIM  3
 STAIY NEWARG
 JSR SETDSN
 LDYIM ARGF
 LDAIY ARGPTR
 LDYIM ARGB
 STAIY NEWARG ;LS(NEW SIZE)
 LDYIM ARGG
 LDAIY ARGPTR
 LDYIM ARGC
 STAIY NEWARG ;CS(NEW SIZE)
 LDYIM ARGH
 LDAIY ARGPTR
 LDYIM ARGD
 STAIY NEWARG ;MS(NEW SIZE)

 JSR JUSINF ;** 3/10/84 pass userinfo ptr

 JSR MAPMAN
 BNE DRCHZY
 JSR ENSOMP ;ENSURE OBJECT MAP

DRCHZY LDYIM ARGA
 STAIY ARGPTR
 JMP DREXIT



;******** EXAMINE ROUTINE ********

;DREXAM : GIVE DETAILS OF ENTRY(S) IN A DIR.
;ENTRY: ARGB = LS
;ARGC = MS(PTR TO USER INFO)
;ARGD = LS
;ARGE = MS(PTR TO FILE TITLE)
;ARGF = LS
;ARGG = MS(ADDRESS OF STORE FOR RESULT)
;ARGH = TYPE OF RESULT REQURIED
;0 => ALL INFO, M/C READABLE
;1 => ALL INFO, CHAR STRING
;2 => FILE TITLE + FILE NAME LENGTH, M/C
;3 => ACCESS+FILE TITLE, CHAR STRING
;4 => GIVE LAST COMPONENT F.T. ONLY
;ARGI = ENTRY POINT TO DIR.
;ARGJ = NO. OF ENTRIES (0=> ALL DIR.)

;EXIT : ARGB = LS
;ARGC = MS(PTR TO BYTE AFTER RESULT END)
;ARGD = NO. OF ENTRIES
;ARGE = SEQ. NO. OF DIRECTORY BEING EXAMINED

;WHEN ARGH IS 4, ARGD IS MAX. ACCESS TO DIR,
;ARGE IS SEQUENCE NUMBER OF DIR., AND
;ARGF/G ARE DISC. NO LO/HI


DREXAM LDYIM ARGK
 LDAIY ARGPTR
 STA DIRWC ;get wild card flag
 RORA ;look at bit0
 BCC DREXCA
 LDAIM &80
 BMI DREXCB
DREXCA LDAIM  0
DREXCB STA DIRFLG
 JSR INITDV
 BEQ DEXONA
 JMP DEXRTS

DEXONA LDYIM ARGF ;STORE RESULT PTR.
 LDAIY ARGPTR
 STA INFPTR
 INY
 LDAIY ARGPTR
 STA INFPTR + 1

 INY
 LDAIY ARGPTR
 CMPIM  5
 BCC DEXONQ ;IF <5, OK

 LDAIM DRERRO ;BAD ARG. TO EXAMINE
 JMP DEXRTS

DEXONQ STA EXARG ;TYPE OF RESULT
 INY
 LDAIY ARGPTR
 STA EXENTR ;ENTRY TO DIR.
 INY
 LDAIY ARGPTR

 JSR CHKENS
 BCC DEXONY ;OK

 LDAIM DRERRN ;TOO MANY ENTRIES REQUESTED
 JMP DEXRTS


DEXONY STA EXENTS ;NO. OF ENTRIES

 JSR GETDRD ;LOAD APPROPRIATE DIR
 BEQ DEXONW
 JMP DEXRTS

DEXONW LDAIM  4
 CMP EXARG
 BNE DEXOND

;IF HERE, COPY FILE NAME FROM DIRECTORY
;INTO RESULT AREA.

 LDYIM DRNAME ;OFFSET IN DIR.
 LDXIM  0
DEXLPZ LDAIY DPTRLD
 STAIX INFPTR
 INY
 JSR INCIPT
 CPYIM DRFREE
 BNE DEXLPZ

 LDYIM DRSQNO
 LDAIY DPTRLD ;Read dir. sequence number
 PHA ;Store for later use

 LDA DIRACC
 LDYIM ARGD
 STAIY ARGPTR
 PLA ;Pull sequence number
 INY
 STAIY ARGPTR
 LDA DRDISC
 INY
 STAIY ARGPTR
 INY
 LDA DRDISC + 1
 STAIY ARGPTR
 JMP DEXONI

DEXOND JSR INTPRE ;PREVEN := DIRSTA

DEXLPA

;FOR I=0 TO EXENTR DO
;$( SET CURRENT := NEXT(PREV. ENTRY)
;IF END OF DIR...EXIT WITH RC SET
;PREVENTRY := CURRENT ENTRY
;$)

 JSR SETCRN
 BEQ DEXONH ;Zero => end of dir => exit

 LDA EXENTR
 DEC EXENTR
 TAX
 BEQ DEXONE ;LOOP FINISHED

 JSR MOVCRN ;PREVEN := CRNTEN
 JMP DEXLPA

DEXONE   ;DEXONE

;SET ROUTINE TO BE USED, DEPENDING
;ON EXARG.
;EXRTN := JMP <examine routine>

 LDA EXARG
 ASLA
 TAX
 LDAAX DEXTAB
 STA EXRTN + 1
 LDAAX DEXTAB + 1
 STA EXRTN + 2
 LDAIM JMPINS
 STA EXRTN

 LDAIM  0 ;NO. OF ENTRIES

DEXLPB

;LOOP ROUND EXAMINE ROUTINE, DECREMENTING
;EXENTS, AND CHAINING THROUGH DIR.

 PHA  ;STORE NO. OF ENTRIES
 JSR EXRTN
 BEQ DEXONJ
 TAX
 PLA ;Restore stack
 TXA
 PHA
 JSR UNLOCK
 PLA
 BNE DEXRTS ;Error -> exit [always jump]

DEXONJ PLA
 CLC
 ADCIM  1 ;ADD NO. OF ENTS.
 PHA

 LDA CRNTEN
 STA PREVEN
 LDA CRNTEN + 1
 STA PREVEN + 1
 JSR SETCRN ;CURRENT := NEXT(PREV)
 BNE DEXONF ;OK, CONTINUE
 BEQ DEXONG ;NOT OK, FINISH LOOP

DEXONF PLA
 CMP EXENTS
 BNE DEXLPB

;FINALLY, SET END OF BLOCK INDICATOR.
DEXONH PHA

DEXONG LDAIM EXTERM
 LDYIM  0
 STAIY INFPTR

 JSR INCIPT ;INCREMENT POINTER TO END OF BLOCK (USED IN TXCB).

 LDYIM ARGB
 LDA INFPTR
 STAIY ARGPTR
 INY
 LDA INFPTR + 1
 STAIY ARGPTR
 INY
 PLA  ;GET NO. OF ENTRIES
 STAIY ARGPTR

 LDYIM DRSQNO
 LDAIY DPTRLD ;Get sequence no. of examined dir.
 LDYIM ARGE
 STAIY ARGPTR ;And return it

DEXONI JSR UNLOCK

 LDAIM  0 ;OK EXIT
DEXRTS LDYIM ARGA
 STAIY ARGPTR
 JMP DREXIT


DEXTAB   ;DEXTAB

;TABLE OF EXAMINE ROUTINE ENTRY POINTS

 & EXRTNA
 & EXRTNB
 & EXRTNC
 & EXRTND



;******** DRINFO ********

;DRINFO: RETRIEVE DETAILS OF A GIVEN OBJECT IN
;FORMATTED FORM.

;ENTRY: ARGB = LS (PTR TO USER INFO)
;ARGC = MS (PTR TO USER INFO)
;ARGD = LS(PTR TO FILE TITLE)
;ARGE = MS(PTR TO FILE TITLE)
;ARGF = LS(ADDRESS OF RESULT AREA)
;ARGG = MS(ADDRESS OF RESULT AREA)

;EXIT:  ARGB = LS(ADDRESS OF BYTE AFTER RESULT AREA)
;ARGG = MS(ADDRESS OF BYTE AFTER RESULT AREA)

;BYTE AFTER RESULT AREA IS USED TO
;SET UP BUFFER POINTERS IN TXCB AFTER
;DETAILS CALL.



DRINFO LDYIM ARGH
 LDAIY ARGPTR
 STA DIRWC ;get wild card flag
 JSR INITDV
 BEQ DINONZ

 JMP DRINFE ;EXIT IF ERROR

DINONZ LDYIM ARGF
 LDAIY ARGPTR ;Set pointer to result area
 STA INFPTR
 INY
 LDAIY ARGPTR
 STA INFPTR + 1

 JSR TSTROT ;IS ROOT ??
 BEQ DINONC
 JMP DINONA

;IF HERE, SUPPLY DETAILS OF ROOT.

DINONC LDA DIRSIN
 STA OBJSIN ;SET SIN FOR SIZE ROUTINE
 LDA DIRSIN + 1
 STA OBJSIN + 1
 LDA DIRSIN + 2
 STA OBJSIN + 2


 LDAIM ROOT
 JSR OUTCH ;Ouput dir. name
 LDXIM &0A
 JSR OUTSPS ;Pad dir. name

 JSR OUTZRO ;Output 8 zeros
 JSR OUTSP
 JSR OUTZRO ;8 more zeros (exec address)
 LDXIM  3
 JSR OUTSPS
 JSR OUTSZA
 BNE DRINFE
 LDAIM TYPDIR ;TYPE = DIRECTORY
 ORAIM LOCKED
 ASLA
 JSR OUTACA ;Output access

 LDXIM  4
 JSR OUTSPS

 LDXIM  2
 JSR OUTRTD
 LDA OBJSIN + 2
 JSR OUTBYT
 LDA OBJSIN + 1
 JSR OUTBYT
 LDA OBJSIN 
 JSR OUTBYT
 JMP DINFIN ;FINISHED .....


DINONA   ;DINONA

;HERE DOING NON-ROOT OBJECT

 JSR RETENT ;RETRIEVE BOTTOM ENTRY
 BNE DRINFE

 JSR OUTENT ;Put out entry details
 JSR UNLOCK ;UNLOCK CURRENT DIR. (note does PHA/PLA)
 BNE DRINFE ;Unsuccessful MAPMAN call

DINFIN

;END OF ENTRY. PUT CR AT END TO FORCE
;A NEW LINE IF OSASCII'ING AT THE
;CLIENT END, AND EXTERM CHAR. TO
;INDICATE END OF DATA.

 LDAIM CR
 JSR OUTCH
 LDAIM EXTERM
 JSR OUTCH

 LDYIM ARGB ;PUT INFPTR ON STACK AS RESULT
 LDA INFPTR
 STAIY ARGPTR
 INY
 LDA INFPTR + 1
 STAIY ARGPTR

 LDAIM  0

DRINFE LDYIM ARGA
 STAIY ARGPTR
 JMP DREXIT



 [ 1=0
;************ DRMAKE ************


;DRMAKE: MAKE THE ROOT DIRECTORY-BUT DON'T RETAIN IT.
;USED IN DISC INITIALISATION.

;ENTRY: ARGB-ARGD = APPROX SIZE OF DIR(IN BYTES)
;N.B. DRDISC MUST = DISC NUMBER

;EXIT : ARGA = RC
;ARGF-ARGS SAME AS DIRMAN.PRESERVE'S ENTRY ARGS

DRMAKE LDAIM  0
 STA DIRWC ;get wild card flag
 LDYIM ARGB
 LDAIY ARGPTR
 STA DIRTMP
 INY
 LDAIY ARGPTR
 STA DIRTMP + 1
 INY
 LDAIY ARGPTR
 STA DIRTMP + 2
 JSR MAKDIR

;MOVE "$" INTO THE HEADER

 BNE DRMAKY
 LDXIM NAMLNT
 LDYIM DRNAME
 LDAIM ROOT
DRMAKD STAIY DPTRLD
 LDAIM SPACE
 INY
 DEX
 BNE DRMAKD

;NOW ENSURE THE DIR UPTO DATE ON DISC AND ENSURE
;THE DISC MAP

 JSR ENSRIT ;ENSURE & UNLOCK IT
 BEQ DRMAKH

DRMAKF JSR DELOBJ ;DELETE IT
 JMP DRMAKY

DRMAKH JSR ENSOMP ;OBJSIN MUST = SIN OF DIR
 BNE DRMAKF
DRMAKY LDYIM ARGA
 STAIY ARGPTR
 JMP DREXIT
 |
DRMAKE LDAIM -1
 JMP DREXIT ;** 3/10/84 **
 ]

;************* DRFTDN ****************

;GIVEN FILE TITLE, ANALYSE TO GET DISC NUMBER
;AND RETURN. USED BY SAVE IN C.PROC TO
;RESOLVE ON WHAT DISC TO SAVE A FILE

;ENTRY: ARGB - PTR TO USER INFO
;ARGC -  "   "  "     " (HI)
;ARGD - (LO) PTR TO FILE TITLE
;ARGE - (HI)  "      "      "

;EXIT: ARGB/C = DISC NUMBER

DRFTDN LDYIM ARGF
 LDAIY ARGPTR
 STA DIRWC ;get wild card flag
 JSR INITDV
 BNE DRFTEX
 LDYIM ARGB
 LDA DRDISC
 STAIY ARGPTR
 INY
 LDA DRDISC + 1
 STAIY ARGPTR
 LDAIM  0 ;=> success
DRFTEX LDYIM ARGA
 STAIY ARGPTR
 JMP DREXIT
 LNK UADE0D
