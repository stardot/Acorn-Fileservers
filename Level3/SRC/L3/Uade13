 OPT UADE13 ;> Uade13
 TTL File server file UADE13

;FNDMAP:
;SEARCHES MAPTB LOOKING FOR DISC NUMBER
;WHICH IS IN ARGB AND ARGC. WHEN
;FOUND LEAVES A POINTER TO THE CORRECT ENTRY IN MAPPTR & MAPENT.
;NOTE THAT MAPENT IS USED BY DSCMAN & SHOULD
;NOT BE ALTERED BY MAPMAN.

FNDMAP LDAIM 0
 STA MPDRVE
 STA DRIVNO
 LDA MAPTB ;START OF MAP TABLE
 STA MAPPTR ;LOOK AT FIRST ENTRY
 LDA MAPTB+1
 STA MAPPTR+1
 LDXIM 0 ;X HOLDS DRIVE NUMBER
MPNXDR LDYIM MPDCNO ;OFFSET TO DISC NUMBER
 LDAIY MAPPTR
 LDYIM ARGB
 CMPIY ARGPTR ;SEE IF ITS CORRECT DISC NUMBER
 BNE MPTONX
 LDYIM MPDCNO+1
 LDAIY MAPPTR
 LDYIM ARGC
 CMPIY ARGPTR
 BEQ MPFND ;BRANCH IF DISC NUMBER MATCHES
MPTONX CLC
 LDYIM MPADFT
 LDA MPDRVE
 ADCIY MAPPTR
 STA MPDRVE
 JSR MPADMP ;GET NEXT ENTRY
 INC DRIVNO
 LDA DRIVNO
 CMP DRIVES ;CHECK FOR END
 BNE MPNXDR ;BRANCH IF NOT AT END
;IF WE REACH HERE THE DISC WAS NOT FOUND
 LDAIM MPERRA
 JMP MPFNND
MPFND LDA MAPPTR
 STA MAPENT
 LDA MAPPTR+1
 STA MAPENT+1 ;MAPENT := PTR TO MAPTB ENTRY
 LDAIM 0 ;SUCESSFUL SO ZERO RC
MPFNND RTS

;CHECK MAP SIZE
;
;CHECKS THAT NEW CYLINDER MAP SIZE IS NOT GREATER THAN OLD
;
;SECTOR TWO INFO POINTED TO BY MPSCPT,
;MAP TABLE ENTRY BY MAPPTR
;
CHMPSZ LDYIM MPNOCY+1
 LDAAY MAPTBF
 PHA
 DEY
 LDAAY MAPTBF
 PHA ;GET OLD NUMBER OF CYLINDERS
 LDYIM MPNOCY ;SECTOR TWO NO. CYLINDERS
 PLA
 CMPIY MAPPTR
 PLA
 INY
 SBCIY MAPPTR
 BCS CHMPOK ;OLD MAP >= NEW MAP

 LDAIM MPERRI
 RTS
CHMPOK LDAIM 0
 RTS


;
;
;FIND SIZE OF NEW MAP AND SAVE IT
;
;
MPMPSZ LDYIM MPSECS ;NO. OF SECTORS ON DISC
 LDAIY MAPPTR
 STA MPTMPC ;SAVE IT
 INY
 LDAIY MAPPTR
 STA MPTMPC+1
 INY
 LDAIY MAPPTR
 STA MPTMPC+2
 LDAIM 0
 STA MPTMPA
 STA MPTMPA+1
 STA MPTMPA+2
 LDYIM MPDSCS
 LDAIY MAPPTR
 TAX
MPRECN CLC
 LDA MPTMPA
 ADC MPTMPC
 STA MPTMPA
 LDA MPTMPA+1
 ADC MPTMPC+1
 STA MPTMPA+1
 LDA MPTMPA+2
 ADC MPTMPC+2
 STA MPTMPA+2
 DEX
 BNE MPRECN
 LDYIM MPSCTT
 LDA MPTMPA
 STAIY MAPPTR
 INY
 LDA MPTMPA+1
 STAIY MAPPTR
 INY
 LDA MPTMPA+2
 STAIY MAPPTR
 RTS
;
;DELETE THE RELEVANT OBJECT
;
MPDLTE LDYIM ARGD ;GET SIN
 LDAIY ARGPTR
 STA MPTMPA
 INY
 LDAIY ARGPTR
 STA MPTMPA+1
 INY
 LDAIY ARGPTR
 STA MPTMPA+2
 LDAIM 1 ;FLAG CURRENT MAP BLOCK TO BE DELETED
 STA MPTMPE
 LDAIM MBENTS ;GET OFFSET TO START
 STA MPSCPT
 LDAIM /(MBENTS )
 STA MPSCPT+1
 LDAIM 1
 STA SAVSC ;STOP EXTRA WORK
 JMP CLRBLK ;REMOVE ALL ENTRIES
;
;INCREMENT MAPPTR TO NEXT MAPTB ENTRY
;

MPADMP CLC
 LDAIM MPTBSZ
 ADC MAPPTR
 STA MAPPTR
 LDAIM 0
 ADC MAPPTR+1
 STA MAPPTR+1
 RTS

DIVIDE JSR DVDE ;CONVERT TO OLD DIVIDE
 SEC
 LDA DIVTMP
 SBCIM 1
 STA DIVPAR
 LDA DIVTMP+1
 SBCIM 0
 STA DIVPAR+1
 LDA DIVTMP+2
 SBCIM 0
 STA DIVPAR+2
 RTS

INAMPT

;ADD NAME TABLE ENTRY LENGTH TO
;DNMPTR.

 CLC
 LDAIM NTENSZ
 ADC DNMPTR
 STA DNMPTR
 LDAIM 0
 ADC DNMPTR+1
 STA DNMPTR+1
 RTS


;DIVIDE SECTORS
;
;  CALCULATES A CYLINDER NUMBER FROM A SIN
;
;ON ENTRY
;      MPTMPA HOLDS THE SIN
;
;ON EXIT
;      MPTMPB HOLDS THE CYLINDER
;
;USES MPTMPA
;
DIVSEC LDAIM 0
 STA MPTMPB
 STA MPTMPB+1 ;CLEAR VARIABLE
DIVNXS LDYIM MPSPCY
 SEC
 LDA MPTMPA
 SBCIY MAPPTR ;DIVIDE BY SECTORS PER CYLINDER
 STA MPTMPA
 INY
 LDA MPTMPA+1
 SBCIY MAPPTR
 STA MPTMPA+1
 LDA MPTMPA+2
 SBCIM 0
 STA MPTMPA+2
 BCC DIVND
 INC MPTMPB
 BNE DIVNXS
 INC MPTMPB+1
 JMP DIVNXS
DIVND RTS


SDSCNM   ;SDSCNM

;TAKE TEXT DISC NAME FROM DNMBUF
;AND PUT IN NAME TABLE ENTRY AT
;DNMPTR. ALSO PUT IN NEW DISC NUMBER
;FROM NXTDNO, AND MARK ENTRY IN USE.
;DISC NO. ALSO PLACED IN MAP TABLE ENTRY
;POINTED TO BY MAPPTR.

;ALSO INCREMENT NXTDNO !!

 LDYIM NTNAME
 LDXIM 0

SDSCLP LDAAX DNMBUF
 STAIY DNMPTR
 INY
 INX
 CPXIM DNAMLN
 BNE SDSCLP

 LDYIM NTDNO
 LDA NXTDNO
 PHA
 STAIY DNMPTR ;SET DISC NO. LO
 INY
 LDA NXTDNO+1
 STAIY DNMPTR

 LDYIM MPDCNO+1
 STAIY MAPPTR ;DISC NO. IN MAP TABLE
 DEY
 PLA
 STAIY MAPPTR

 LDYIM NTUSED
 LDAIM USED
 STAIY DNMPTR

 INC NXTDNO
 BNE SDSCOK
 INC NXTDNO+1

SDSCOK LDAIM 0
 RTS

;
;SET UP CYLINDER MAP FOR CURRENT DISC
;
MPSTCY LDAIM 1
 STA RSTFLG
 LDYIM MPCYMP
 CLC
 LDAIY MAPPTR
 ADCIM 3 ;TO POINT AT ACTUAL ENTRIES
 STA MPCYPT
 INY
 LDAIY MAPPTR
 ADCIM 0
 STA MPCYPT+1
 LDAIM 0 ;ZERO A FEW VALUES
 STA DDRSZE+2
 STA MPTMPC
 STA MPTMPC+1
 STA MPTMPA+2 ;** 21/11/84 **
MPSCSL LDYIM MPSCYL
 LDA MPTMPC
 CMPIY MAPPTR
 INY
 LDA MPTMPC+1
 SBCIY MAPPTR
 BCS MPSCSF
 LDAIM 0
 TAY
 STAIY MPCYPT
 INY
 STAIY MPCYPT
 CLC
 LDA MPCYPT
 ADCIM 2
 STA MPCYPT
 LDA MPCYPT+1
 ADCIM 0
 STA MPCYPT+1
 INC MPTMPC
 BNE MPSCSL
 INC MPTMPC+1
 JMP MPSCSL
MPSCSF STA MPTMPB
 STA MPTMPB+1
 STA MPTMPB+2
CYMPLP LDAIM 0 ;LOOP TO READ IN BIT MAPS
 STA MPTMPA
 STA MPTMPA+1

 LDA MPTMPA+2 ;check not skipping
 BEQ CYMPL1
 DEC MPTMPA+2 ;counter for maps to skip
 JMP CYMPL2

CYMPL1 JSR RDBTMP

 LDYIM MPVAL ;check that subsequent maps are valid
 LDAIY MPSCPT ;** 21/11/84 **
 STA MPTMPA+2 ;save this flag [n<>0 => skip n maps]

 LDYIM MPSPCY
 LDAIY MAPPTR
 STA MAPTMP
 INY
 LDAIY MAPPTR
 STA MAPTMP+1 ;SECTORS PER CYCLINDER
CRCLP1 LDXIM 8 ;EIGHT BITS PER BYTE
 LDYIM 0
 LDAIY MPSCPT
CRCYLP RORA ;CHECK IF SECTOR FREE
 BCC CRCYSK ;CLEAR IF ALLOCATED
 INC MPTMPA ;COUNT OF FREE SECTORS
 BNE CRCYSK
 INC MPTMPA+1
CRCYSK PHA
 SEC
 LDA MAPTMP
 SBCIM 1 ;TO CHECK FOR END OF MAP
 STA MAPTMP
 LDA MAPTMP+1
 SBCIM 0
 STA MAPTMP+1
 ORA MAPTMP
 BEQ CRCFND ;BRANCH IF END OF MAP
 PLA
 DEX ;FOR END OF BYTE
 BNE CRCYLP
 INC MPSCPT ;INCREMENT POINTER TO BIT MAP
 BNE CRCLP1
 INC MPSCPT+1
 JMP CRCLP1 ;TO LOOK AT NEXT BIT
CRCFND PLA ;REMOVE SAVED REG.
CYMPL2 LDA MPTMPA
 STAIY MPCYPT ;SAVE COUNT OF FREE SECTORS
 CLC
 ADC MPTMPB ;SAVE TOTAL
 STA MPTMPB
 INY
 LDA MPTMPA+1
 STAIY MPCYPT
 ADC MPTMPB+1
 STA MPTMPB+1
 LDAIM 0
 ADC MPTMPB+2
 STA MPTMPB+2
 CLC ;MOVE POINTER TO NEXT ENTRY
 LDA MPCYPT
 ADCIM 2
 STA MPCYPT
 LDA MPCYPT+1
 ADCIM 0
 STA MPCYPT+1
 INC MPTMPC
 BNE MPRES9
 INC MPTMPC+1
MPRES9 LDYIM MPNOCY ;CHECK FOR END OF DISC
 LDA MPTMPC
 CMPIY MAPPTR
 INY
 LDA MPTMPC+1
 SBCIY MAPPTR
 BCS MPRES3
 JMP CYMPLP
MPRES3 LDYIM MPCYMP ;END OF MAPS SO SAVE TOTAL COUNT
 LDAIY MAPPTR
 STA MPSCPT
 INY
 LDAIY MAPPTR
 STA MPSCPT+1
 LDYIM 0
 LDA MPTMPB
 STAIY MPSCPT
 INY
 LDA MPTMPB+1
 STAIY MPSCPT
 INY
 LDA MPTMPB+2
 STAIY MPSCPT
 LDAIM 0
 STA RSTFLG
 RTS

;FIND SIZE OF OBJECT
;
;ON ENTRY
;     MPMBPT POINTS TO MAP BLOCK
;
;ON EXIT
;     MPTMPA HOLDS NUMBER OF BYTES
;     MPTMPD HOLDS NUMBER OF BLOCKS
;
;
MPGTSZ LDAIM 0
 STA MPTMPD
 STA MPTMPD+1
 STA MPTMPD+2 ;ZERO BLOCK COUNT
 LDA MPMBPT
 PHA
 LDA MPMBPT+1
 PHA 
 
MPGSMB LDAIM MBENTS
 STA MPTMPB
 LDAIM /(MBENTS )
 STA MPTMPB+1 ;OFFSET
MPGTLP;ADD UP NEXT ENTRY
 CLC
 LDA MPMBPT
 ADC MPTMPB
 STA MPSCPT
 LDA MPMBPT+1
 ADC MPTMPB+1
 STA MPSCPT+1
 LDYIM 0
 LDAIY MPSCPT
 INY
 ORAIY MPSCPT
 INY
 ORAIY MPSCPT
 BEQ MPGSGB
 LDA MPTMPB
 CMPIM LSTENT
 LDA MPTMPB+1
 SBCIM /(LSTENT )
 BCS MPGSNX
 LDYIM 3
 CLC
 LDA MPTMPD
 ADCIY MPSCPT
 STA MPTMPD
 INY
 LDA MPTMPD+1
 ADCIY MPSCPT
 STA MPTMPD+1
 LDA MPTMPD+2
 ADCIM 0
 STA MPTMPD+2
 CLC
 LDA MPTMPB
 ADCIM ENSZ
 STA MPTMPB
 LDA MPTMPB+1
 ADCIM 0
 STA MPTMPB+1
 JMP MPGTLP
MPGSNX ;GET NEXT MAP BLOCK
 LDYIM 0
 LDAIY MPSCPT
 STA MPTMPA
 INY
 LDAIY MPSCPT
 STA MPTMPA+1
 INY
 LDAIY MPSCPT
 STA MPTMPA+2
 CLC
 JSR RDMPBK
 BEQ MPGSS2
 JMP MPGSND
MPGSS2 LDA MAPTMP
 STA MPMBPT
 LDA MAPTMP+1
 STA MPMBPT+1
 JMP MPGSMB
MPGSGB PLA
 STA MPMBPT+1
 PLA
 STA MPMBPT
 ;CALCULATE BYTES FROM BLOCKS
 LDA MPTMPD ;NUMBER OF BLOCKS
 STA MPTMPB
 LDA MPTMPD+1
 STA MPTMPB+1
 LDA MPTMPD+2
 STA MPTMPB+2
 LDAIM 0
 STA MPTMPA ;ZERO BYTE COUNT
 STA MPTMPA+1
 STA MPTMPA+2
 LDA MPTMPD
 ORA MPTMPD+1
 ORA MPTMPD+2
 BEQ MPGSSA
MPGSL1 SEC
 LDA MPTMPB
 SBCIM 1
 STA MPTMPB
 LDA MPTMPB+1
 SBCIM 0
 STA MPTMPB+1
 LDA MPTMPB+2
 SBCIM 0
 STA MPTMPB+2
 ORA MPTMPB+1
 ORA MPTMPB
 BEQ MPGSFN
 CLC
 LDAIM BTINBK
 ADC MPTMPA
 STA MPTMPA
 LDAIM /(BTINBK )
 ADC MPTMPA+1
 STA MPTMPA+1
 LDAIM 0
 ADC MPTMPA+2
 STA MPTMPA+2
 JMP MPGSL1

MPGSFN ;GET BYTES IN LAST BLOCK
 LDYIM BILB
 LDAIY MPMBPT
 INY
 ORAIY MPMBPT
 BNE MPGSNZ
 CLC
 LDA MPTMPA
 ADCIM BTINBK
 STA MPTMPA
 LDA MPTMPA+1
 ADCIM /(BTINBK )
 STA MPTMPA+1
 LDA MPTMPA+2
 ADCIM 0
 STA MPTMPA+2
 JMP MPGSSA
MPGSNZ LDYIM BILB
 CLC
 LDA MPTMPA
 ADCIY MPMBPT
 STA MPTMPA
 INY
 LDA MPTMPA+1
 ADCIY MPMBPT
 STA MPTMPA+1
 LDA MPTMPA+2
 ADCIM 0
 STA MPTMPA+2
MPGSSA LDAIM 0
 RTS
MPGSND PLA
 PLA
 LDAIM MPERRC
 RTS

CHDNAM  ;CHDNAM

;LOOK UP DISC NAME IN SECTOR ZERO INFO
;POINTED TO BY MPSCPT.
;IF FOUND, AND ENTRY IN USE -> ERROR
;IF FOUND, ENTRY NOT IN USE, MARK IN USE
;AND SET MAP TABLE ENTRY DISC NO. FROM TABLE
;IF NOT FOUND, CHUCK OUT LRU DISC NO. NOT
;CURRENTLY IN USE, INSERT NEW NAME AND GIVE IT
;A NEW DISC NUMBER (FROM NXTDNO). MARK ENTRY IN USE.
;SET DISC NO. IN MAP TABLE

;ON ENTRY MAPPTR -> MAP TABLE ENTRY



 JSR FNDDSC ;EXIT WITH DNMPTR POINTING TO ENTRY
 BNE CHDNAA ;NOT FOUND, THROW AN ENTRY OUT

;IF HERE, DISC FOUND. IF IN USE, THEN ERROR
;COZ => TWO DISCS OF SAME NAME IN USE
;ON SAME SYSTEM. IF NOT IN USE, RETURN
;DISC NUMBER.

 LDYIM NTUSED
 LDAIY DNMPTR
 BNE CHDNON ;NOT IN USE, OK

 LDAIM MPERRJ
 JMP CHDNEX ;ERROR

CHDNON LDYIM NTDNO
 LDAIY DNMPTR
 PHA
 INY
 LDAIY DNMPTR

;NOW SET MAP TABLE ENTRY

 LDYIM MPDCNO+1
 STAIY MAPPTR
 DEY
 PLA
 STAIY MAPPTR

;MARK NAME TABLE ENTRY IN USE

 LDYIM NTUSED
 LDAIM USED
 STAIY DNMPTR

 JMP CHDNOK ;FOUND FINISH



CHDNAA JSR LRUDSC

;NOW DNMPTR => LRU NAME ENTRY

 JSR SDSCNM

CHDNOK LDAIM 0
CHDNEX RTS  ;EXIT


MOVDNM   ;MOVDNM

;MOVE DISC NAME FROM SEC. ZERO
;TO DNMBUF.

 LDXIM 0
 LDYIM MPSZNM
MDNLPA LDAIY MPSCPT
 STAAX DNMBUF
 INY
 INX
 CPXIM DNAMLN
 BNE MDNLPA
 RTS


FNDDSC   ;FNDDSC

;ENTRY: MPSCPT -> SECTOR ZERO INFO, INCLUDING DISC NAME

;EXIT:  DNMPTR -> NAME TABLE ENTRY IF FOUND
;Z FLAG SET IF FOUND

;SIDE EFFECT: DISC NAME MOVED TO DNMBUF

 JSR MOVDNM ;MOVE DISC NAME TO DNMBUF

FNDNAM LDA NAMETB
 STA DNMPTR
 LDA NAMETB+1
 STA DNMPTR+1 ;SET P.0 POINTER
 LDAIM NTSIZE ;NO. OF ENTRIES IN NAMTAB
 STA TEMPA

FDLPB LDYIM NTNAME ;NAMTAB OFFSET
 LDXIM 0
FDLPC LDAIY DNMPTR
 EORAX DNMBUF ;Compare
 ANDIM &DF ;Force cases
 BNE FDONA
 INX
 INY
 CPXIM DNAMLN
 BNE FDLPC

;IF HERE, NAME FOUND, Z SET.
 BEQ FDEXIT

FDONA DEC TEMPA
 BEQ FDONB ;SEARCH FINISHED, NOT FOUND
 JSR INAMPT ;SET DNMPTR TO POINT TO NEXT ENTRY
 JMP FDLPB ;DO NEXT ENTRY

FDONB LDAIM MPERRK ;UNSET Z FLAG
FDEXIT RTS  ;FINISH



LRUDSC   ;LRUDSC

;SEARCH NAME TABLE FOR LRU ENTRY

;ON EXIT DNMPTR -> LRU ENTRY

 LDA NAMETB
 STA GENPTR
 LDA NAMETB+1
 STA GENPTR+1

 LDAIM &FF
 STA TEMPA ;USED TO KEEP PARTIAL RESULT
 LDXIM NTSIZE ;NO. OF ENTRIES

LRUDLP LDYIM NTUSED ;OFFSET OF USE FLAG
 LDAIY GENPTR
 BEQ LRUDON ;IN USE -> NO GOOD

 CMP TEMPA
 BCS LRUDON ;TABLE ENTRY>=TEMPA, CONTINUE

 STA TEMPA ;NEW PARTIAL RESULT
 LDA GENPTR
 STA DNMPTR ;SET POINTER TO PARTIAL RESULT ENTRY
 LDA GENPTR+1
 STA DNMPTR+1

LRUDON DEX
 BEQ LRUEX ;ALL ENTRIES DONE, FINISH

 CLC
 LDAIM NTENSZ
 ADC GENPTR
 STA GENPTR
 LDAIM 0
 ADC GENPTR+1
 STA GENPTR+1
 JMP LRUDLP

LRUEX RTS







;DDNAME   ;DDNAME

;DELETE DISC NAME POINTED TO BY
;DNMPTR.
;PUT $80 IN FIRST CHAR. OF NAME SO
;IT WON'T BE RECOGNISED AND SET
;USED FLAG TO UNUSED.

 LDYIM NTNAME
 LDAIM &80
 STAIY DNMPTR
 LDYIM NTUSED
 LDAIM UNUSED
 STAIY DNMPTR
 RTS


FNDDNO

;LOOK UP CURDNO IN NAMETABLE.
;EXIT: NAMTAB -> ENTRY, Z SET IF FOUND

 JSR SDNMPT
 LDXIM NTSIZE - 1

FNDDLP LDYIM NTDNO
 LDA CURDSC
 CMPIY DNMPTR
 BNE FDDON
 INY
 LDA CURDSC+1
 CMPIY DNMPTR
 BEQ FDDEX ;FOUND, FINISH

FDDON JSR INAMPT ;MOVE DNMPTR
 DEX
 BPL FNDDLP

FDDEX RTS



AGENTB

;AGE ALL ENTRIES NOT IN USED IN THE
;DISC NAME TABLE

 JSR SDNMPT
 LDXIM NTSIZE
 LDYIM NTUSED
AGENTL LDAIY DNMPTR
 BEQ AGENTM ;IN USE, DON'T AGE
 SEC
 SBCIM 1 ;AGE
 STAIY DNMPTR
AGENTM JSR INAMPT
 DEX
 BNE AGENTL
 RTS


SDNMPT LDA NAMETB
 STA DNMPTR
 LDA NAMETB+1
 STA DNMPTR+1
 RTS



;INCREMENT THE SEQUNCE NUMBER


CHKDSC

;CHECK SECTOR ZERO INFO (POINTED TO
;BY MPSCPT) IS FOR A VALID FS DISC

 LDYIM MPDRNM ;PONTER TO NAME
 LDXIM 0
CHKDLP LDAAX TAGTAB
 CMPIY MPSCPT
 BNE CHKDER
 INY
 INX
 CPXIM 4
 BNE CHKDLP ;IF EQ, DROP THROUGH AND EXIT, Z SET

CHKDEX RTS
CHKDER LDAIM MPERRD
 BNE CHKDEX

TAGTAB = "AFS0"


SMAPEN

;MOVE SECTOR ZERO INFO. POINTED TO
;BY MPSCPT INTO MAP TABLE ENTRY
;POINTED TO BY MAPPTR

 CLC  ;COPY AREA OF STORE
 LDA MAPPTR
 ADCIM MPNOCY ;MAKE MAPPTR POINT TO START OF AREA
 STA MOVTO
 LDA MAPPTR+1
 ADCIM 0
 STA MOVTO+1 ;STORE IN POINTER TO COPY
 CLC
 LDA MPSCPT
 ADCIM MPSZNC ;TO POINT TO DISC INFO
 STA MOVFRM
 LDA MPSCPT+1
 ADCIM 0
 STA MOVFRM+1 ;POINTER FOR MOVING TO
 LDXIM MPSZLN
 JMP MOVE ;MOVE AND EXIT
ZERDSK
;Zeroes an area of disck. Is a psuedo
;map management routine.
;
;On entry
;           OLDSZE = Old size in bytes
;           MPTMPA = SIN of object
;
;On exit
;           Z set if sucessful

 JSR FNDMAP
 BEQ ZDCT
ZDSZ1 JMP ZDND
ZDCT CLC
 JSR RDMPBK ;Requires SIN in MPTMPA
 BNE ZDSZ1
 LDA MAPTMP
 STA MPMBPT
 LDA MAPTMP+1
 STA MPMBPT+1
 LDA OLDSZE
 STA DIVPAR
 LDA OLDSZE+1
 STA DIVPAR+1
 LDA OLDSZE+2
 STA DIVPAR+2
 LDA OLDSZE+3
 STA DIVPAR+3
 JSR DVDE
 BCC ZDZ1
 LDAIM &F9
 JSR INTERR
ZDZ1 LDA OLDSZE
 BNE ZBS2
 LDAIM 1
 STA DIVPAR
 JMP ZBSBT
ZBS2 LDAIM 2
 STA DIVPAR
ZBSBT SEC
 LDA DIVTMP
 SBC DIVPAR ;START FROM BLOCK ZERO
 STA BREGA
 LDA DIVTMP+1
 SBCIM 0
 STA BREGA+1
 LDAIM &FF
 STA NBLKS
 STA NBLKS+1
 JSR DCENT2
 BEQ ZDZ2
 JMP ZBND
ZDZ2
;MAPTMP holds SIN of current disc block
;MPTMPD holds count of number in this entry
;Now zero out rest of current block
 LDA MAPTMP
 STA MPTMPA
 LDA MAPTMP+1
 STA MPTMPA+1
 LDA MAPTMP+2
 STA MPTMPA+2
 LDA OLDSZE
 ORA OLDSZE+1
 ORA OLDSZE+2
 BEQ ZCNT
 LDA OLDSZE
 BEQ ZNBK ;If all of this block used continue
ZCNT CLC
 JSR RDMPBK ;Pretend its map block
 LDA MAPTMP ;Ignore possible error
 STA MPCYPT
 LDA MAPTMP+1
 STA MPCYPT+1
 LDY OLDSZE
 LDAIM 0
ZLP STAIY MPCYPT ;Zero rest of block
 INY
 BNE ZLP
 JSR SETMB
 JSR CASTWB ;Mark block written
 JSR ENSMB ;Write it to disc
 JSR SETMB
 JSR FNDBLK ;FIND BLOCK TO FLUSH
 LDAIM 0
 LDYIM CAFLG
 STAIY GNCBPT
 SEC
 LDA MPTMPD
 SBCIM 1
 STA MPTMPD
 LDA MPTMPD+1
 SBCIM 0
 STA MPTMPD+1
 INC MPTMPA
 BNE ZNBK
 INC MPTMPA+1
 BNE ZNBK
 INC MPTMPA+2
ZNBK
;Next bit writes 0's to MPTMPD entries until
;none left.
 JSR SETBM ;Use bit maps
 JSR GETFR
 LDYIM CBSA
 LDAIY GNCBPT
 STA MPCYPT
 INY
 LDAIY GNCBPT
 STA MPCYPT+1
 LDYIM 0
 LDAIM 0
ZSB STAIY MPCYPT
 INY
 BNE ZSB ;Area of store zeroed
 LDA MPCYPT
 STA DCSTAD
 LDA MPCYPT+1
 STA DCSTAD+1
 LDA MPDRVE
 STA DRIVNO
ZBLP LDA MPTMPD
 ORA MPTMPD+1
 BEQ ZBNE
 LDA MPTMPA
 STA RBDA
 LDA MPTMPA+1
 STA RBDA+1
 LDA MPTMPA+2
 STA RBDA+2
 LDAIM &A
 STA SAVCOM
 JSR XFER
 SEC
 LDA MPTMPD
 SBCIM 1
 STA MPTMPD
 LDA MPTMPD+1
 SBCIM 0
 STA MPTMPD+1
 INC MPTMPA
 BNE ZBLP
 INC MPTMPA+1
 BNE ZBLP
 INC MPTMPA+2
 JMP ZBLP
ZBNE JSR NXTEN
 BNE ZBND
 LDA MAPTMP
 STA MPTMPA
 LDA MAPTMP+1
 STA MPTMPA+1
 LDA MAPTMP+2
 STA MPTMPA+2
 JMP ZBLP
ZBND LDAIM 0
ZDND RTS


 LNK MBBMCM
