 OPT UADE20 ;FILE > Uade20
 TTL File server file UADE20


;C O M M A N D  P R O C E S S O R

;U T I L I T I E S


RCODE ROUT

;Check return code in A. If 0, send
;3 byte message. If not, go to error
;routine
;Command code always set 0.

 LDXIM 0
 STX CCODE
 TAY
 BEQ REPLYA
 JMP EXTERR


;Sends a zero return code to client.
;Sets RC into TXBUF and drops through into
;REPLY, passing a the header length as message length

REPLYA LDAIM TXHDR
REPLYC LDXIM 0
 STX RTCODE ;Set R.code

;Sends a message of length A to client
;on the reply port (in var RPLYPT).

REPLY LDX RPLYPT

;Sends a message of length A on port X
;to client.

REPLYB LDY QPTR ;Get CB pointer
 CLC
 ADCIM :LSB:TXBUF
 STAAY CBBUFE ;Buffer end ptr. (lo)
 LDAIM  0 ;Assumed msg. length < 255

 STAAY CBBUF+2
 STAAY CBBUF+3 ;hi order addresses
 STAAY CBBUFE+2
 STAAY CBBUFE+3 ;from 2nd processor

 ADCIM :MSB:TXBUF
 STAAY CBBUFE+1 ;Buffer end ptr (hi)

 LDAIM :LSB:TXBUF
 STAAY CBBUF ;Buffer ptr lo
 LDAIM :MSB:TXBUF
 STAAY CBBUF+1 ;Buffer ptr hi
 TXA  ;Set port
 STAAY CBPORT


;Entry point used when CB set up elsewhere
;(e.g. LOAD/EXAMINE). Assumed all is
;set but TX flag.

SEND ROUT
 LDAIM TXFLAG
 ORAAY CBFLG
 STAAY CBFLG

SENDX LDAIM TXRPT
 LDYIM TXDLY ;Delay between tries

;A = no. of times to try transmit
;Y = delay between tries
;NETCB = page zero pointer to control block

 STA TXJ
 STY TXD
 LDYIM 0
 LDAIY NETCB
 STA TXF ;flag byte
10 LDX NETCB ;Pointers to CBlock
 LDY NETCB+1
 LDAIM &10
 JSR OSWORD ;call Tx

 LDAIM 0
 LDAIY NETCB ;check for Tx on Tx
 BNE #20
 LDA TXF
 STAIY NETCB
 BNE #10 ;restore flag byte and try again

20 LDAIM 50
 JSR OSBYTE
 TXA
 BMI #20 ;poll 'til done
 BEQ #40 ;Yes => success => exit
 DEC TXJ ;No. of times decrement
 BEQ #30 ;All done => failure
 LDY TXD ;Delay time
 JSR MSDELY ;Do delay
 JMP #10 ;Do again

30 TXA ;Return flag in A
40 RTS


;Wait to receive from client.
;Control block pointed by QPTR, wait
;is a constant (WAITCL) no. of msecs.

WAIT ROUT
 LDAIM RXFLAG
 STA CBFLG ;CB is ammended for Rx, so open it

 LDXIM 0
 STX RXCBN
 LDAIM &11
 LDXIM :LSB:RXCBN
 LDYIM :MSB:RXCBN
 JSR OSWORD

 LDXIM 50
WaitX STX TIMER2
 LDXIM WAITCL
 STX TIMER1
10 LDAIM ONEMS ;One msec loop
 STA TIMER ;(2cycles)
20 LDX RXCBN ;(4usecs)
 LDAIM 51
 JSR OSBYTE ;poll Rx
 TXA
 BMI #30 ;(2)
 DEC TIMER ;(5) timer not p.0
 BNE #20 ;(3)
 DEC TIMER1  ;(2)
 BNE #10 ;(3)
 DEC TIMER2
 BNE #10

;Total inner loop time = 14 cycles
;So ONEMS = 71 (decimal)

30 LDXIM :LSB:RXCBN
 LDYIM :MSB:RXCBN
 LDAIM &11
 JSR OSWORD ;read the control block

 LDAIM 0
 BIT RXCBN+1 ;read flag byte
 BMI #40
 LDAIM WAITER ;timeout

40 RTS
  

ERROR ROUT
 JSR EXTERR
 JMP COMRTS


;Puts error code in A into TXBUF +02.
;Looks A up in ERRTAB and if found, puts text into
;message.
;If not found, uses text F.S. ERROR xx (xx is A
;in hex).
;Message then send to client using REPLY.
;CCODE always set to zero in LOOKER

EXTERR ROUT
 PHA
 JSR LOOKER ;Find error in table etc.
 PLA ;** 17/9/84 **
 CMPIM RDERRH
 BNE #30           
 LDA MCopat+1 ;Details of where object open
 BEQ #10 ;net number

 JSR #40 ;write into the buffer
 LDAIM "."
 STAAX MIDTX ;add separator
 INX

10 LDA MCopat ;station number
 JSR #40 ;append to end of message
 LDAIM "("
 STAAX MIDTX ;lest job (task) number present
 LDA MCopat+2
 BEQ #20
 INX
 JSR #40 ;write into the buffer
 LDAIM ")"
 STAAX MIDTX
 INX

20 LDAIM CR
 STAAX MIDTX

30 TXA ;Message length for REPLY
 SEC ;Set carry to add 1 for CR
 ADCIM TXHDR ;Add header length to message length
 JMP REPLY ;Send and return

40 STX COTEMP
 JSR MKDEC ;convert to decimal
 LDYIM :LSB:-3
 LDX COTEMP ;restore X value
50 LDAAY COWORK-:LSB:-3 ;get results from MKDEC
 CMPIM SPACE
 BEQ #60
 STAAX MIDTX ;put text in buffer
 INX
60 INY
 BNE #50
 RTS


;Look error in A up and put relevant message
;at MIDTX.

LOOKER ROUT
 STA RTCODE
 PHA

 LDAIM :LSB:ERRTAB
 STA GENPTR
 LDAIM :MSB:ERRTAB
 STA GENPTR+1
 LDYIM 0
 STY CCODE ;Set command code to zero
10 PLA
 CMPIY GENPTR ;Check error number
 BEQ #60 ;Found

 PHA
 LDAIM CR
20 INY
 BNE #30
 INC GENPTR+1
30 CMPIY GENPTR ;Move to end of this text
 BNE #20
 INY
 BNE #40
 INC GENPTR+1
40 LDAIY GENPTR
 BNE #10 ;Non-zero => not end of table

;If here, number not found, so construct
;default error message.

 LDXIM 0
45 LDAAX ERRMSG ;Load error text
 BMI #50 ;Terminated by NOP
 STAAX MIDTX ;Store in transmit buffer
 INX
 BNE #45

50 PLA  ;Get error number back
 JSR WRTERR ;Put A in hex in message at X
 LDAIM CR
 STAAX MIDTX ;Terminate message
 RTS

60 LDXIM &FF ;Error found, move text to message
65 INX
 INY
 BNE #70
 INC GENPTR+1
70 LDAIY GENPTR
 STAAX MIDTX
 CMPIM CR
 BNE #65
 RTS  ;Complete, exit X - length-1


WRTERR ROUT
 PHA
 LSRA
 LSRA
 LSRA
 LSRA
 JSR #10 ;TOP NIBBLE
 PLA
10 ANDIM &F
 CMPIM &A
 BCC #20
 ADCIM 6
20 ADCIM &30
 STAAX MIDTX
 INX
 RTS


 [ Lang = English
ERRMSG = "F.S. Error "
 ]
 [ Lang = Italian
ERRMSG = "Errore mefile "
 ]
 NOP


;Send big block on port in A.
;Size of message is in OUTBSZ,
;assumes station already set.

SENDBB ROUT
SENDBC LDY QPTR
 STAAY CBPORT
 CLC
 LDA BBUF ;Buffer address
 STAAY CBBUF
 ADC OUTBSZ
 STAAY CBBUFE
 LDA BBUF+1
 STAAY CBBUF+1
 ADC OUTBSZ+1
 STAAY CBBUFE+1
 JMP SEND ;Send message  ...


SENDIO ROUT
 LDY QPTR ;routine to send the IO side buffer
 STAAY CBPORT ;in byte-size chunks ** 19/1/84 **

 CLC
 LDA IOBUF
 STA COTEMP
 ADC OUTBSZ
 STA OUTBSZ
 LDA IOBUF+1
 STA COTEMP+1
 ADC OUTBSZ+1
 STA OUTBSZ+1 ;COTEMP is low end of buffer

 LDAIM &FF
 STAAY CBBUF+2
 STAAY CBBUF+3
 STAAY CBBUFE+2
 STAAY CBBUFE+3 ;initialise top bytes

10 LDY QPTR
 CLC

 LDA COTEMP
 STAAY CBBUF
 ADCIM BUFSZ
 STAAY CBBUFE
 STA COTEMP

 LDA COTEMP+1
 STAAY CBBUF+1
 ADCIM :MSB:BUFSZ
 STAAY CBBUFE+1
 STA COTEMP+1 ;buffer pointers set, new COTEMP set

 LDAAY CBBUFE
 CMP OUTBSZ
 LDAAY CBBUFE+1
 SBC OUTBSZ+1
 BCC #20 ;C=1 if cbbufe>= outbsz

 LDA OUTBSZ
 STAAY CBBUFE
 LDA OUTBSZ+1
 STAAY CBBUFE+1 ;setup last transmission

20 PHP
 JSR SEND ;do transmit
 PLP ;restore carry
 TAX
 BNE #30 ;bad transmit
 BCC #10
30 RTS

MSDELY ROUT
 CPYIM 0
 BEQ #30 ;If no delay, Exit
 PHA ;Keep Acc.
 TXA
 PHA ;Keep X
 TYA
 PHA
 LDXIM 0
10 DEX
 BNE #10 ;1msec loop
 DEY
 BNE #10 ;Outer loop
 PLA
 TAY ;Reset delay time
 PLA
 TAX ;Reset X
 PLA ;Reset A
30 RTS


;*** NON - NET  UTILITIES ***


CPDNAM ROUT

;Read disc name of disc number at ARGF on stack
;into MIDTX offset by A.

 PHA ;Push MIDTX offset

 LDYIM ARGF
 LDAIY NEWARG ;GET DISC NO.
 PHA
 INY
 LDAIY NEWARG ;SET ON STACK AT ARGB
 LDYIM ARGC
 STAIY NEWARG
 DEY
 PLA
 STAIY NEWARG
 LDAIM &B ;MAPMAN ENTRY PT.
 JSR SETRTN
 JSR MAPMAN
 BNE #20

 LDYIM ARGB
 LDAIY NEWARG
 STA GENPTR
 INY
 LDAIY NEWARG
 STA GENPTR+1 ;SET PTR. TO DISC NAME

 PLA
 TAX ; Offset from MIDTX
 LDYIM 0
10 LDAIY GENPTR
 STAAX MIDTX
 INX
 INY
 CPYIM DNAMLN
 BNE #10
20 RTS


DIRIND ROUT
 STA COZERO
 JSR STKUSA ;Stack user info at ARGA
 LDXIM &C1
 BNE #10

;Call DIRMAN.EXAMINE to get last component of
;file title (may be CR) and disc number and cycle
;number of directory.
;On entry, A is offset from MIDTX to put dir. name
;Dir. name arg. is assumed at MIDRX

DIRINF STA COZERO
 JSR STKUSA ;Stack user info at ARGA
 LDXIM &C0
10 LDAIM HDRLEN
DIRIN2  ;Entry point from CPINFO
 STX COZERO+1 ;save parameter for DIRMAN
 JSR SETFTP ;MOVE FILE TITLE PTR. TO STACK
 INY
 LDA COZERO ;Load offset
 CLC
 ADCIM :LSB:MIDTX
 STAIY NEWARG ;SET RESULT AREA FOR EXAMINE
 LDAIM :MSB:MIDTX
 ADCIM 0
 INY
 STAIY NEWARG
 INY
 LDAIM 4
 STAIY NEWARG ;ARG. FOR EXAMINE => GET TITLE
 LDAIM 7
 JSR SETRTN

 LDYIM ARGK
 LDA COZERO+1 ;passed parameter
 STAIY NEWARG ;wild card flag

 JMP DIRMAN ;GET INFO. and return


;Copy SIN/Disc no. from DANDS to
;stack. Y already set as stack ptr.

SINDSC ROUT
 LDXIM 0
10 LDAAX DANDS
 STAIY NEWARG
 INY
 INX
 CPXIM 5
 BNE #10
 RTS


;Copy disc block information to stack, starting
;at Y.

;Info is:
;1) Current disc block start (CURBLK)
;2) No. of blocks to read/write (DIVPAR)
;3) Address to read/write to/from (BBUF)

IBLOCK ROUT
 LDA CURBLK
 STAIY NEWARG
 INY
 LDA CURBLK+1
 STAIY NEWARG

 INY
 LDA DIVPAR
 STAIY NEWARG
 INY
 LDA DIVPAR+1
 STAIY NEWARG

 INY
 LDA IOBUF
 STAIY NEWARG
 INY
 LDA IOBUF+1
 STAIY NEWARG

 RTS



;Set pointer on stack pointing to
;text buffer.
;Also set 0 in byte after receive buffer
;Offset in A on entry to SETTXP

SBUFPT ROUT
 LDAIM 0

SETTXP INY
 CLC
 ADCIM :LSB:TXTBUF
 STAIY NEWARG
 LDAIM :MSB:TXTBUF
 INY
 ADCIM  0
 STAIY NEWARG
 LDX BPTR
 LDAIM  0
 STAAX RXBUFT
 RTS

;Sets file title pointer to stack
;at Y.
;On entry, A is offset of file title
;in RX buffer.

;This routine also puts 0 in the byte
;after the receive buffer so that
;analysis of the file title doesn't
;get carried away.

SETFTP INY
 CLC
 ADC BPTR ;Add file title offset to buffer offset
 ADCIM :LSB:RXBUF
 STAIY NEWARG
 LDAIM  0
 ADCIM /(RXBUF )
 INY
 STAIY NEWARG
 TXA
 PHA ;Store X just in case
 LDX BPTR
 LDAIM  0
 STAAX RXBUFT ;RX buffer terminater
 PLA
 TAX ;Restore X
 RTS

;Returns the last component of the pathname handed to save
;in MIDTX [3:13]

SAVNAM ROUT
 LDX BPTR
10 INX
 LDAAX MIDRX+11
 CMPIM CR
 BNE #10 ;look for CR
20 DEX
 LDAAX MIDRX+11
 CMPIM "."
 BEQ #30
 CPX BPTR ;maybe just one component here
 BNE #20
 DEX
30 INX
 LDYIM 0
40 LDAAX MIDRX+11
 CMPIM CR
 BEQ #50
 STAAY MIDTX+3
 INX
 INY
 BNE #40
50 LDAIM &20
60 CPYIM 12
 BCS #70
 STAAY MIDTX+3
 INY
 BNE #60

70 LDAIM &80
 STAAY MIDTX+3
 RTS ;terminate with CR


;Call FINDMC using machine number
;in net control block.

;Then set CSD handle from RX block into
;user table.

GETUSE ROUT ;Entry generating EXTERR if error
 JSR GETUSR
 BEQ #10
 JSR EXTERR
 LDAIM &FF ;Indicate unsuccessful exit
 RTS

GETUSR LDY QPTR ;Entry not generating error
 LDAAY CBSTID
 STA MCNUMB
 LDAAY CBSTID+1
 STA MCNUMB+1
 LDAAY CBflg ;**25/12/86**
 ANDIM MCtask
 STA MCnumb+2

 JSR FINDMC
 BNE #10

 LDX BPTR
 LDAAX CPCSD ;GET CSD SENT FROM CLIENT
 LDYIM UTHSLD
 STAIY USTPTR ;SET CSD
 LDAIM 0 ;Indicate successful exit
10 RTS



;Move user info. pointer in USTPTR
;to stack.

SETUSE ROUT
 INY
 LDA USTPTR
 STAIY NEWARG
 LDA USTPTR+1
 INY
 STAIY NEWARG
 RTS


;GET USER INFO AND PUT ON STACK AT ARGB

STKUSE ROUT
 JSR GETUSE
 BNE #10
STKUSA LDYIM ARGA
 JSR SETUSE ;NOTE SETUSE DOES INY FIRST, SO ARGA CORRECT
 LDAIM 0
10 RTS


;PUT THREE HANDLES FROM RX BUFFER
;ON STACK AT Y.

STKHND ROUT
 LDX BPTR
 LDAAX CPUFD
 STAIY NEWARG
 INY
 LDAAX CPCSD
 STAIY NEWARG
 INY
 LDAAX CPLIB
 STAIY NEWARG
 RTS


SETRTN ROUT
 LDYIM ARGA
 STAIY NEWARG
 RTS


;Set pointer to COWORK on stack

SCOWPT ROUT
 INY
 LDAIM :LSB:COWORK
 STAIY NEWARG
 INY
 LDAIM :MSB:COWORK
 STAIY NEWARG
 RTS



;SIN/disc no. of object are on
;stack (usually just after a call
;of PRESERVE).

;assumes that GETUSE result is valid ** 3/10/84 **

;If SIN <> 0 ...

;1) Clear object from store.
;2) Delete object from map
;3) Ensure map.

OBJCLR ROUT
 JSR SINZED ;Check SIN is zero (also used in RENAME)
 BEQ #30 ;If zero, exit

 LDAIM 5 ;STRALL function
 JSR SETRTN
 JSR STRMAN ;Flush from store
 BNE SETRTN ;put it on the stack if error

 LDYIM ARGF
 JSR SETUSE ;pass pointer to user info ** 3/10/84 **

 LDAIM MAPFS ;Map free store
 JSR SETRTN
 JSR MAPMAN ;Delete from map
 BNE #20 ;No good => abort

 LDAIM MAPENS ;Map ensure fn.
 JSR SETRTN
 JSR MAPMAN ;Ensure map
 BEQ #30 ;OK => exit

20 JSR INTERR ;Not ok => stop

30 RTS


SINZED LDYIM ARGD
 LDAIY NEWARG
 INY
 ORAIY NEWARG
 INY
 ORAIY NEWARG
 RTS


;Gets entry point, no. of entries and a pointer
;to BIGBFR +1 onto stack. Used by DISCS and USERS

STKLST ROUT
 TYA
 TAX ;pointer into MIDRX
 LDYIM ARGB
 LDAAX MIDRX
 STAIY NEWARG ;Start point in list
 INY
 LDAAX MIDRX+1
 STAIY NEWARG ;Number of entries
 INY
 LDA BBUF
 CLC
 ADCIM TXHDR+1 ;Result area
 STAIY NEWARG
 INY
 LDA BBUF+1
 ADCIM 0
 STAIY NEWARG
 RTS



;Given no. of entries found and ptr. to
;end of result area on stack, sends off the
;result of DISC/USERS in big buffer.
;On entry A = continue code.

LSTRPY ROUT
 STA TEMPA
 LDYIM ARGB
 LDAIY NEWARG
 PHA ;Number of entries found
 LDA BBUF
 STA GENPTR
 LDA BBUF+1
 STA GENPTR+1
 LDYIM 0
 LDA TEMPA ;Continue code
 STAIY GENPTR
 TYA ;Return code (0)
 INY
 STAIY GENPTR
 PLA
 INY
 STAIY GENPTR ;Number of entries found

;Set control block for reply

 LDA RPLYPT
 LDX QPTR
 STAAX CBPORT
 LDA BBUF
 STAAX CBBUF ;Ptr. to message
 LDA BBUF+1
 STAAX CBBUF+1
 LDYIM ARGC
 LDAIY NEWARG ;End of result buffer
 STAAX CBBUFE
 INY
 LDAIY NEWARG
 STAAX CBBUFE+1
 LDY QPTR ;Arg to SEND
 JMP SEND ;Send reply and exit



;Set stack and call DIRMAN retrieve
;to put details into COWORK buffer.
;On entry A = offset in RXCB of file name

LDRETR ROUT
 LDAIM LODFTO

CPRETR PHA
 LDAIM DRRTR ;Dirman retreive
 JSR SETUSA ;PLACE ADDR OF USERINFO ONTO NEWARG STACK
 PLA ;Pull f.t. offset
 JSR SETFTP ;Set file title pointer
 JSR SCOWPT
 LDAIM &C0 ;allow wild cards in LOAD
 LDYIM ARGH
 STAIY NEWARG ;wild card flag

 JMP DIRMAN ;Get info. to COWORK and return



 [ 1=0
RNAMDQ ROUT
 TAY
 LDAIM &C0 ;wild card flag
 PHA
 TYA
 BNE #10

RNAMDM

;Call DIRMAN with function code in A, file title offset
;from TXTBUF in X. Used from RENAME.

 TAY
 LDAIM 0
 PHA
 TYA
10 JSR SETUSA
 TXA ;Get offset of file name in TXTBUF
 JSR SETTXP
 PLA
 JMP CPRET1 ;Set pointer to COWORK, and call DIRMAN



;Check access/type byte for RENAME
;Must be an unlocked file with OWNER access

CHEKTB = DRERRG ;Is locked
 = LODERA ;Is a directory
 = DRERRE ;Insufficient access

CHEKRN ROUT
 LDXIM 3
 LDYIM ARGB
 LDAIY NEWARG
 EORIM OWNER ;Flip the OWNER bit
 ASLA
10 ASLA
 BCS #20
 DEX
 BNE #10

 TXA ;Zero RC
 RTS

20 LDAAX CHEKTB-1
 RTS
       
 ]


;COMMAND LINE UTILS


;Get string (possibly quoted) from
;CLI string (at MIDRX) and transfer
;to TXTBUF offset by X (normally zero)
;NOTE - ACKS and NACKS ignored here !!

BUFTXT ROUT
 LDXIM 0
BTXTA LDAIM 0
 STA QUOTED ;Quoted flag

 JSR SPACES
 CMPIM """"
 BNE #30
 DEC QUOTED ;Quoted flag on
 DEX

20 INX
25 INY
30 LDAAY MIDRX
35 STAAX TXTBUF

 CMPIM ACK
 BEQ #25 ;Inc. string ptr., but not buffer
 CMPIM NACK
 BEQ #25

 CMPIM CR
 BEQ #60
 CMPIM SPACE
 BNE #50
 BIT QUOTED
 BMI #20 ;Spaces OK in quoted string

40 LDAIM CR ;Finish with CR as terminator in destn.
 BNE #35

50 CMPIM """"
 BNE #20
 INY ;Step C.line ptr. past final delimiter
 INC QUOTED ;Switch off quoted flag
 BEQ #40 ;Exit, with CR terminator

60 LDA QUOTED ;Error in quoted string
 BEQ #70 ;Otherwise exit, Z set

BUFERR LDAIM NAMERR
 PHP
 JSR EXTERR ;Send error message
 PLP
70 RTS ;Give Z unset exit

 [ 1=0 ;**8/2/88
;Read hex number (up to 4 bytes)
;into 4-byte p.0 area at X. NOTE
;uses 1 extra byte at X.

RDNUM ROUT
 LDAIM 0
 STAAX 0
 STAAX 1
 STAAX 2
 STAAX 3
 STAAX 4
 JSR SPACES
10 LDAAY MIDRX
 CMPIM "0"
 BCC #40
 CMPIM &3A
 BCC #20
 SBCIM 7
 BCC #40
 CMPIM &40
 BCS #40

20 ASLA
 ASLA
 ASLA
 ASLA
 STYZX 4
 LDYIM 4
30 ASLA
 ROLZX 0
 ROLZX 1
 ROLZX 2
 ROLZX 3
 DEY
 BNE #30
 LDYZX 4
 INY
 BNE #10

40 LDAZX 4
 RTS
 ]

SPACER DEY
50 INY
SPACES LDAAY MIDRX
 CMPIM SPACE
 BEQ #50
 RTS


;Move file title into TXTBUF and
;check to end of line for syntax.

RDTITL ROUT
 JSR BUFTXT
 BNE #10 ;**20/5/87** fall into COMEND

COMEND JSR SPACES
 CMPIM CR
 BEQ #10
 LDAIM SYNERR
 JSR EXTERR
 LDAIM SYNERR ;Give non-zero exit
10 RTS

;** E R R O R  T A B L E **

ERRTAB

 [ Lang = English
 = URERRA,"Who are you?",CR
 = WOTERR,"Bad Command",CR
 = NAMERR,"Bad string",CR
 = DRERRA,"Bad file name",CR
 = DRERRB,"Broken dir",CR
 = DRERRC,"Not found",CR
 = DRERRD,"Not a directory",CR
 = DRERRE,"Insufficient access",CR
 = DRERRG,"Entry locked",CR
 = ATERRB,"User not known",CR
 = ATERRC,"Wrong password",CR
 = ATERRE,"Bad password",CR
 = MPERRB,"Disc full",CR
 = MPERRA,"Disc changed",CR
 = SAERRA,"Bad attribute",CR
 = ATERRA,"PW file not found",CR
 = &54,"Insert a Fileserver disc",CR
 = RDERRB,"Channel",CR
 = RDERRJ,"EOF",CR
 = RDERRL,"Outside file",CR
 = RDERRH,"Already open at station ",CR
 = RDERRN,"File read only",CR
 = DCERRE,"Disc read only",CR
 = DCERRF,"Disc fault",CR
 = MPERRL,"Map fault",CR
 = RDERRC,"Too many open files",CR
 = URERRB,"Too many users",CR
 = LODERA,"Is a directory",CR
 = &BA,"Insufficient privilege",CR ;** 13/4/83 **
 = DRERRJ,"Dir. not empty",CR
 = DRERRM,"Dir. full",CR
 = ATERRF,"Already a user",CR
 = RNAMQQ,"Bad Rename",CR
 = DRERRK,"Types don't match",CR
 = URERRE,"Not logged on",CR
 = ATERRG,"Bad user name",CR
 = RDERRO,"Write only",CR ;** 16/11/84
 = MPERRN,"Insufficient space",CR
 = SPERRA,"Bad privilege letter",CR ;** 6/11/86 **
 =  0 ;Table terminator
 ]

 [ Lang = Italian
 = URERRA,"Chi sei?",CR
 = WOTERR,"Comando Errato",CR
 = NAMERR,"Sequenza errata",CR
 = DRERRA,"Nome file errato",CR
 = DRERRB,"Dir rotto",CR
 = DRERRC,"Non trovato",CR
 = DRERRD,"Non e' un directory",CR
 = DRERRE,"Accesso insufficiente",CR
 = DRERRG,"Entrata bloccata",CR
 = ATERRB,"Utente Sconosciuto",CR
 = ATERRC,"P.o. Errata",CR
 = ATERRE,"P.o. incorretta",CR
 = MPERRB,"Disco pieno",CR
 = MPERRA,"Disco changed",CR    ; **********************************
 = SAERRA,"Attributo Errato",CR
 = ATERRA,"P.o. file non trovato",CR
 = &54,"Inserire un disco FileStore",CR
 = RDERRB,"Canale",CR
 = RDERRJ,"FDF",CR
 = RDERRL,"Fuori file",CR
 = RDERRH,"Gia' aperto alla stazione ",CR
 = RDERRN,"File solo lettura",CR
 = DCERRE,"Disco solo lettura",CR
 = DCERRF,"Disco difettoso",CR
 = MPERRL,"Mappa difettoso",CR
 = RDERRC,"Troppi file aperti",CR
 = URERRB,"Troppi utenti",CR
 = LODERA,"E' gia' un directory",CR
 = &BA,"Privilegio insufficiente",CR ;** 13/4/83 **
 = DRERRJ,"Dir non vuoto",CR
 = DRERRM,"Dir pieno",CR
 = ATERRF,"Gia' in uso",CR
 = RNAMQQ,"Rinome errata",CR
 = DRERRK,"Tipi non coincidono",CR
 = URERRE,"Non acceso",CR
 = ATERRG,"Nome utente errato",CR
 = RDERRO,"Solo scrittura",CR ;** 16/11/84
 = MPERRN,"Spazio insufficiente",CR
 = SPERRA,"Privilegio lettera errato",CR ;** 6/11/86 **
 =  0 ;Table terminator
 ]

FNSH
LEFT * FRESTR-. ;get free store
 [ LEFT > 0 ;must not overflow workspace
 |
 ! 0,"FRESTR incorrect"
 ]

;** T H E  E N D ***
 END

