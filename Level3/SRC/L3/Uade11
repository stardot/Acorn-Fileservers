 OPT UADE11 ;> Uade11
 TTL File server file UADE11

;************************
;*  Restart one drive   *
;*  Disc number -> name *
;*  Disc name -> number *
;*                      *
;*  U T I L I T I E S   *
;************************


;MPFRSP: FREE SPACE

;ENTRY:
;ARGB-C DISC NUMBER
;ARGD-F SIN
;ARGG-H Ptr to user info

;EXIT:  ARGA = RC

;FUNCTION: MAPTB IS SEARCHED TO FIND THE RELEVANT ENTRY. IF THE SECTOR
;MAP IS NOT IN STORE IT IS READ IN. THE SIN IS CHECKED TO ENSURE THAT IT
;POINTS TO THE FIRST BLOCK OF THE CHAIN. ALL THE SECTORS ON THE CHAIN ARE
;THEN ADDED TO THE FREE CHAIN. THE FREE SECTOR COUNT IS THEN ADJUSTED. THE
;DIRTY FLAG FOR THE SECTOR MAP IS SET.

MPFRSP ROUT
 JSR FNDMAP ;GET CURRENT MAP TABLE POSITION
 BNE #10

 LDAIM 0
 STA ERRTYP
 STA DNDLTE

 LDYIM ARGG
 JSR MPFRAD
 BNE #10

 JSR MPDLTE
 BNE #10
 JSR ENSMB
 JSR ENSBM
 LDAIM 0 ; REPLY ZERO
10 LDYIM ARGG
 JSR MPSETF
 JMP MPEXIT


;MPREDR: *** RESTART ONE DRIVE **

;ENTRY: ARGB = DRIVE NO.

;EXIT:  ARGA = RC

MPREDR ROUT
 LDAIM 0
 STA ERRTYP
 LDA BBUF
 STA DSCCB+TRADD ;SET UP AREA TO READ IN SECTOR TWO
 STA MPSCPT
 LDA BBUF+1
 STA DSCCB+TRADD+1
 STA MPSCPT+1

 LDYIM ARGB
 LDAIY ARGPTR
 STA CURDRV ;SET CURRENT DRIVE
 STA MPDRVE

 JSR RDSTWO ;GET SECTOR ZERO TO BIG BUFFER

 JSR CHKDSC ;CHECK DISC IS FS DISC
 BNE #20
 JSR SMPPTR ;SET POINTER TO RELEVANT MAPTAB ENTRY

;Store old MAPTB entry, so that if an error
;occurs, MAPTB can be replaced.
; Having stored old MAPTB entry, replace with stuff
;from sector zero.

 LDYIM MPDCNO
10 LDAIY MAPPTR
 STAAY MAPTBF-MPDCNO
 INY
 CPYIM MPTBSZ
 BNE #10

 JSR SMAPEN ;Move sector zero info. from BBUF

 JSR MPMPSZ
 JSR DIVSEC ; GET NO. OF TRACKS
 LDYIM MPNOCY
 CLC
 LDA MPTMPB ;CALCULATE SIZE OF CY.MAP
 STAIY MAPPTR ; SAVE NO. OF TRACKS
 INY
 ROL MPTMPB ; MULTIPLY TRACKS BY TWO
 LDA MPTMPB+ 1
 STAIY MAPPTR
 ROL MPTMPB+ 1

 JSR CHMPSZ ;CHECK MAP WILL FIT IN AVAILABLE SPACE
 BNE #30

 JSR MPSTCY ;SET CORRECT MAP (MOST RECENT)

 JSR AGENTB ;AGE NAME TABLE

 LDA BBUF
 STA MPSCPT
 LDA BBUF+1
 STA MPSCPT+1 ;CHMAPS destroys MPSCPT

 LDA MAPTBF
 STA CURDSC ;Set disc no. for FNDDNO
 LDA MAPTBF+1
 STA CURDSC+1
 JSR FNDDNO ;Find name table entry of old disc
 LDAIM UNUSED
 LDYIM NTUSED
 STAIY DNMPTR ;Mark old disc unused

 JSR CHDNAM ;CHECK DISC NAME AND PUT IN NAME TABLE
 BNE #30 ;POSSIBLY NOT UNIQUE DISC

 LDAIM 0 ;=> Success
20 JMP MPEXIT ;*** EXIT **

30 PHA ;Error exit !!
 LDYIM MPTBSZ-1
40 LDAAY MAPTBF
 STAIY MAPPTR ;Restore MAPTB information,
 DEY ;so that state is as before
 BPL #40
 PLA
 JMP #20

;MPDRNB:

;ENTRY: ARGB-C DISC NUMBER

;EXIT:  ARGA = RC
;ARGB   DRIVE NUMBER

;FUNCTION: finds the relevant entry
;in MAPTB and returns the drive number currently
;containing that disc (if any)

MPDRNB ROUT
 JSR FNDMAP ;to find disc number
 PHA
 LDYIM ARGB ;save possible answer
 LDA MPDRVE
 STAIY ARGPTR
 PLA
 JMP MPEXIT

;MPDSNB:

;ENTRY: ARGB = DRIVE NUMBER

;EXIT:  ARGA = RC
;ARGB-C DISC NUMBER

;FUNCTION: FINDS THE RELEVANT ENTRY
;IN MAPTB AND RETURNS THE DISC NUMBER CURRENTLY
;ON THAT DRIVE.

MPDSNB ROUT
 LDYIM ARGB ;TO FIND DRIVE NUMBER
 LDAIY ARGPTR
 CMP DRIVES
 BCS #10 ;BRANCH IF LEG PULL
 STA CURDRV
 JSR SMPPTR
 LDYIM MPNOCY ; ** 14/06/86 ** Unless disc has cyls ...
 LDAIY MAPPTR
 INY
 ORAIY MAPPTR
 BEQ #10 ; ** 14/06/86 ** It is a gap between drives

;ENTRY FOUND SO LOOK AT IT
 LDYIM MPDCNO ;FOR DISC NUMBER
 LDAIY MAPPTR
 LDYIM ARGB ;TO SAVE IT FOR RETURN
 STAIY ARGPTR
 LDYIM MPDCNO+1
 LDAIY MAPPTR
 LDYIM ARGC
 STAIY ARGPTR
 LDAIM 0 ;RC
 BEQ #20

10 LDAIM MPERRF
20 JMP MPEXIT

;MPDNNA

;ENTRY: ARGB-C PTR TO DISC NAME

;EXIT : ARGB-C DISC NO.

MPDNNA ROUT
 LDYIM ARGB
 LDAIY ARGPTR
 STA GENPTR
 INY
 LDAIY ARGPTR
 STA GENPTR+1
 LDYIM 0

 LDAIY GENPTR
 CMPIM CR
 BNE #10
 LDAIM MPERRK
 BNE #50 ;null disc name

10 LDAIY GENPTR
 CMPIM CR
 BEQ #20 ;ARG. IS TERMINATED CR, SO NEEDS PADDING
 STAAY DNMBUF
 INY
 JMP #10

20 LDAIM SPACE
30 CPYIM DNAMLN ;CONTINUE PADDING ?
 BCS #40 ;NOPE, Y>=DNAMLN
 STAAY DNMBUF ;YEP, CONTINUE
 INY
 BNE #30

40 JSR FNDNAM ;LOOK UP NAME IN NAME TABLE
 BNE #50 ;NOT FOUND ...

 LDYIM NTDNO
 LDAIY DNMPTR
 PHA
 INY
 LDAIY DNMPTR
 LDYIM ARGC

 STAIY ARGPTR
 PLA
 DEY
 STAIY ARGPTR
 LDAIM 0

50 JMP MPEXIT


;MPNADN

;**  DISC NO. -> DISC NAME **

;ENTRY: ARGB-C DISC NO.

;EXIT:  ARGB-C PTR. TO NAME

MPNADN ROUT
 LDYIM ARGB
 LDAIY ARGPTR
 STA CURDSC
 INY
 LDAIY ARGPTR
 STA CURDSC+1

 JSR FNDDNO
 BEQ #10

 LDAIM MPERRA ;DISC NO. NOT FOUND
 BNE #20

10 LDYIM ARGB
 CLC
 LDA DNMPTR
 ADCIM NTNAME
 STAIY ARGPTR
 INY
 LDA DNMPTR+1
 ADCIM 0
 STAIY ARGPTR
 LDAIM 0 ;OK EXIT ...

20 JMP MPEXIT

;MPFREE
; RETURN SIZE OF FREE CHAIN
;
; Entry:
;    ARGB-C DISC NO
;
; Exit:
;    ARGB-D SIZE
;    ARGE-G TOTAL SPACE

MPFREE ROUT
 JSR FNDMAP ;GET MAP TO STORE
 BNE #10
 LDYIM MPCYMP
 LDAIY MAPPTR
 STA MPCYPT
 INY
 LDAIY MAPPTR
 STA MPCYPT+1
 LDYIM 0
 LDAIY MPCYPT ;GET FREE SPACE
 STA MPTMPA
 INY
 LDAIY MPCYPT
 STA MPTMPA+1
 INY
 LDAIY MPCYPT
 STA MPTMPA+2
 LDYIM ARGB
 LDA MPTMPA
 STAIY ARGPTR
 INY
 LDA MPTMPA+1
 STAIY ARGPTR
 INY
 LDA MPTMPA+2
 STAIY ARGPTR
 LDYIM MPSCTT
 LDAIY MAPPTR
 STA MPTMPA
 INY
 LDAIY MAPPTR
 STA MPTMPA+1
 INY
 LDAIY MAPPTR
 LDYIM ARGG
 STAIY ARGPTR
 DEY
 LDA MPTMPA+1
 STAIY ARGPTR
 DEY
 LDA MPTMPA
 STAIY ARGPTR
 LDAIM 0
10 JMP MPEXIT

;MPZDSK: ZERO AREA OF DISC
;
;ENTRY:
;ARGB-C DISC NUMBER
;ARGD-F SIN
;ARGG-I OLD SIZE
;
;EXIT: ARGA = RC

MPZDSK ROUT
 JSR MPsetd ;**8/5/87** MPTMPA = ARGD
 LDAIY ARGPTR
 STA OLDSZE
 INY
 LDAIY ARGPTR
 STA OLDSZE+1
 INY
 LDAIY ARGPTR
 STA OLDSZE+2
 LDAIM 0
 STA OLDSZE+3
 JSR ZERDSK
 JMP MPEXIT

;**********************************
;*           M A P M A N          *
;*        U T I L I T I E S       *
;**********************************



; READS THE SPECIFIED BIT MAP INTO STORE
;
; ON ENTRY
;     MAPPTR points to map table entry
;     MPTMPC IS CYLINDER NUMBER OF BIT MAP
;
; ON EXIT
;     MPSCPT points to first byte of bit map
;     MPSCOR points to first byte of bit map sector

RDBTMP ROUT ;READ BIT MAP
 LDAIM 0
 STA CBSIN ;ZERO OUT SIN
 STA CBSIN+1
 STA CBSIN+2
 STA MPSCPT
 STA MPSCPT+1
 LDYIM MP1BIT
 LDAIY MAPPTR ;**23/1/87** See if packed bitmap
 BNE #60 
 LDA MPTMPC ;GET CYLINDER NUMBER
 STA CBTPPT ;SAVE FOR DECREMENTING
 LDA MPTMPC+1
 STA CBTPPT+1
 JSR #90 ;**23/1/87** Calculate SIN of bit map
20 JSR SETBM ;**23/1/87** FOUND SO SET SIZE OF BIT MAP CHAIN
 JSR GTBTS ;READ IN BLOCK IF NECESSARY
 BNE #50 ;NON-ZERO IF FAILED
 CLC
 LDA CBSTA ;GET STORE ADDRESS
 STA MPSCOR ;**23/1/87** AND SAVE FOR RETURN
 ADC MPSCPT
 STA MPSCPT ;**23/1/87** calculate offset start
 LDA CBSTA+1
 STA MPSCOR+1
 ADC MPSCPT+1
 STA MPSCPT+1
 LDA ERRTYP
 BEQ #40
 LDA RSTFLG
 BNE #30
 LDAIM IERRAJ
 JSR INTERR
30 LDA CBSTA
 STA CLRPTR
 LDA CBSTA+1
 STA CLRPTR+1
 LDYIM 0
 LDXIM 1
 JSR CLRSTR
40 LDAIM 0
50 RTS

60 LDYIM MPSCYL ;**23/1/87** packed bit map code
 LDAIY MAPPTR ;calculate SIN of packed map
 STA CBTPPT
 INY
 LDAIY MAPPTR
 STA CBTPPT+1
 JSR #90
 LDA MPTMPC ;get cylinder number
 STA CBTPPT
 LDA MPTMPC+1
 STA CBTPPT+1
70 LDA CBTPPT ;see if sector/offset found
 ORA CBTPPT+1
 BEQ #20 ;yes, go read bit map sector
 LDA CBTPPT
 BNE #75
 DEC CBTPPT+1
75 DEC CBTPPT ;count through cylinders
 LDYIM MP1BIT
 CLC
 LDA MPSCPT ;calculate offset
 ADCIY MAPPTR
 BEQ #80
 STA MPSCPT
 ADCIY MAPPTR ;entry must not cross sector bdry
 BCC #70
 BEQ #70 ;exact fit allowed ok
80 LDAIM 0
 STA MPSCPT ;flows or new sector
 INC CBSIN
 BNE #70
 INC CBSIN+1
 BNE #70
 INC CBSIN+2
 JMP #70

90 LDA CBTPPT ;CHECK IF CYLINDER FOUND
 ORA CBTPPT+1
 BEQ #50 ; FOUND SO GO AND READ IN
 LDYIM MPSPCY
 CLC
 LDA CBSIN
 ADCIY MAPPTR
 STA CBSIN
 INY
 LDA CBSIN+1 ;GET TO NEXT BIT MAP
 ADCIY MAPPTR
 STA CBSIN+1
 BCC #95
 INC CBSIN+2
95 LDA CBTPPT ; DECREMENT CYLINDER COUNTER
 BNE #96
 DEC CBTPPT+1
96 DEC CBTPPT
 JMP #90

;
; READ THE BLOCK SPECIFIED AT ARGD INTO STORE
;
RDmpbd ROUT
 JSR MPsetd ;**8/5/87** MPTMPA = ARGD
 CLC ;**8/5/87** fall into RDMPBK

;
; READ THE SPECIFIED MAP BLOCK INTO STORE
;
; ON ENTRY
;     MPTMPA HOLDS SIN
;     CARRY SET IF BLOCK NOT TO BE READ IN
;
; ON EXIT
;     MAPTMP HOLDS POINTER
;
RDMPBK ROUT ;READ IN MAP BLOCK
 PHP ;SAVE STATE OF CARRY FLAG
 LDA MPTMPA ;GET SIN TO RIGHT PLACE
 STA CBSIN
 LDA MPTMPA+1
 STA CBSIN+1
 LDA MPTMPA+2
 STA CBSIN+2
 
 LDA MBCBPT ; GET CORRECT POINTER
 STA GNCBPT
 LDA MBCBPT + 1
 STA GNCBPT + 1
 LDAIM NOMPBK ;NUMBER OF MAP BLOCK ENTRIES
 STA NCBDB
 
 PLP ;GET CARRY FLAG BACK
 BCS #30 ;BRANCH IF NOT TO BE READ IN
 JSR GTBTS ; GET THE MAP BLOCK TO STORE
 BNE #20 ; NON-ZERO IF FAILED
 LDA CBSTA ;SAVE ADDRESS IN CORRECT PLACE
 STA MAPTMP
 STA GNCBPT
 LDA CBSTA+1
 STA MAPTMP+1
 STA GNCBPT+1
 LDYIM MBSQNO ;POINT TO FIRST SEQUNCE NUMBER
 LDAIY GNCBPT
 TAX
 CLC
 LDA GNCBPT
 ADCIM :LSB:LSTSQ
 STA GNCBPT
 LDA GNCBPT+1
 ADCIM :MSB:LSTSQ
 STA GNCBPT+1
 LDYIM 0
 TXA
 CMPIY GNCBPT ;COMPARE WITH LAST NUMBER
 BEQ #10
 LDAIM MPERRC
 RTS

10 LDAIM 0
20 RTS

30 JSR FNDMB
 BCC #40
 LDYIM CBSA
 JMP #50

40 JSR GETFR ;JUST FIND A FREE SPACE
 BNE #20
 LDYIM CBDR
 LDA MPDRVE
 STAIY GNCBPT
 LDYIM CAFLG
 LDAIY GNCBPT
 ORAIM 1 ;FLAG ALLOCATED
 STAIY GNCBPT
 INY
 LDA MPTMPA
 STAIY GNCBPT
 INY
 LDA MPTMPA+1
 STAIY GNCBPT
 INY
 LDA MPTMPA+2
 STAIY GNCBPT
 INY
50 LDAIY GNCBPT ;GET ADDRESS OF FREE STORE
 STA MAPTMP
 STA CLRPTR
 INY
 LDAIY GNCBPT
 STA MAPTMP+1
 STA CLRPTR+1
 LDYIM :LSB:BTINBK
 LDXIM :MSB:BTINBK
 JSR CLRSTR ;CLEAR MAP BLOCK TO ZEROES SINCE NOT READ IN
 JMP #10
 
; CALCULATE THE NUMBER OF SECTORS REQUIRED FROM
; THE NUMBER OF BYTES REQUIRED. 
;
;   ON ENTRY
;           DIVPAR HOLDS THE NUMBER OF BYTES
;
;   ON EXIT
;           DIVPAR HOLDS ODD BYTES
;           DIVTMP HOLDS THE NUMBER OF BLOCKS
;           Carry Set if Overflow
;
DVDE ROUT
 LDAIM 0
 STA DIVTMP
 STA DIVTMP+1
 STA DIVTMP+2
 LDA DIVPAR
 ORA DIVPAR+1
 ORA DIVPAR+2
 BEQ #40
10 SEC ;NOW LOOP DO DIVIDE BY BLOCK SIZE
 LDA DIVPAR
 SBCIM :LSB:BTINBK
 STA DIVPAR
 LDA DIVPAR+1
 SBCIM :MSB:BTINBK
 STA DIVPAR+1
 LDA DIVPAR+2
 SBCIM 0
 STA DIVPAR+2
 BCC #20 ;CARRY CLEAR AT END OF DIVISION
 LDA DIVPAR
 ORA DIVPAR+1
 ORA DIVPAR+2
 BEQ #30
 INC DIVTMP
 BNE #10
 INC DIVTMP+1
 JMP #10

20 LDA DIVPAR ;REPLACE LOWER BYTE
 ADCIM :LSB:BTINBK
 STA DIVPAR
 LDA DIVPAR+1
 ADCIM :MSB:BTINBK
 STA DIVPAR+1
 BCC #30
 INC DIVPAR+2
30 CLC
 LDA DIVTMP
 ADCIM 2 ;AT LEAST TWO BLOCKS LONG
 STA DIVTMP
 BCC #45
 INC DIVTMP+1
 BNE #45
 INC DIVTMP+2
 BNE #45
 SEC
 RTS

40 INC DIVTMP                      
45 CLC
 RTS



;GETPOS
;   FINDS NEXT FREE POSITION IN MAP BLOCK
; SETS CARRY FLAG IF MAP BLOCK FULL
;
; ON ENTRY
;      MAPGEN POINTS TO START OF MAP BLOCK
;
; ON EXIT
;      MAPGEN POINTS TO NEXT FREE POSITION
;
; USES
;      MPTMPE
;
GETPOS ROUT
 CLC
 LDA MAPGEN
 ADCIM :LSB:MBENTS ;GET MAPGEN TO START OF ENTRIES
 STA MAPGEN
 LDA MAPGEN+1
 ADCIM :MSB:MBENTS
 STA MAPGEN+1
 LDAIM 0
 STA MPTMPE
 STA MPTMPE+1 ;CLEAR VARIABLES
10 LDA MPTMPE
 CMPIM :LSB:(MXENTS-1) ;CHECK FOR END OF LIST
 LDA MPTMPE+1
 SBCIM :MSB:(MXENTS-1)
 BCS #50 ;RETURNS WITH CARRY SET IF END OF LIST
 LDYIM 0 ;Y POINTS AT SIN
 LDAIY MAPGEN
 BNE #30 ;ZERO IS END OF LIST
 INY
 LDAIY MAPGEN
 BNE #30
 INY
 LDAIY MAPGEN 
 BEQ #40
30 CLC ;LOOK AT NEXT ENTRY
 LDA MAPGEN
 ADCIM ENSZ
 STA MAPGEN
 BCC #35
 INC MAPGEN+1
35 INC MPTMPE ;MPTMPE HOLDS NUMBER OF ENTRIES WE'VE LOOKED AT
 BNE #10
 INC MPTMPE+1
 JMP #10

40 CLC
50 RTS ;RETURNS HERE WITH CARRY CLEAR, ALL OK, SET IF NOT.

; GET CYLINDER MAP POSITION
;
; STARTS A SEARCH FROM MPTMPC FOR THE NEXT
; CYLINDER WITH A FREE SECTOR
;
; ON ENTRY
;     MPTMPC HOLDS THE CURRENT CYLINDER
;     MAPGEN POINTS TO START OF CYLINDER MAP
;     MAPPTR POINTS TO MABTB ENTRY
;
; ON EXIT
;     MAPGEN POINTS TO CYLINDER WITH FREE ENTRY
;
; USES  MPTMPE

GTCYPS ROUT
 LDA MPTMPC
 STA MPTMPE ;SAVE CURRENT POSITION
 LDA MPTMPC+ 1
 STA MPTMPE+ 1
 CLC
 LDA MAPGEN ;POINT TO START OF MAP
 ADCIM  3
 STA MAPGEN
 BCC #10
 INC MAPGEN+ 1
10 LDA MPTMPE ;CHECK IF POSITION FOUND
 ORA MPTMPE+ 1
 BEQ #40
 CLC
 LDA MAPGEN
 ADCIM  2 ;FOR NEXT ENTRY
 STA MAPGEN
 BCC #20
 INC MAPGEN+ 1
20 LDA MPTMPE
 BNE #30
 DEC MPTMPE+ 1
30 DEC MPTMPE
 JMP #10
40 LDA MPTMPC
 STA MPTMPE
 LDA MPTMPC + 1
 STA MPTMPE + 1
50 LDYIM  0 ;NOW LOOK FOR POSITION WITH FREE BLOCK
 LDAIY MAPGEN
 INY
 ORAIY MAPGEN
 BNE #90 ;FOUND IF NON ZERO
 INC MPTMPE
 BNE #60
 INC MPTMPE+ 1
60 LDA MPTMPE
 LDYIM MPNOCY ;CHECK FOR END OF CYCLINDER MAP
 CMPIY MAPPTR
 INY
 LDA MPTMPE+ 1
 SBCIY MAPPTR
 BCS #80
 LDAIM 2
70 CLC ;NOT END SO LOOK AT NEXT ENTRY
 ADC MAPGEN
 STA MAPGEN
 BCC #50
 INC MAPGEN + 1
 JMP #50
80 LDAIM  0 ;END SO BACK TO BEGINNING
 STA MPTMPE
 STA MPTMPE+ 1
 LDYIM MPCYMP
 LDAIY MAPPTR ;GET START OF CYLINDER MAP
 STA MAPGEN
 INY
 LDAIY MAPPTR
 STA MAPGEN + 1
 LDAIM 3
 BNE #70
90 RTS


; FIND CYLINDER
;
; FINDS THE CYCLINDER WITH THE LARGEST AMOUNT
; OF FREE SPACE
;
; ON ENTRY
;     MPCYPT POINTS TO START OF CYLINDER MAP
;
; ON EXIT
;     MPCYPT POINTS TO CYLINDER FOUND
;
; USES  MAPTMP MPTMPA MPTMPB

FNDCY ROUT
 LDAIM 0
 STA MAPTMP ;ZERO VALUES
 STA MAPTMP+1
 STA MPTMPA
 STA MPTMPA+1
 STA MPTMPC
 STA MPTMPC+1
 CLC
 LDA MPCYPT ;GET TO START OF ENTRIES
 ADCIM 3
 STA MPCYPT
 STA MPTMPB
 LDA MPCYPT+1
 ADCIM 0
 STA MPCYPT+1
 STA MPTMPB+1
10 LDYIM 0 ;NOW SCAN ENTRIES FOR LARGEST
 LDA MAPTMP
 CMPIY MPCYPT
 INY
 LDA MAPTMP+1
 SBCIY MPCYPT ; MAPTMP HOLDS LARGEST SO FAR
 BCS #20 ;BRANCH IF NOT LARGER
 LDAIY MPCYPT
 STA MAPTMP+1
 DEY
 LDAIY MPCYPT
 STA MAPTMP
 LDA MPCYPT ;SAVE POSITION
 STA MPTMPB
 LDA MPCYPT+1
 STA MPTMPB+1
 LDA MPTMPA
 STA MPTMPC ;SAVE CYLINDER NUMBER
 LDA MPTMPA+1
 STA MPTMPC+1
20 CLC
 LDA MPCYPT ;MOVE TO NEXT ENTRY
 ADCIM 2
 STA MPCYPT
 BCC #25
 INC MPCYPT+1
25 INC MPTMPA
 BNE #30
 INC MPTMPA+1
30 LDYIM MPNOCY ;CHECK FOR END OF MAP
 LDAIY MAPPTR
 CMP MPTMPA
 BNE #10
 INY
 LDAIY MAPPTR
 CMP MPTMPA+1
 BNE #10
 LDA MPTMPB ;END SO RETURN POINTER
 STA MPCYPT
 LDA MPTMPB+1
 STA MPCYPT+1
 RTS

; RETURNS THE SIZE OF A BLOCK OF STORE
;
; ON ENTRY
;    MPSCPT POINTS TO BIT MAP
;
; ON EXIT
;    MPTMPD HOLDS THE SIZE
;
; USES MPTMPE
;
SIZE ROUT
 LDYIM MPSPCY
 LDAIY MAPPTR
 STA TMPSPC
 INY
 LDAIY MAPPTR
 STA TMPSPC+1
 LDAIM 0
 STA MPTMPD ;CLEAR VARIABLES
 STA MPTMPD+1
 STA MPTMPE
 STA MPTMPE+1
 LDYIM 0
10 LDAIY MPSCPT
 BEQ #80 ;NO FREE BITS IN THIS PART
 LDXIM 8 ;LOOK AT ALL EIGHT BITS
20 RORA ;GET BIT INTO CARRY
 PHA
 BCC #70 ;CLEAR SO CHECK FOR END
 INC MPTMPD
 BNE #30 ;KEEP A COUNT OF SECTORS
 INC MPTMPD+1
30 INC MPTMPE
 BNE #40
 INC MPTMPE+1 ;AND CHECK HOW MANY BITS WE'VE LOOKED AT
40 JSR TESTME ;**23/1/87** check for end of map
 BCC #60
 LDA MPTMPD
 ORA MPTMPD+1
 BNE #50
48 LDAIM &F6
 JSR INTERR
50 PLA ;GET BIT MAP VALUE BACK
55 RTS

60 PLA
 DEX
 BNE #20
65 INY
 JMP #10

70 LDA MPTMPD
 ORA MPTMPD+1
 BNE #50 ;END IF ALREADY SOME COUNT
 BEQ #30

80 LDA MPTMPD
 ORA MPTMPD+1
 BNE #55
 CLC
 LDA MPTMPE
 ADCIM 8 ;LOOK AT NEXT BYTE OF MAP
 STA MPTMPE
 BCC #85
 INC MPTMPE+1
85 JSR TESTME ;**23/1/87** test for end of map
 BCC #65
 BCS #48

; FILL BLOCKS
;    ALLOCATES REST OF BLOCKS THAT ARE REQUIRED
;
; ON ENTRY
;      DIVTMP HOLDS SIZE
;      MPSCPT POINTS TO CURRENT BIT MAP
;      MPTMPC HOLDS CYLINDER NUMBER
;      MAPTMP POINTS TO MAP BLOCK
;      MAPPTR POINTS TO MAP TABLE
;      MPCYPT POINTS TO POSITION IN CYLINDER MAP
;
; ON EXIT
;      C SET IF FAILED
;

FLBLKS ROUT
 LDA DIVTMP ;CHECK IF ALL BLOCKS ALLOCATED
 ORA DIVTMP+1
 ORA DIVTMP+2
 BEQ #40
 JSR GETBIT ;FIND FIRST FREE BLOCK
 BCS #10 ;NONE LEFT SO GET NEXT TRACK
 JSR ABLKS ;ALLOCATE THESE BLOCKS
 BCC FLBLKS ;KEEP ALLOCATING BLOCKS UNTIL NONE LEFT
 LDA ERRTYP
 BEQ #10
00 SEC
 RTS

10 INC MPTMPC
 BNE #20
 INC MPTMPC+1
20 LDA MPTMPC ;GET NEXT BIT MAP
 LDYIM MPNOCY ; CHECK FOR END
 CMPIY MAPPTR
 INY
 LDA MPTMPC+1
 SBCIY MAPPTR
 BCS #30
 CLC
 LDA MPCYPT ;KEEP CYLINDER MAP POINTER UP TO DATE
 ADCIM 2
 STA MPCYPT
 BCC #25
 INC MPCYPT+1
25 LDYIM 0
 LDAIY MPCYPT
 INY
 ORAIY MPCYPT
 BEQ #10
 JSR RDBTMP ; GET THE BIT MAP
 BNE #00 ;**23/2/87** Failed
 BEQ FLBLKS ; KEEP TRYING TO ALLOCATE

30 LDAIM 0
 STA MPTMPC ;GO BACK TO THE BEGINNING
 STA MPTMPC+1
 LDYIM MPCYMP ;RETURN CYLINDER MAP TO BEGINNING
 CLC
 LDAIY MAPPTR
 ADCIM 1
 STA MPCYPT
 INY
 LDAIY MAPPTR
 ADCIM 0
 STA MPCYPT+1
 JMP #20

40 CLC ;INDICATE OK
 RTS

;
; GET BIT
;   FINDS THE FIRST FREE BIT IN THE BIT MAP
;
; ON ENTRY
;     MPSCPT POINTS TO BIT MAP
;
; ON EXIT
;     MPTMPE HOLDS BIT NUMBER
;     C SET IF NOT BITS FOUND
;
GETBIT ROUT
 LDYIM MPSPCY
 LDAIY MAPPTR
 STA TMPSPC
 INY
 LDAIY MAPPTR
 STA TMPSPC+1
 LDYIM 0
 STY MPTMPE
 STY MPTMPE+1
10 LDAIY MPSCPT ; GET BYTE OF BIT MAP
 BEQ #40 ; IF NONE FREE GET NEXT BYTE
20 RORA ; ROTATE UNTIL BIT FOUND
 BCS #50 ; BRANCH WHEN FOUND
 INC MPTMPE ;KEEP TRACK OF WHERE WE ARE
 BNE #30
 INC MPTMPE+1
30 PHA
 JSR TESTME ;CHECK FOR END OF ENTRY
 PLA
 BCC #20
40 CLC
 LDA MPTMPE ;ADD 8 FOR THIS BYTE
 ADCIM 8
 STA MPTMPE
 BCC #45
 INC MPTMPE+1
45 INY
 JSR TESTME ; CHECK FOR END OF BIT MAP
 BCC #10
 SEC ;WHEN NONE FOUND
 RTS

50 CLC
 RTS

;
; CHECK FOR END OF BIT MAP
;
TESTME LDA MPTMPE
 CMP TMPSPC
 LDA MPTMPE+1
 SBC TMPSPC+1
 RTS
;
; CORRECT THE CURRENT FREE BLOCK COUNT
;
; ON ENTRY
;     MPTMPB HOLDS NUMBER OF BLOCKS
;     MPTMPC HOLDS CYLINDER NUMBER
;     MAPPTR POINTS TO MAP TABLE ENTRY
;
; USES MAPGEN
;
ADDFR ROUT
 LDYIM MPCYMP
 LDAIY MAPPTR
 STA MAPGEN
 INY
 LDAIY MAPPTR
 STA MAPGEN+1 ;GET POINTER TO CYLINDER MAP
 LDYIM  0
 CLC
 LDAIY MAPGEN ;ADD TO FREE COUNT AT START
 ADC MPTMPB
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADC MPTMPB+1
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADC MPTMPB+2
 STAIY MAPGEN
 CLC ; NOW FOUND CYLINDER POSITION
 LDA MAPGEN
 ADCIM 3 ;START OF ENTRIES
 STA MAPGEN
 BCC #05
 INC MAPGEN+1
05 LDA MPTMPC
 ORA MPTMPC+1
 BEQ #40
 LDX MPTMPC
 LDY MPTMPC+1
 JMP #20

10 CLC
 LDA MAPGEN
 ADCIM 2
 STA MAPGEN
 BCC #20
 INC MAPGEN+1
20 CPXIM 0
 BEQ #30
 DEX
 JMP #10

30 CPYIM 0
 BEQ #40
 DEX
 DEY
 JMP #10

40 LDYIM 0
 CLC ;NOW ADD THE NEW VALUES
 LDAIY MAPGEN
 ADC MPTMPB
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADC MPTMPB+1
 STAIY MAPGEN
 RTS

MPMKFR ROUT
 LDAIY ARGPTR ;form zero page pointer from supplied info
 STA GENPTR
 INY
 LDAIY ARGPTR
 STA GENPTR+1
10 RTS

MPSETF TAX
 BNE #10 ;non-zero => dont update the free store
 JSR MPMKFR
 CLC
 TAX
 LDA GENPTR
 ADCIM UTUSID
 LDYIM ARGB
 STAIY NEWARG
 INY
 BCC #20
 INX
20 TXA
 STAIY NEWARG

 LDXIM :LSB:-4
30 INY
 LDAAX MPNWFR-:LSB:-4 ;write calculated new free space
 STAIY NEWARG
 INX
 BNE #30
 LDAIM 9
 JSR SETRTN
 JMP USRMAN

MPsetd ROUT ;**8/5/87** Copy ARGD into MPTMPA
 LDYIM ARGD
 LDAIY ARGPTR
 STA MPTMPA
 INY
 LDAIY ARGPTR
 STA MPTMPA+1
 INY
 LDAIY ARGPTR
 STA MPTMPA+2
 INY ;exit with Y=ARGG
 RTS

MPFRAD ROUT
 JSR MPMKFR ;setup pointer
 JSR RDmpbd ;**8/5/87** Read block at ARGD
 BNE #30 ;exit

 LDA MAPTMP
 STA MPMBPT
 LDA MAPTMP+1
 STA MPMBPT+1
 JSR MPGTSZ

 LDXIM :LSB:-3
 LDYIM UTFREE
 CLC

20 LDAIY GENPTR
 ADCAX MPTMPA-:LSB:-3
 STAAX MPNWFR-:LSB:-3 ;save it away
 INY
 INX
 BNE #20

;deal with extra length byte

 LDAIY GENPTR
 ADCIM 0 ;'cos size only three bytes
 STAAX MPNWFR+3

 TXA ;return ok
30 RTS

 LNK UADE12
