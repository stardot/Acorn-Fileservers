 OPT UADE03 ;FILE > Uade03
 TTL File server file UADE03


;**********************************
;*        U T I L I T I E S       *
;**********************************

ENPT
 CMPIM 1
 BEQ START
 RTS
 NOP
 = &60
 = COPYRIGHT
 = 0 ;SOFTWARE VERSION NUMBER
 = "Winchester File Server"
COPYRIGHT
 = 0,"(C) 1984 Acorn",CR,0

; & ENPT
; & 0

START

 JSR VSTRIN
 =  22, 7 ;select mode 7
 = CR,"Acorn File Server Level "
VERSN = "3 Version 1.",VERLA,VERLB,CR
 = 21,"Version string",6 ;software protection 
 = "   File server station "

 NOP               ;Print station number LH 21/10/85
 LDAIM &08
 STA &0100
 LDAIM &13
 LDXIM &00
 LDYIM &01
 JSR OSWORD
 LDA &0101
 JSR MKDEC
 JSR PRTMC2

 JSR VSTRIN
 = 28, 0, 21, 39, 4 ;define a window
 NOP
 LDXIM WCMD
 LDYIM /WCMD
 JSR OSCLI
 LDXIM WDCMD
 LDYIM /WDCMD
 JSR OSCLI
 

 JMP STRTFS ; .. here we go ..

DOBRK JSR CURSON
 JSR VSTRIN
 = 28,0,23,39,0
 NOP

;ammended BRK handling ** 30/9/84 **
 PLA ;get P
 PLA
 STA BRKPTR
 PLA ;get address from stack
 STA BRKPTR+1 ;standard places to put them

 LDYIM 0
DOBRKA LDAIY BRKPTR
 BEQ DOBRKB
 JSR OSASCI ;print the error message
 INY
 BNE DOBRKA 

DOBRKB JMP TSTART

SETBRK ;Store old value of BRKVEC
;and set new value to X/Y
;
;Called from MAPMAN and CONVERT block read routine

 LDA BRKVEC
 STA OLDBRK
 LDA BRKVEC + 1
 STA OLDBRK + 1
SETBK1 SEI
 STX BRKVEC
 STY BRKVEC + 1
 CLI
 RTS

WCMD = "ADFS",CR ;SET WINCHESTER FILING SYSTEM
WDCMD = "DIR :0",CR ;SELECT DRIVE ZERO
PROT = 5,MASK ;SET PROTECTION except USER procedure

TRACE
 [ DEBUG > 0
 PHA
 LDAIM DEBUG
 BEQ TRACEX
 PLA
 JMP OSWRCH

TRACEX PLA
 ]
 RTS



;I N P U T - O U T P U T  R O U T I N E S

ISDCHA

;Returns CC if digit or char.

 PHA
 CMPIM "0"
 BCC ISCHER ;Fail
 CMPIM "9" + 1
 BCC ISCHEX ;Succeed
 PLA ;Now check if is char.

ISCHAR

;Returns CC if is alpha (upper or lower)

 PHA
 ANDIM &DF
 CMPIM "A"
 BCC ISCHER ;=> char < A
 CMPIM "Z" + 1
 BCC ISCHEX ;=> char => Z
ISCHER SEC
ISCHEX PLA
 RTS


OSECHO JSR OSRDCH
 BCC OSECH1
 LDAIM &7E ;escape found so ack and return bad char
 JMP OSBYTE
OSECH1 JMP OSASCI ;read & echo a char

VSTRIN PLA
 STA VSTPTR
 PLA
 STA VSTPTR + 1
 LDYIM  0
VSTRLP INC VSTPTR
 BNE INCPX
 INC VSTPTR + 1
INCPX LDAIY VSTPTR
 BMI VSTRNX
 JSR OSASCI
 JMP VSTRLP
VSTRNX JMI VSTPTR ;continue execution


WHEX PHP   ;WRITE A AS TWO HEX DIGITS
 PHA
 LSRA
 LSRA
 LSRA
 LSRA
 JSR WHEXD
 PLA
 PHA
 ANDIM &F
 JSR WHEXD
 PLA
 PLP
 RTS


WHEXD CMPIM 10
 BMI WHEXLA
 CLC
 ADCIM 7
WHEXLA ADCIM "0"
 JMP OSWRCH


;THE FOLLOWING ROUTINES READ A LINE OF TEXT
;TYPED AT A KEYBOARD INTO THE COMMAND LINE BUFFER (DOS=256)
;THE PAGE ZERO REGISTER COMPTR IS USED TO POINT
;INTO THE INPUT BUFFER.
;THE INDEX REGISTER Y IS USED TO REFER TO
;CHARACTERS IN THE INPUT BUFFER.
;THE ROUTINE GETINT READS CHARS FROM INPUT BUFFER
;AND CONVERTS THEM INTO INTEGERS (PLACED IN INTEGR).


SETCOM LDAIM  0 ;COMPTR := ADDR OF INPUT BUFFER
 STA COMPTR
 LDAIM  1
 STA COMPTR + 1
 RTS


INCCOM INC COMPTR ;COMPTR +:= 1
 BNE INCCMZ
 INC COMPTR + 1
INCCMZ RTS


RDLINE JSR SETCOM
 LDAIM &86
 JSR OSBYTE
 STX OFF1
 JSR CURSON
 LDXIM RDLNBK
 LDYIM /RDLNBK
 LDAIM 0
 JSR OSWORD
 BCC RDLINZ
 LDAIM &7C
 JSR OSBYTE
 LDAIM &86
 JSR OSBYTE
 SEC
 TXA
 SBC OFF1
 TAY
RDLNLP CPYIM 0
 BEQ RDLINE
 STY OFF1
 JSR VSTRIN
 = 8,32,8
 NOP
 LDY OFF1
 DEY
 JMP RDLNLP
RDLINZ JMP CURSOF
;
RDLNBK = 0,1,40,32,&80
;

;Turn Cursor On
;
CURSON JSR VSTRIN
 = 23,1,1,0,0,0,0,0,0,0
 NOP
 RTS

;Turn Cursor off
;
CURSOF JSR VSTRIN
 = 23,1,0,0,0,0,0,0,0,0
 NOP
 RTS


;GETINT: READ A DECIMAL INTEGER INTO INTEGR.
;NOTE COMPTR IS LEFT POINTING TO THE CHARACTER
;FOLLOWING THE INTEGER.
;EXIT: A = RC (<>0 => NOT A DECIMAL INTEGER)

GETINT LDYIM  0
 TYA
 STA TEMPB ;TEMPB := CHAR COUNT
 STA INTEGR
 STA INTEGR + 1 ;INTEGR := 0

GETITA LDAIY COMPTR
 CMPIM "0"
 BCC GETITC
 CMPIM ":" ;(':='9+1)
 BCC GETITF
GETITC LDA TEMPB ;FIRST CHAR ?
 BNE GETITK
 LDAIM IERRAH
 BNE GETITZ
GETITF SEC
 SBCIM "0"
 PHA  ;PUSH DIGIT
 INC TEMPB ;TEMPB +:= 1
 LDA INTEGR
 ASLA
 STA TEMPA
 LDA INTEGR + 1
 ROLA
 STA TEMPA + 1 ;TEMPA := INTEGR * 2
 LDXIM  3
GETITH LDA INTEGR
 ASLA
 STA INTEGR
 LDA INTEGR + 1
 ROLA
 STA INTEGR + 1
 DEX
 BNE GETITH ;INTEGR * 8
 CLC
 LDA INTEGR
 ADC TEMPA
 STA INTEGR
 LDA INTEGR + 1
 ADC TEMPA + 1
 STA INTEGR + 1
 CLC
 PLA  ;PULL DIGIT
 ADC INTEGR
 STA INTEGR
 LDA INTEGR + 1
 ADCIM  0
 STA INTEGR + 1
 JSR INCCOM ;COMPTR +:= 1
 JMP GETITA

GETITK LDAIM  0 ;RC:= 0
GETITZ RTS


USRERR   ;USRERR
 PHA
 JSR OSCRLF
 PLA
 JSR LOOKER ;Get error msg. in MIDTX
 LDXIM  0
USRERL LDAAX MIDTX
 JSR OSASCI
 INX
 CMPIM CR
 BNE USRERL
 RTS





;E R R O R  H A N D L I N G



;STOP: THIS ROUTINE BRINGS THE FILE
;SERVER TO A GRACEFULL HALT.
;IT PUSHES, ONTO THE HARDWARE
;STACK, P,A,X,Y AND REMEMBERS
;THE VALUE OF THE STACK PTR IN
;STKPTR (SEE HEADER FILE).


STOP PHP  ;PUSH P,A,X,Y REMEMBER STK PTR
 PHA
 TXA
 PHA
 TYA
 PHA
 TSX
 STX STKPTR
 [ 1=0
 BRK
STOPER = &00,CR,"STOP",CR
 = 0
 |
 JSR OSCRLF
 JMP TSTART ;cant use BRK cos it's intercepted ** 28/9/84 **
 ]

INTERR PHP
 PHA
 TXA
 PHA
 TYA
 PHA
; STA STOPER
 JSR VSTRIN
 = CR,"FS internal error #"
 NOP
 PLA
 TAY
 PLA
 TAX
 PLA
 PLP
 JSR WHEX
 JSR VSTRIN
 = CR,"AT ADDRESS "
 NOP
 PLA
 TAX
 PLA
 JSR WHEX
 TXA
 JSR WHEX
 JMP STOP




;COMPAR: COMPARE TWO AREAS OF STORE,
;BYTE-BY-BYTE.

;ENTRY: MOVFRM = PTR TO 1ST AREA
;MOVTO  = PTR TO 2ND AREA
;X      = NO. OF BYTES TO BE COMPARED

;EXIT: A = 0 IF IDENTICAL
;<>0 IF NOT IDENTICAL
;N.B. STATE BITS (Z ETC) ARE ALSO SET.
;NOTE X,Y,A ARE DESTROYED.


COMPAR TXA
 TAY
COMPRA DEY
 LDAIY MOVFRM
 CMPIY MOVTO
 BNE COMPRZ
 DEX
 BNE COMPRA
COMPRZ TXA
 RTS




;F R E E  S P A C E  M A N A G E M E N T


;SPACE IS ALLOCATED FROM A
;CONTIGUOUS AREA OF MEMORY. N.B.
;THAT SPACE CANNOT BE RETURNED TO
;THE FREE POOL.


;GETVEC: RETURNS A POINTER TO A FREE
;AREA OF MEMORY.
;THE PAGE ZERO POINTER,
;FREPTR POINTS TO THE BEGINNING
;OF FREE SPACE.


;ENTRY: Y,X = SIZE (Y=LS)
;EXIT: Y,X = PTR TO VECTOR

;FUNCTION:-

;IF FREPTR+SIZE > ENDPTR
;THEN ERROR(INSUFFICENT SPACE)
;ELSE FREPTR +:=:= SIZE
;FI

GETVEC TYA  ;FIRST CHECK THAT SIZE REQUESTED <> 0
 STX GVWRKA
 ORA GVWRKA
 BNE GVEC1
 LDAIM IERRAF ;SIZE = 0
 JSR INTERR
GVEC1 CLC
 TYA
 ADC FREPTR
 STA GVWRKA ;GETVEC WORK VARIABLE A
 TXA
 ADC FREPTR + 1
 STA GVWRKA + 1
 BCC CHECKS
 LDAIM IERRAD ;X,Y TOO BIG!
 JSR INTERR
CHECKS LDA ENDPTR ;IS GVWRKA > ENDPTR
 CMP GVWRKA
 LDA ENDPTR + 1
 SBC GVWRKA + 1
 BCS OK
 LDAIM IERRAE ;INSUFFICIENT SPACE
 JSR INTERR
OK LDY FREPTR
 LDX FREPTR + 1
 LDA GVWRKA
 STA FREPTR
 LDA GVWRKA + 1
 STA FREPTR + 1
 RTS


;CLRSTR: CLEARS A SPECIFIED STORE AREA TO ZERO.

;ENTRY:- CLRPTR (PAGE ZERO) = START ADDRESS
;X,Y = NUMBER OF BYTES (Y=LS)
;NOTE A & TEMPA ARE DESTROYED BY THIS RTN

CLRSTR LDAIM  0
 STA TEMPA + 1
 STY TEMPA
 CPYIM  0
 BEQ CLC
CLB DEY
 STAIY CLRPTR
 BNE CLB
CLC CPXIM  0
 BEQ CLD
 CLC
 LDA CLRPTR
 ADC TEMPA
 STA CLRPTR
 LDA CLRPTR + 1
 ADC TEMPA + 1
 STA CLRPTR + 1
 LDYIM  1
 STY TEMPA + 1
 LDAIM  0
 TAY
 STY TEMPA
 DEX
 JMP CLB
CLD RTS


;MOVBLK: MOVE DATA FROM PTR AT X OFFSET BY OFF1, TO
;        PTR AT Y OFFSET BY OFF2. A CONTAINS THE AMOUNT
;        TO MOVE. USEFUL FOR MOVING TO AND FROM THE STACK
;        TO TABLES IN DYNAMIC AREA.
;

MOVBLK

 PHA  ;Push amount to move
 CLC
 LDAAX  0
 ADC OFF1
 STA MOVFRM ;Set "from" pointer
 LDAAX  0001
 ADCIM  0
 STA MOVFRM + 1

 CLC
 LDAAY  0
 ADC OFF2 ;Set "to" pointer
 STA MOVTO
 LDAAY  0001
 ADCIM  0
 STA MOVTO + 1

 PLA
 TAX  ;Set length for MOVE

;And drop into MOVE

;MOVE: MOVE DATA FROM ONE AREA OF MEMORY TO A NEW AREA
;N.B. DATA AREAS SHOULD NOT OVERLAPP!!!!!

;ENTRY: MOVFRM - PAGE ZERO FROM ADDRESS
;MOVTO  - PAGE ZERO TO ADDRESS
;X       - AMOUNT TO BE MOVED

;NOTE THAT A,X,Y ARE DESTROYED BY THIS ROUTINE


MOVE LDYIM  0
 TXA
 BEQ MOVEXX ;If zero to move, exit

MOVEA LDAIY MOVFRM
 STAIY MOVTO
 INY
 DEX
 BNE MOVEA
MOVEXX RTS


;MRKDRT: MARK A STORE BUFFER DIRTY

;ENTRY: GENPTR => STORE ADDRESS OF BUFFER

;SAVED: A,X,Y
;DESTROYED: GENPTR


MRKDRT PHA  ;PUSH A
 TYA
 PHA  ;PUSH Y
 JSR DCGEN ;INITITIALISE GENPTR & Y
 LDAIM DIRTY
 STAIY GENPTR
 PLA
 TAY  ;PULL Y
 PLA  ;PULL A
 RTS


;MRKCLE: MARK A STORE BUFFER CLEAN

;ENTRY: GENPTR => STORE ADDR OF BUFFER
;SAVED: A,X,Y
;DESTROYED: GENPTR

;MRKCLE PHA  ;PUSH A
 TYA
 PHA  ;PUSH Y
 JSR DCGEN ;INITIALISE GENPTR & Y:=0
 TYA
 STAIY GENPTR
 PLA
 TAY  ;PULL Y
 PLA  ;PULL A
 RTS


DCGEN SEC
 LDA GENPTR
 SBCIM  1
 STA GENPTR
 LDA GENPTR + 1
 SBCIM  0
 STA GENPTR + 1
 LDYIM  0
 RTS




;I N T E R  M O D U L E  C O M M U N I C A T I O N


;ARGUMENTS ARE PASSED AROUND ON
;A SOFTWARE STACK. WHEN IN A
;MODULE ARGUMENTS SETUP BY THE
;CALLER (AND THOSE TO BE PASSED
;BACK) ARE POINTED TO BY THE
;PAGE ZERO REGISTER, ARGPTR.
;PARAMETERS FOR THE NEXT MODULE
;TO BE CALLED ARE POINTED TO BY
;THE PAGE ZERO REGISTER, NEWARG.
;THE POSN OF NEWARG RELATIVE TO
;ARGPTR IS SET BY THE SETFS ROUTINE.
;SETFS MUST BE CALLED
;BEFORE A MODULE IS CALLED.



;SETFS: SET FRAME SIZE. THIS RTN
;SETS UP THE CORRECT VALUE
;OF THE PAGE ZERO POINTER,
;NEWARG.
;ON ENTRY A = NUMBER OF ARGUMENT
;STACK POSNS TO BE SET ASIDE.
;IT ALSO PLACES ZERO IN THE REMEMBER ENTRY REASON SLOT.


;FUNCTION:-

;NEWARG  := ARGPTR+A+FINFO
;[NEWARG] := A+FINFO
;[NEWARG+ENTRES] := 0



SETFS CLC
 ADCIM FINFO ;A:=FINFO+A
 BCC SETFSA
 LDAIM IERRAA ;FRAME SIZE TOO BIG
 JSR INTERR ;INTERNAL ERROR
SETFSA PHA  ;PUSH A
 ADC ARGPTR ;A:=A+LS(ARGPTR)
 STA NEWARG ;LS(NEWARG) := A
 LDA ARGPTR + 1 ;A:=MS(ARGPTR)
 ADCIM  0
 STA NEWARG + 1 ;MS(NEWARG):=A
 PLA  ;PULL ACCUMULATOR
 LDYIM FRAMSZ ;Y:=POSN OF FRAME SIZE INFO
 STAIY NEWARG ;[NEWARG] :=A
 LDYIM ENTRES ;Y:= POSN OF ENTRY REASON TO BE REMEMBERED
 LDAIM  0
 STAIY NEWARG ;ENTRY REASON := 0 AT THE MOMENT
 RTS



;ENTRY: THIS RTN MUST BE CALLED ON
;EVERY ENTRY TO A MODULE. IT
;CHECKS THAT THE ENTRY CODE
;0 < (ARG0) >= A.  IT ALSO PLACES
;THE NAME OF THE CALLED MODULE
;AND THE VALUE OF ARGA (THE ENTRY REASON)
;ON THE ARGUMENT STACK (THIS IS USEFUL WHEN DEBUGGING).

;ON ENTRY:-

;X = NUMB OF MODULE ENTRY POINTS
;A= NUMBER OF MODULE

;FUNCTION:-

;ARGPTR := NEWARG
;X := JUMP TABLE OFFSET
;NEWARG := $FFFF (SHOULD BE SET BY SETFS RTN)



ENTRY LDYIM MODNME
 STAIY NEWARG ;PUSH NAME OF CALLED MODULE ON ARG STACK
 TXA  ;A:= NUMBER OF EXPECTED ENTRY POINTS
 LDYIM ARGA ;Y:=ARGA
 CMPIY NEWARG
 BPL ENTRYA
 LDAIM IERRAC ;UNKNOWN ENTRY REASON
 JSR INTERR
ENTRYA LDAIY NEWARG ;A:=[NEWARG+ARGA]
 BNE ENTRYB
 LDAIM IERRAB ;FUNCTION CODE = 0
 JSR INTERR

;NOW MAKE ARGPTR := NEWARG

ENTRYB LDA NEWARG ;A:= LS(NEWARG)
 STA ARGPTR ;LS(ARGPTR):=A
 LDA NEWARG + 1 ;A:=MS(NEWARG)
 STA ARGPTR + 1 ;MS(ARGPTR):=A
;NOW WORKOUT JUMP TABLE OFFSET
 LDAIY ARGPTR
 LDYIM ENTRES
 STAIY ARGPTR ;COPY OF ARGA (THE ENTRY REASON)
 STA ENWRKA ;ENWRKA:=[ARGPTR+ARGA]
 DEC ENWRKA ;ENWRKA -:= 1
 ASL ENWRKA ;ENWRKA *:= 2
 LDX ENWRKA ;X := JUMP TABLE OFFSET
 LDAIM &FF
 STA NEWARG
 STA NEWARG + 1 ;NEWARG := $FFFF
 RTS



;EXIT: THIS RTN SHOULD BE
;CALLED BY EVERY MODULE, JUST
;BEFORE IT RETURNS TO ITS CALLER.

;FUNCTION:-

;NEWARG := ARGPTR
;ARGPTR := ARGPTR-[ARGPTR]
;A := [NEWARG+ARGA]
;Y := ARGA

EXIT LDYIM FRAMSZ ;Y:=POSN OF FRAME SIZE INFO
 LDA ARGPTR ;A:=LS(ARGPTR)
 STA NEWARG ;LS(NEWARG):=A
 LDA ARGPTR + 1
 STA NEWARG + 1 ;NOW NEWARG=ARGPTR
 SEC
 LDA ARGPTR ;A:=LS(ARGPTR)
 SBCIY ARGPTR ;A:=A-SIZE OF PREVIOUS STACK FRAME
 STA ARGPTR ;LS(ARGPTR):=A
 LDA ARGPTR + 1 ;A:=MS(ARGPTR)
 SBCIM  0
 STA ARGPTR + 1 ;MS(ARGPTR):=A
 LDYIM ARGA ;Y:=ARGA
 LDAIY NEWARG ;A:=[NEWARG+ARGA] I.E. RETURN CODE
 RTS


PREXIT LDYIM ARGA
 STAIY ARGPTR
 JMP EXIT




;A R I T H M E T I C  R O U T I N E S


MULTBS LDXIM  8 ;BREGA *:= BLKSZE
MBSA ASL BREGA
 ROL BREGA + 1
 ROL BREGA + 2
 DEX
 BNE MBSA
 RTS



 [ 1=0

MULT10 STA TEMPA
 ASLA
 ASLA
 ASLA
 CLC
 ADC TEMPA
 ADC TEMPA
 RTS

 ]



SETTAB   ;SETTAB

;ENTRY: X - NO. OF ENTRIES IN TABLE
;Y - SIZE OF EACH ENTRY

;EXIT:  Y -> TABLE (LO)
;X -> TABLE (HI)

;TABLE IS CLEARED TO ZERO AFTER
;GETTING SPACE FROM GETVEC.

 LDAIM  0
 STA TEMPA
 STA TEMPA + 1
SETTBL CLC
 TYA
 ADC TEMPA
 STA TEMPA
 LDAIM  0
 ADC TEMPA + 1
 STA TEMPA + 1
 DEX
 BNE SETTBL

 LDY TEMPA
 LDX TEMPA + 1
 JSR GETVEC ;*** GET SPACE **
 TYA
 PHA  ;DONT' TRUST CLRSTR WITH X/Y
 TXA
 PHA
 STY CLRPTR
 STX CLRPTR + 1
 LDY TEMPA
 LDX TEMPA + 1
 JSR CLRSTR
 PLA
 TAX
 PLA
 TAY
GETBBX RTS


GETBB LDAIM  7
 LDYIM ARGA
 STAIY NEWARG
 JSR STRMAN  ;Do get big buffer
 BNE GETBBX

 LDXIM  3
 LDYIM ARGE
GETBBL LDAIY NEWARG
 STAAX BBUF ;Set address and size
 DEY
 DEX
 BPL GETBBL
 CLC
 LDA BBUF
 ADC BBSIZE
 STA BBEND ;Set end address
 LDA BBUF + 1
 ADC BBSIZE + 1
 STA BBEND + 1

;declare a new I/O side buffer for file transfers
;Nb 2nd processor FS only
 LDXIM  0
 STX IOBUF ;even page boundary
 LDYIM &FF
 LDAIM  180
 JSR OSBYTE ;read I/O OSHWM

 STX RXBUF + 1 ;ready for i/o routine
 [ 1=0
 STX CODTB1 ;modify table a bit
 STX CODTB4
 ]
 [ ZTIME=0
 STX CODTX4
 STX CODTX7
 STX CODTX8
 ]

 INX ;result returned in X
 STX IOBUF + 1 ;base of buffer

 LDAIM  135
 JSR OSBYTE ;read a char, get screen mode in Y
 TYA
 TAX ;read the bottom of display
 LDAIM  133
 JSR OSBYTE ;result in X,Y

 STX IOEND
 STY IOEND + 1

 SEC
 TXA
 SBC IOBUF
 STA IOBSIZ ;get buffer size
 TYA
 SBC IOBUF + 1
 STA IOBSIZ + 1 ;two bytes

;when reading unwritten sectors of disc, the store must be
;set to zero. This is to be done in the I/o side by a 
;dubious bit of code, called by intercepting the OSBPUT vector
;The code itself is poked over in the following section

 LDXIM &FF

 STX ODSCMN ;illegal value for big buffer cache
 STX ODSCMN + 1

 STX RXBUF + 2
 STX RXBUF + 3 ;high order address
 INX
 STX RXBUF ;lo byte of address, hi byte already set up

 LDAIM 0
 RTS

 [ 1=1

GETBLA LDX RXBUF
 LDAAX CODTAB
 CMPIM &EA
 BEQ GETBLB ;end marker
 STA RXBUF + 4 ;byte to put in
 
 JSR GETBW ;do call
 INC RXBUF 
 BNE GETBLA

GETBLB LDAIM BPUTV
 STA RXBUF
 LDAIM /(BPUTV )
 STA RXBUF + 1
 LDAIM  0
 STA RXBUF + 4 ;data lo
 JSR GETBW
 INC RXBUF
 LDA CODTB1
 STA RXBUF + 4 ;data hi
 JSR GETBW

 [ ZTIME=0
 LDAIM &0216
 STA RXBUF
 LDAIM /(&0216 )
 STA RXBUF + 1
 LDAIM CODTX1-CODTAB
 STA RXBUF + 4 ;data lo
 JSR GETBW
 INC RXBUF
 LDA CODTB1
 STA RXBUF + 4 ;data hi
 JSR GETBW
 ]

 RTS

GETBW LDXIM RXBUF
 LDYIM /(RXBUF )
 LDAIM  6
 JMP OSWORD ;call to ammend store

CODTAB = &8D,&0B
CODTB1 = &00 ;ammended to buffer start
 = &8C,&0A
CODTB4 = &00
; STA CODTB2 +%2 ;ammend hi byte of address
; STY CODTB2 +%1 ;ammend hi byte of address
 LDAIM  0
 TAY
CODTB2 STAAY &7C00 ;hi byte ammended 
 INY
 BNE CODTB2
 RTS
;CODTB3 * CODTB2 +%2

 [ ZTIME=0
CODTX6 EORIM &FF ;invert input
 PHA
 LSRA
 LSRA
 LSRA
 LSRA
 = &20 ;JSR
 = . - CODTAB + 3
CODTX4 = &00
 PLA
CODTX2 ANDIM &0F
 ORAIM &30
 CMPIM &3A
 BCC CODTX3
 ADCIM &06
CODTX3 JMP &E0A4 ;call wrch direct

CODTX1 TAX
 BEQ CODTX5
 LDA &FE64
 PHA
 LDA &FE65
 = &20
 = CODTX6-CODTAB
CODTX7 = &00
 PLA
 = &20
 = CODTX6-CODTAB
CODTX8 = &00
 LDAIM &20
 JSR &E0A4
CODTX5 LDAIM  0
 STA &FE6B
 LDAIM &FF
 STA &FE64
 STA &FE65
 RTS
 ]
 NOP ;end marker
 [ ZTIME=0
RDTIME LDAIM &FF
 JMP &FFD7

WRTIME LDAIM  0
 JMP &FFD7
 ]
 ] ;*** 17/9/84

INCGPT INC GENPTR
 BNE INCGPX
 INC GENPTR + 1
INCGPX RTS


MEMTST   ;MEMTST

;First find end of memory. Then test memory
;several times with random numbers and once each
;with %0 and $FF.

 JSR VSTRIN
 = CR,"Testing Memory",CR
 NOP

 LDAIM FRESTR
 STA GENPTR ;NOTE ASSUMES FRESTR ON PAGE BOUNDARY
 LDAIM /(FRESTR )
 STA GENPTR + 1
 LDYIM  0
MEMTLA LDAIM &55
 STAIY GENPTR
 LDAIM &FF
 INY
 STAIY GENPTR ;Clear address lines
 INY
 STAIY GENPTR
 DEY
 DEY
 LDAIY GENPTR
 CMPIM &55
 BNE MEMTLB ;NE if found
 LDX GENPTR + 1
 INX
 STX GENPTR + 1 ;use page sized jumps
 CPXIM &F8 ;look for start of NET code
 BEQ MEMTLB ;stop here
 JMP MEMTLA

MEMTLB DEY
 CLC
 TYA
 STA NEWARG
 LDA GENPTR + 1
 SEC
 SBCIM  1
 STA NEWARG + 1
 JSR VSTRIN
 = CR,"Last free location = "
 NOP
 LDA NEWARG + 1
 JSR WHEX
 LDA NEWARG
 JSR WHEX
 JSR OSCRLF

;NOW TEST MEMORY

 LDAIM &44 ;Set "random number"
 STA COZERO
 LDAIM &55
 STA COZERO + 1
 STA COZERO + 2
 LDAIM  0
 STA ARGPTR ;Use ARGPTR as an error flag
 LDXIM  3
MEMTLC JSR RMTSTA ;Rajdom number test
 DEX
 BNE MEMTLC
 LDAIM  0
 JSR RMTSTB
 LDAIM &FF
 JSR RMTSTB

 LDA NEWARG
 STA MEMEND
 LDA NEWARG + 1
 STA MEMEND + 1
 LDA ARGPTR ;Error flag
 RTS


RMTSTA   ;RMTSTA

;Test from FREPTR to NEWARG using pseudo rand. nos.
;in COZERO +00/01/02

 LDAIM FRESTR
 STA GENPTR
 LDAIM /(FRESTR )
 STA GENPTR + 1

RMTALD LDA COZERO
 STA COZERO + 3 ;Store for checking pass
 LDA COZERO + 1
 STA COZERO + 4
 LDA COZERO + 2
 STA COZERO + 5
 LDYIM  0
RMTALA LDA COZERO
 STAIY GENPTR
 JSR RANDUM
 INY
 BNE RMTALA

;Reset rand. no. and check page.

 LDA COZERO + 3
 STA COZERO
 LDA COZERO + 4
 STA COZERO + 1
 LDA COZERO + 5
 STA COZERO + 2
RMTALB LDA COZERO
 CMPIY GENPTR
 BEQ RMTALC ;OK, continue
 JSR MEMERR
RMTALC JSR RANDUM
 INY
 BNE RMTALB

;Finished testing one page, do next one.

 INC GENPTR + 1
 LDA NEWARG + 1
 CMP GENPTR + 1
 BCS RMTALD ;G/ptr >= NEWARG, continue.
 RTS


RMTSTB   ;RMTSTB

;Test memory using value in A.

 STA COZERO
 LDAIM FRESTR
 STA GENPTR
 LDAIM /(FRESTR )
 STA GENPTR + 1
RMTBLD LDYIM  0
 LDA COZERO
RMTBLA STAIY GENPTR
 INY
 BNE RMTBLA ;Fill a page
RMTBLB LDAIY GENPTR
 CMP COZERO
 BEQ RMTBLC ;OK, continue
 JSR MEMERR
RMTBLC INY
 BNE RMTBLB

 INC GENPTR + 1
 LDA NEWARG + 1
 CMP GENPTR + 1
 BCS RMTBLD
 RTS


RANDUM   ;RANDUM

;Generate next random number

 LDA COZERO
 EORIM  2
 LSRA
 LSRA
 ROR COZERO
 ROR COZERO + 1
 ROR COZERO + 2
 RTS



MEMERR   ;MEMERR

;Print error location and set flag


 PHA
 LDAIM &FF
 STA ARGPTR ;Set error flag
 TYA
 PHA
 JSR VSTRIN
 = "Fails at: "
 NOP

 LDA GENPTR + 1
 JSR WHEX
 CLC
 PLA
 TAY
 ADC GENPTR
 JSR WHEX
 JSR OSCRLF

 PLA
 RTS
 [ DONGLE=1 ; Keep track of days without dongle
INCDAY LDA DATE
 CMPIM 28
 BCS CHMN
JINCD INC DATE
 JMP IDRET
CHMN LDA DATE +1
 ANDIM &F
 CMPIM 2
 BEQ CHLPY
 LDA DATE
 CMPIM 30
 BCC JINCD
 LDXIM 4
 LDA DATE +1
 ANDIM &F
CHMLP CMPAX MW30D - 1
 BEQ THDM
 DEX
 BNE CHMLP
 LDA DATE
 CMPIM 31
 BNE JINCD
THDM LDA DATE +1
 ANDIM &F
 CMPIM 12
 BEQ ICY
 CLC
 ADCIM 1
 TAX
 LDA DATE +1
 ANDIM &F0
 STA DATE +1
 TXA
 ORA DATE +1
 STA DATE +1
 LDAIM 1
 STA DATE
 JMP IDRET
ICY LDA DATE +1
 LSRA
 LSRA
 LSRA
 LSRA
 CLC
 ADCIM 1
 ASLA
 ASLA
 ASLA
 ASLA
 ORAIM 1
 STA DATE +1
 LDAIM 1
 STA DATE
 JMP IDRET
CHLPY LDA DATE
 CMPIM 29
 BEQ THDM
 LDA DATE +1
 LSRA
 LSRA
 LSRA
 LSRA
 CLC
 ADCIM BASEYR
 ANDIM &3
 BNE THDM
 JMP JINCD
IDRET JMP PRDTE
 ]                                              

MW30D = 4,6,9,11

JUSINF ;pass userinfo pointer to CHANGESIZE

 LDYIM ARGB
 LDAIY ARGPTR
 TAX
 INY
 LDAIY ARGPTR

 LDYIM ARGK
 STAIY NEWARG
 DEY
 TXA
 STAIY NEWARG
 RTS ;** 3/10/84 **

 LNK UADE04
