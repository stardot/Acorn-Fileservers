 OPT UADE02 ; > Uade02
 TTL File server file UADE02

;**********************************
;*    H E A D E R  F I L E  2     *
;**********************************

BRKVEC * &202
BPUTV * &218
TSTART * &F800

;*** USRMAN MANIFESTS ***
;USERTB OFFSETS
UTMCNO *  0 ;START OF 2 BYTE MACHINE NO
UTUSID * UTMCNO + 2 ;START OF USERID
UTDISC * UTUSID +MAXUNM+1 ;CURRENTLY SELECTED DISC NUMBER
UTPRIV * UTDISC + 2 ;SYSTEM PRIVILEGE & INUSE FLAG
UTHSLD * UTPRIV + 1 ;HANDLE FOR SELECTED DIR
UTHNDB * UTHSLD + 1 ;BYTE INDICATING HANDLES IN USE PER MC
UTFREE * UTHNDB + 1 ;User disc space allocation ** 2/10/84 **
UTFRLN * 4 ;length of free space counter
UTENSZ * UTFREE + UTFRLN ;SIZE OF A USERTB ENTRY
USRLIM * MAXUSE + 1 ;MAX 40 USERS FOR NOW **
OPTMSK * &F ;Mask for user option bits
NTOPT * &F0 ;Complement of OPTMSK


;*** STRMAN MANIFESTS ***
;CACHE ENTRY DESCRIPTOR OFFSETS
CEDISC *  0 ;DISC NO
CESIN * CEDISC + 2 ;SIN OF OBJECT
CEBKNO * CESIN + 3 ;START BLOCK NUMBER IN OBJECT
CEBLKS * CEBKNO + 2 ;NUMBER OF BLOCKS OCCUPIED BY WINDOW
CESTA * CEBLKS + 2 ;STORE ADDRESS OF OBJECT
CERCNT * CESTA + 2 ;REFERENCE COUNT
CEAGE * CERCNT + 1 ;AGE FOR LRU REPLACEMENT ALGORITHM
CENEXT * CEAGE + 1 ;PTR TO NEXT DESCRIPTOR
CESIZE * CENEXT + 2 ;SIZE OF A DESCRIPTOR
;THE ADDRESS OF DIRTY FLAG IS = STORE ADDRESS OF WINDOW - 1

;STRMAN BUFFER SIZE
LGBFSZ * 5 * BLKSZE ;SIZE OF A LARGE BUFFER(MUST BE MULTIPLE OF BLKSZE)
;** 6/12/84 **

;BUFFER AGES
LRU *  1 ;=> LEAST RECENTLY USED
MRU * &FF ;=> MOST RECENTLY USED

;*** DIRMAN MANIFESTS ***
;DIRECTORY OFFSETS
;(HEADER INFORMATION)
;NOTE THAT A ONE BYTE SEQUENCE NUMBER (INCREMENTED WHEN
;WRITING A DIR TO DISC) BRACKETS A DIRECTORY.
;THE LEADING SEQUENCE NUMBER GOES AT BYTE OFFSET 2
;AND THE TRAILING SQ NO IS THE LAST BYTE OF A DIR.
;THESE SQ NOS ARE USED TO DETECT DIRS WHICH HAVE NOT
;BEEN WRITTEN TO DISC COMPLETELY -
;NOTE DIRS CAN BE MULTI-SECTOR OBJECTS.
;SQ NOS ARE CHECKED WHENEVER A DIR IS LOADED.
DRFRST *  0 ;PTR TO 1ST ENTRY (N.B. DON'T CHANGE THIS)
DRSQNO * DRFRST + 2 ;LEADING SEQUENCE NUMBER (1 BYTE)
DRNAME * DRSQNO + 1 ;(NAMLNT BYTES) DIRECTORY NAME
DRFREE * DRNAME +&A ;PTR TO 1ST FREE ENTRY
DRENTS * DRFREE + 2 ;NUMBER OF DIRECTORY ENTRIES
DRSTAR * DRENTS + 2 ;FIRST ENTRY IN DIR
;(OFFSETS IN ENTRY)
DRLINK *  0 ;PTR TO NEXT ENTRY (DON'T ALTER THIS)
DRTITL * DRLINK + 2 ;TEXT NAME (PADDED WITH ZEROES)
DRLOAD * DRTITL +&A ;LOAD ADDRESS
DREXEC * DRLOAD + 4 ;EXECUTE ADDRESS
DRACCS * DREXEC + 4 ;ACCESS INFO
DRDATE * DRACCS + 1 ;DATE OF CREATION
DRSIN * DRDATE + 2 ;SIN OF OBJECT
DRENSZ * DRSIN + 3 ;SIZE OF DIRECTORY ENTRY

;OFFSETS FOR DETAILS RETRIEVED FROM A DIRECTORY
;NOTE THAT IF THE SIZE OF THE INFORMATION (INFNXT) IS
;EVER CHANGED YOU MUST CHANGE THE SIZE OF THE
;BUFFERS:- USWORK,ATUSRI
INFNAM *  0 ;FILE TITLE
INFLOA * INFNAM +&A ;LOAD ADDRESS
INFEXE * INFLOA + 4 ;EXECUTE ADDRESS
INFACC * INFEXE + 4 ;ACCESS INFO (TYPE & ACCESS VECTOR)
INFDTE * INFACC + 1 ;DATE OF CREATION
INFSIN * INFDTE + 2 ;SIN OF OBJECT
INFDIS * INFSIN + 3 ;DISC NUMBER
INFSZE * INFDIS + 2 ;SIZE OF OBJECT
INFNXT * INFSZE + 3 ;NUMBER OF BYTES IN DETAILS

;DIRMAN CONSTANTS
ACCMSK * &1F ;BITS 0 -> 4 (LWR/WR)
TLAMSK * &3F ;=> type/LWRWR mask
RWMSK * &F ;BITS 0 -> 3 (WR/WR)
DISCIN * ":" ;INDICATES DISC NAME IN FILE TITLE
TERMIN * &D ;STRING TERMINATOR
SEPART * "." ;FILE NAME SEPARATOR
NAMLNT * &A ;MAX LENGTH OF TEXT NAME (10 CHARS)
SPACE * " " ;SPACE CHARACTER
ROOT * "$" ;NAME OF ROOT DIRECTORY
MAXDIR * ((:MSB:(DRSTAR + 255 * DRENSZ))+1)*&100
 ;MAX SIZE A DIR IS ALLOWED TO BE
ENTTRM *  0 ;ENTRY TERMINATOR
EXTERM * &80 ;BLOCK TERMINATOR
JMPINS * &4C ;JMP INSTRUCTION
MAXENA * LGBFSZ / 27 ;NO. OF ENTRIES TYPE A
MAXENB * LGBFSZ / 68 ;""      ""      "   B
MAXENC * LGBFSZ / 11 ;""      ""      "   C
MAXEND * LGBFSZ / 18 ;""      ""      "   D

;*** AUTMAN MANIFESTS ***

MAXPW *  6 ;MAX SIZE OF PASSWORD
MAXID * 10 ;MAXIMUM SIZE OF SINGLE USER ID
MAXUNM * 2 * MAXID + 1 ;MAX USER IDS PLUS DOT

;PASSWORD FILE OFFSETS
PWUSID *  0 ;USERID
PWPASS * PWUSID +MAXUNM -1 ;PASSWORD
PWFREE * PWPASS + MAXPW ;free space for this user
PWFLAG * PWFREE + UTFRLN ;FLAG (INUSE & SYSTEM PRIV)
PWENSZ * PWFLAG + 1 ;SIZE OF PASSWORD FILE ENTRY

;*** RNDMAN MANIFESTS ***
;HANDLE TABLE OFFSETS (HANDTB)
HTHAND *  0 ;HANDLE NUMBER
HTMCNO * HTHAND + 1 ;MACHINE NUMBER OF OWNING M/C
HTACC * HTMCNO + 2 ;ACCESS TO & TYPE OF OBJECT
HTDISC * HTACC + 1 ;DISC NUMBER OF OBJECT
HTSIN * HTDISC + 2 ;SIN OF OBJECT
HTMODE * HTSIN + 3 ;MODE OF USE FOR WHICH OPENED
HTRPTR * HTMODE + 1 ;Ptr. to RANDTB entry (2 bytes)
HTENSZ * HTRPTR + 2 ;SIZE OF A HANDTB ENTRY

;RANDTB OFFSETS
RTCSFP *  0 ;Current sequential file pointer
;Note RDSTAR in randman assumes that the
;two pointers are consecutive in this table
RTOSFP * RTCSFP + 3 ;Old sequential file pointer
RTHWM * RTOSFP + 3 ;HIGH WATER MARK
RTFSZE * RTHWM + 3 ;FILE SIZE
RTDESC * RTFSZE + 3 ;ADDRESS OF CACHE DESCRIPTOR(HINT)
RTINUS * RTDESC + 2 ;INUSE + SEQ. NUMBER
RTENSZ * RTINUS + 1 ;SIZE OF EACH RANDTB ENTRY

;*** MAPMAN MANIFESTS ***
;MAPTB OFFSETS
MPDCNO *  0 ;DISC NUMBER
MPNOCY * MPDCNO + 2 ;NUMBER OF CYLINDERS
MPSECS * MPNOCY + 2 ;NO. OF SECTORS PER DISC
MPDSCS * MPSECS + 3 ;NUMBER OF DISCS
MPSPCY * MPDSCS + 1 ;SECTORS PER CYLINDER
MPBMSZ * MPSPCY + 2 ;SIZE OF BIT MAP IN BLOCKS
MPADFT * MPBMSZ + 1 ;ADDED TO GET NEXT PHYSICAL DISC
MPDRNC * MPADFT + 1 ;INCREMENT TO NEXT LOGICAL DRIVE
MPRTSN * MPDRNC + 1 ;SIN OF ROOT DIRECTORY
MPRTDT * MPRTSN + 3 ;ROOT DATE
MPSCYL * MPRTDT + 2 ;START CYLINDER
MPSCTT * MPSCYL + 2 ;TOTAL NUMBER OF SECTORS
MPSIZE * MPSCTT + 3 ;SIZE OF CYLINDER MAP
MPCYMP * MPSIZE + 3 ;STORE ADDRESS OF CYLINDER MAP
MPSQNO * MPCYMP + 2 ;MAP SEQUENCE NUMBER
MPSZLN * MPSCTT ;SIZE OF ENTRY
;** SECTOR ZERO INFO **
MPTBSZ * MPSQNO + 1 ;SIZE OF MAPTB ENTRY
MPDRNM *  0 ;POSN OF 'AFS0' IN SECTOR 0
MPSZNM *  4 ;POSITION OF NAME IN SEC. ZERO
MPSZNC * MPSZNM +&10 ;NUMBER OF CYLINDERS PER DISC
MPSZNS * MPSZNC + 2 ;NUMBER OF SECTORS PER DISC
MPSZDN * MPSZNS + 3 ;NUMBER OF DISCS
MPSZSC * MPSZDN + 1 ;SECTORS PER CYLINDER
MPSZSB * MPSZSC + 2 ;SIZE OF BIT MAP
MPSZAF * MPSZSB + 1 ;ADDITION FOR NEXT PHYSICAL DISC
MPSZDI * MPSZAF + 1 ;INCREMENT FOR NEXT LOGICAL DRIVE
MPSZSI * MPSZDI + 1 ;SIN OF ROOT
SZOFF * &F6 ;OFFSET TO DRIVE DATA SECTOR
MPSZDT * MPSZSI + 3 ;DATE OF ROOT
MPSZSS * MPSZDT + 2 ;START SECTOR

; MAP BLOCK POINTERS
BLKSN *  0
BLKNO * BLKSN + 3
MBSQNO * BLKNO + 3
MGFLG * MBSQNO + 1
BILB * MGFLG + 1
MBENTS * BILB + 2 ;START OF MAP BLOCK ENTRIES
ENSZ *  5 ;BYTES IN MAP BLOCK ENTRY
MXENTS * 49
LSTENT * MBENTS+(MXENTS-1)*ENSZ ;a better definition
LSTSQ * 255
BTINBK *  256 ;BYTES IN A NORMAL DISC BLOCK
;
;BIT MAP FLAGS

MPVAL * &FF ;offset of 'next bitmaps valid' flag

;
; OFFSETS IN CACHE CONTROL BLOCK
;
CAFLG *  0
CBDA * CAFLG +  1
CBSA * CBDA + 3
CBDR * CBSA + 2
CBAGE * CBDR + 1
CBSZ * CBAGE + 1
;
; INFORMATION ABOUT BIT MAP AND MAP BLOCK CACHES
;
NOBTMP *  5 ;NUMBER OF BIT MAP CACHE BLOCKS
NOMPBK *  15 ;NUMBER OF MAP BLOCK CACHE ENTRIES *** LH 15/12/85 ***
SZBMAR * NOBTMP * BTINBK ; NUMBER OF BYTES IN BIT MAP CACHE
SZMBAR * NOMPBK * BTINBK ; NUMBER OF BYTES IN MAP BLOCK CACHE
SZBMCB * NOBTMP * CBSZ ; SIZE OF CACHE CONTROL BLOCK ENTRIES
SZMBCB * NOMPBK * CBSZ ; DITTO FOR MAP BLOCKS

;NAME TABLE OFFSETS ETC.
DNAMLN * &10 ;SIZE OF DISC NAME
NTSIZE *  7 ;NO. OF ENTRIES
USED *  0 ;IN USE VALUE
UNUSED * &FE ;MOST RECENTLY USED VALUE
NTNAME *  0 ;DISC NAME
NTDNO * NTNAME +&10 ;DISC NO.
NTUSED * NTDNO + 2 ;IN USE PTR.
NTENSZ * NTUSED + 1 ;SIZE OF ENTRY
;PAGE ZERO ADDRESSES
;NOTE THAT DOS USES (AD,C9,CB,DA->FF) FOR DISC I/O
 [ SYS=0
SAVCOM * &AD ;DISC TRANSFER COMMAND(READ/WRITE)
TRACK * &DA
SECTOR * &DB
WORK * &DF ;(DISC DRIVER DESCRIPTOR BLOCK)
DDRSTA * WORK ;STORE ADDRESS FOR BLKRD & BLKWR
DDRSPA * DDRSTA + 2 ;SPARE (I.E. NOT USED BY DISC DRIVER)
DDRSZE * DDRSPA + 2 ;NUMBER OF BYTES (LS FIRST) TO BE TRANSFERED
DDRSCT * DDRSZE + 2 ;LOGICAL START SECTOR NUMBER (MS FIRST)
CNTA * &F1 ;NUMBER OF RETRIES STILL TO GO
SECTNO * &F2 ;NUMBER OF SECTORS TO TRANSFER
RAMADR * &F7 ;2 BYTE STORE ADDRESS
 ]

;*** COMMAND PROC. MANIFESTS ***
;CONSTANTS
RXBUFL * &50 ;Receive buffer length
COPORT * &99
FIFLSZ * &400 ;Initial size of file created by FIND
BUFSZ * &500 ;TX BUFFER SIZE
;Function numbers
DRPRS *  1 ;Preserve in dir. man.
DRRTR *  2 ;Retrieve in dir. man
MAPCS *  1 ;Create map space
MAPFS *  2 ;Free map space
MAPENS *  6
;Bits and pieces
WAITCL * &50 ;No. of msecs wait for client
ONEMS *  5 ;No. of loops to give 1 msec (see WAIT)

PSAVD * COPORT + 1 ;Data port in save
TXRPT * &FF ;Do 255 times
TXDLY * &14 ;Delay 20 msec
LF * &A
CR * &D
DOT * "."
FCCMND *  5 ;To recognise a command
FCCRET * 29 ; The create command 11/6/84 BC
FCMAX * 32 ; Max. fn. code
HDRLEN *  5 ;Header of INCOMING message
TXHDR *  2 ;Header length of OUTGOING message
CLIDLM * CR ;Delimiter in CLI table
CLIDL1 * CLIDLM - 1
SAVFTO * HDRLEN +&B
LODFTO * HDRLEN
EXAFTO * HDRLEN + 3
INFFTO * HDRLEN + 1
FNDFTO * HDRLEN + 2 ;File find, not dir. find ??

;LOW LEVEL ADDRESSES

;CLOCK CHIP ADDRESSES


;STORE POINTERS
 [ SYS=0
FRESTR * &7A00
 |
 [ WINCH=0
 [ DONGLE = 0
FRESTR * &8B00
 |
FRESTR * &8C00
 ]
 |
FRESTR * &7A00 ;FIRST FREE STORE LOCATION
 ]
 ]

STKPTR * FRESTR + 0 ;VAL OF HARDWARE STACK PTR (STOP)
FREPTR * STKPTR + 2 ;PTR TO FREE STORE (GETVEC)
ENDPTR * FREPTR + 2 ;PTR TO END OF FREE STORE (GETVEC)
BIGBUF * ENDPTR + 2 ;PTR TO BIG BUFFER (STRMAN)
NUMBCE * BIGBUF + 2 ;NO. OF CACHE DECRIPTORS
CACHSZ * NUMBCE + 1 ;CACHE SIZE

USERTB * CACHSZ + 2 ;PTR TO START OF USERTB (USRMAN)
TITPTR * USERTB + 2 ;PTR TO DIR NAME
USDISC * TITPTR + 2 ;HOLDS DISC NUMBER FOR USRMAN
USRACC * USDISC + 2 ;ACCESS TO DIRECTORY
USRHND * USRACC + 1 ;HANDLE
USRROT * USRHND + 1 ;ROOT CHARACTER
USRSEP * USRROT + 1 ;SEPARATOR CHARACTER
USRUFD * USRSEP + 1 ;USERID
USRTER * USRUFD +MAXUNM ;DIR NAME TERMINATOR
USRINF * USRTER + 1 ;OBJECT DETAILS AREA(SEE DIRMAN.RETRV)
USWORK * USRINF +&1D ;($1D=INFNXT) USRMAN WORK VARIABLE
USTEMP * USWORK + 2 ;Temp general USRMAN store
UMHUFD * USTEMP + 1 ;Temp UFD store.
UMHCSD * UMHUFD + 1
UMHLIB * UMHCSD + 1
MCTEMP * UMHLIB + 1 ;M/C NUMBER
USERS * MCTEMP + 2 ;NO. OF USERS
USSYS * USERS + 1 ;flag to indicate priv'd user logged on
CACHTB * USSYS + 1 ;PTR TO FIRST CACHE ENTRY DESCRIPTOR
FRECHN * CACHTB + 2 ;PTR TO CHAIN OF FREE CACHE DESCRIPTORS
AMTNED * FRECHN + 2 ;AMOUNT OF STORE NEEDED FOR OBJECT
STRTMP * AMTNED + 2 ;STRMAN TEMP VARIABLE
BSTSTA * STRTMP + 2 ;BEST START POSITION
BSTEND * BSTSTA + 2 ;BEST END POSITION
MINCST * BSTEND + 2 ;MINIMUM COST
COST * MINCST + 2
HANDTB * COST + 2 ;PTR TO START OF HANDLE TABLE (RNDMAN)
RANDTB * HANDTB + 2 ;PTR TO START OF RANDOM ACCESS TABLE
RNDTMP * RANDTB + 2
RDBFAD * RNDTMP + 3 ;Current buffer position (RNDMAN)
BTSXFD * RDBFAD + 2 ;Bytes xferred in PB/GB (2 bytes) (RNDMAN)
BTSLFT * BTSXFD + 2 ;Bytes left to transfer (2 bytes)
NEWFSZ * BTSLFT + 2 ;New file size (arg to RDCHSZ
;routine) - 3 bytes
EOFFLG * NEWFSZ + 3 ;End-of-file flag (RNDMAN)
HTENTS * EOFFLG + 1 ;NO. OF HAND. TBL. ENTRIES
RTNENT * HTENTS + 1 ;No. of RANDTB entries
INTEGR * RTNENT + 1 ;TO HOLD AN INTEGER(RDINT)
GVWRKA * INTEGR + 2 ;GETVEC WORK VARIABLE
ENWRKA * GVWRKA + 2 ;ENTRY WORK VAR
TEMPA * ENWRKA + 2 ;TEMPORARY VARIABLE
TEMPB * TEMPA + 2
MCNUMB * TEMPB + 2 ;MC/NO LOOKED UPIN USERTB(USRMAN-FINDMC)
DATE * MCNUMB + 2 ;3 BYTE DATE VALUE Last byte = day
 [ Dongle=0
ORB * DATE+3
IRB * ORB+1
DDRB * IRB+1
TIME * DDRB+1 ;TIME OF DAY
 |
TIME * DATE+3
 ]
OTIME * TIME +5 ;COMPARISON
NTIME * OTIME +5 ;WORK VARIABLE FOR TIME
SECS * NTIME + 5 ;SECONDS
MINS * SECS + 1 ;MINUTES
HRS * MINS + 1 ;HOURS
DAYS * HRS + 1
MUNTHS * DAYS + 1
REM * MUNTHS + 1 ;DIVISION REMAINDER
DVSOR * REM + 1 ;DIVISOR
DATBUF * DVSOR + 1 ;Buffer for time chip data
LASTNM * DATBUF +&C ;PTR TO 1ST CHAR OF LAST TEXT NAME(DIRMAN)
DRDSNM * LASTNM + 2 ;BUFFER TO HOLD DISC NAME(17BYTES)
DIRACC * DRDSNM +&11 ;TYPE & ACCESS TO DIR (OWNER/ANYBODY)
DRDISC * DIRACC + 1 ;DISC NO OF CURRENT DIR
DIRSIN * DRDISC + 2 ;SIN OF CURRENT DIR
DIRSTT * DIRSIN + 3 ;START BLK NO OF DIRECTORY (=0)
DIRBKS * DIRSTT + 2 ;NO OF BLKS IN DIR
DIRSTA * DIRBKS + 2 ;STORE ADDRESS OF DIR
DIRSZE * DIRSTA + 2 ;3 BYTE VARIABLE HOLDING SIZE OF DIR
TXTNAM * DIRSZE + 3 ;10 BYTE TEXT NAME (PADDED WITH SPACES)
DIRTMP * TXTNAM +NAMLNT+1 ;(0A=NAMLNT)3 BYTE TEMPORARY VARIABLE
DMTEMP * DIRTMP + 3 
OBJSIN * DMTEMP + 3 ;TEMP VAR HOLDING SIN OF OBJECT
OBJACC * OBJSIN + 3 ;TEMP VAR HOLDING ACC INFO FOR OBJECT
EXARG * OBJACC + 1
EXENTR * EXARG + 1
EXENTS * EXENTR + 1
DMSTX * EXENTS + 1 ;1 BYTE
DRCNT * DMSTX + 1 ;1 BYTE LOCN.
EXRTN * DRCNT + 1 ;3 BYTES
TDATE * EXRTN + 3
DIRWC * TDATE + 2 ;FLAG FOR WILD CARDS
WILD1 * DIRWC + 1 ;USED IN FNDTEX
WILD2 * WILD1 + 1
DIRFLG * WILD2 +  1
ATDRIV * DIRFLG + 1 ;DRIVE NUMBER(AUTMAN)
ATLNG * ATDRIV + 1 ;LENGTH OF PW FILE
ATSTRA * ATLNG + 3 ;STORE ADDRESS OF PW FILE
ATINF * ATSTRA + 2 ;INFORMATION FROM DIRMAN
ATUSRI * ATINF +INFNXT ;(INFNXT) USERINFO VECTOR FOR AUTMAN
ATNWEN * ATUSRI +UTENSZ ;(UTENSZ) PTR TO NEW PW FILE ENTRY(SETBY FDUSID)
ATWORK * ATNWEN + 2 ;AUTMAN WORK VARIABLE
DOTFLG * ATWORK + 3 ;FLAG DOT HAS OCCURED
DRIVES * DOTFLG + 1 ;NUMBER OF DRIVES ATTACHED TO FS
MAPTB * DRIVES + 1 ;HOLDS ADDRESS OF MAP TABLE(MAPMAN)
DIVPAR * MAPTB + 2
DIVTMP * DIVPAR + 3 ;HOLDS BLOCKS TO ALLOCATE
NAMETB * DIVTMP + 3 ;NAME TABLE
MAPTMP * NAMETB + 2 ;TEMP VARIABLE
MPTMPA * MAPTMP + 3
MPTMPB * MPTMPA + 3
MPTMPC * MPTMPB + 3
TMPSPC * MPTMPC + 3 ;TEMPORARY SECTORS PER CYLINDER
MPSZEQ * TMPSPC + 3 ;Indicates if zero length chain
MPCHFL * MPSZEQ + 1 ;HOLDS END OF CHAIN FLAGS
MPDRVE * MPCHFL + 1 ;HOLDS CURRENT DRIVE NUMBER
MPDSNO * MPDRVE + 1 ;CURRENT DISC NO
MPSCST * MPDSNO + 2 ;POINTER TO START OF DISC????
MPTMPD * MPSCST + 2 ;GENERAL PURPOSE VARIABLE
MPTMPE * MPTMPD + 3 ;GENERAL PURPOSE VARIABLE
MKENVA * MPTMPE + 3
SAVC * MKENVA + 3
SAVSC * SAVC + 3
SAVPTB * SAVSC + 3 ;SAVE POINTER POSITION
SAVPTA * SAVPTB + 3 ;SAVE POINTER
MBCBPT * SAVPTA + 3 ;POINTER TO MAP BLOCK CONTROL BLOCKS
BMCBPT * MBCBPT + 2 ;PONTER TO BIT MAP CONTROL BLOCK
NCBDB * BMCBPT + 2 ;NUMBER OF CURRENT CONTROL BLOCK ENTRIES
CBSIN * NCBDB + 2 ;CURRENT CB SIN
CBSTA * CBSIN + 3 ;CURRENT CB STORE ADDRESS
CBTPPT * CBSTA + 2 ;CB TEMPORARY POINTER
RBDA * CBTPPT + 2 ;TRANSFER BLOCK DISC ADDRESS
ERRTYP * RBDA + 3 ;READ OR WRITE DISC ERROR
DNDLTE * ERRTYP + 1 ;DELETE CURRENT MAP BLOCK?
RSTFLG * DNDLTE + 1 ;CYLINDER MAP STARTUP FLAG
CURDSC * RSTFLG + 1 ;CURRENT DSIC NO.
NXTDNO * CURDSC + 2 ;NEXT DISC NO. ALLOCATION
CURDRV * NXTDNO + 2 ;CURRENT DRIVE
LDRNB * CURDRV + 1 ;LOGICAL DRIVE NUMBER (DSCMAN)
DCSECT * LDRNB + 1 ;SECTOR NUMBER
DRIVNO * DCSECT + 3 ;ACTUAL DRIVE NUMBER TO BE SELECTED
DCSTAD * DRIVNO + 1 ;STORE ADDRESS
NBLKS * DCSTAD + 2 ;NUMBER OF DISC BLOCKS TO BE TRANSFERED
DATARA * NBLKS +2 ;AREA FOR TEST OF DISC BLOCK VALIDITY
OLDFDR * DATARA + 16 ;LAST FDRIVE USED
OLDSZE * OLDFDR + 1
CTRACK * OLDSZE + 4 ;COPY OF TRACK NUMBER
CSECTR * CTRACK + 1 ;COPY OF 1 BYTE SECTOR NUMBER
CADDR * CSECTR + 1 ;COPY OF STORE ADDRESS
SECTSD * CADDR + 2 ;NUMB OF SECTORS ON A SIDE OF DISC
SECTS * SECTSD + 2 ;NO. OF SECTS TO XFER
DCRASH * SECTS + 2 ;DISC CRASH INDICATION
 [ BBC=0
DSCCB * DCRASH + 1
SAVCOM * DSCCB + 16
TRACK * SAVCOM + 1
SECTOR * TRACK + 1
DDRSTA * SECTOR + 1
DDRSPA * DDRSTA + 2
DDRSZE * DDRSPA + 2
DDRSCT * DDRSZE + 2
CNTA * DDRSCT + 2
SECTNO * CNTA + 1
DFNAME * SECTNO+ 1
DFLOAD * DFNAME + 10
DFEXEC * DFLOAD+ 2
DFSIZE * DFEXEC + 2
DFQUAL * DFSIZE+ 3
DFSECT * DFQUAL+ 10
RAMADR * DFSECT + 10
INTROT * RAMADR + 2 ;USED FOR A FILE TITLE (INIT)
 |
INTROT * DCRASH + 1
 ]
USERNM * INTROT + 2 ;HOLDS A USERID
BREGA * USERNM +MAXUNM+ 1 ;3 BYTE WORK VARIABLE (MULTBS)
 [ BBC=0
RXTAB * BREGA + 3
RXCBN * RXTAB + 1
RXCBV * RXCBN + 1
 |
RXCBV * BREGA + 3 ;RECEIVE CONTROL BLOCK VECTOR
 ]
CBFLG * RXCBV ;RECEIVE C.B. FIELDS
CBPORT * RXCBV + 1
CBSTID * RXCBV + 2
CBBUF * RXCBV + 4
 [ SYS=0
CBBUFE * RXCBV + 6
RXBUF * RXCBV +&B
 |
CBBUFE * RXCBV + 8
RXBUF * RXCBV +&E
 ]
FCODE * RXBUF + 1 ;FN. code
CPUFD * RXBUF + 2
CPCSD * CPUFD + 1
CPLIB * CPCSD + 1
MIDRX * CPLIB + 1
RXBUFT * RXBUF +&A1
TXBUF * RXBUFT + 1
MIDTX * TXBUF + 2
CCODE * TXBUF ;Command code
RTCODE * TXBUF + 1

 ;CONVERT FROM DOS WORKSPACE


;OTHER VARIABLES
OTHERS * TXBUF +&30
COTEMP * OTHERS
COWORK * COTEMP + 2
DETRAM * COWORK
DETNAM * DETRAM ;DETAILS FROM RETRIEVE
DETLOA * DETNAM +&A
DETEXE * DETLOA + 4
DETACC * DETEXE + 4
DETDAT * DETACC + 1
DETSIN * DETDAT + 2
DETDIS * DETSIN + 3
DETSZ * DETDIS + 2
TOSEND * DETSZ + 3
OFFSET * TOSEND + 3
GBBXFD * OFFSET + 3 ;Bytes xfd in CP GETBYTES (3 bytes)
GBEFLG * GBBXFD + 3 ;End of file flag (CP GETBYTES)
TXTBUF * GBEFLG + 1 ;80 byte file title buffer
QPTR * TXTBUF +&50
BPTR * QPTR + 1
CURBLK * BPTR + 1
OUTBSZ * CURBLK + 2
BBUF * OUTBSZ + 2
BBSIZE * BBUF + 2
BBEND * BBSIZE + 2
DANDS * BBEND + 2
DSCERR * DANDS + 5
RPLYPT * DSCERR + 1
DATAIN * RPLYPT + 1
FINFLG * DATAIN + 3
FILLFL * FINFLG + 1
TIMER * FILLFL + 1
TIMER1 * TIMER + 1
TIMER2 * TIMER1 + 1
QUOTED * TIMER2 + 1
TXJ * QUOTED + 1
TXD * TXJ + 1
TXF * TXD + 1
MONFLG * TXF + 1
OLDRXB * MONFLG + 1
CDIRTB * OLDRXB + 2
CVTDRV * CDIRTB + 2
FSDNO * CVTDRV + 1
HNDROT * FSDNO + 2
QUALIF * HNDROT + 1
TXBYTS * QUALIF + 1
TXBLKS * TXBYTS + 2
MEMEND * TXBLKS + 2
 [ 1=0
TSTACK * MEMEND + 2 ;Store stack pointer in MAPMAN & CONVERT
OLDBRK * TSTACK + 1 ;Store BRK vector in MAPMAN & CONVERT
 |
OLDBRK * MEMEND + 2
 ]
OFF1 * OLDBRK + 2 ;ARG TO MOVBLK
OFF2 * OFF1 + 1 ;ARG TO MOVBLK
STRPTR * OFF2 + 1 ;Ptr. used in AUTMAN
PTREND * STRPTR + 2 ;Ptr. used in AUTMAN
RIPPLE * PTREND + 2
EVCHAR * RIPPLE + 1
IOBUF * EVCHAR + 1 ;new big buffer
IOBSIZ * IOBUF + 2
IOEND * IOBSIZ + 2
ODSCMN * IOEND + 2
MPNWFR * ODSCMN + 11 ;user free space calculation
DYNSTA * MPNWFR + UTFRLN ;START OF DYNAMICALLY ALLOCATED STORE
MAPTBF * TXTBUF ;Buffer MAPTB information in MAPMAN.MPREDR

 LNK UADE03
