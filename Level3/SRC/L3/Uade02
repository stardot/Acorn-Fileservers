 OPT UADE02 ; > Uade02
 TTL File server file UADE02

;**********************************
;*    H E A D E R  F I L E  2     *
;**********************************

BRKVEC * &202
BPUTV * &218
TSTART * &F800

;*** STRMAN MANIFESTS ***
;CACHE ENTRY DESCRIPTOR OFFSETS
 ^ 0
CEDISC # 2 ;DISC NO
CESIN # 3 ;SIN OF OBJECT
CEBKNO # 2 ;START BLOCK NUMBER IN OBJECT
CEBLKS # 2 ;NUMBER OF BLOCKS OCCUPIED BY WINDOW
CESTA # 2 ;STORE ADDRESS OF OBJECT
CERCNT # 1 ;REFERENCE COUNT
CEAGE # 1 ;AGE FOR LRU REPLACEMENT ALGORITHM
CENEXT # 2 ;PTR TO NEXT DESCRIPTOR
CESIZE * @ ;SIZE OF A DESCRIPTOR
;THE ADDRESS OF DIRTY FLAG IS = STORE ADDRESS OF WINDOW - 1

;STRMAN BUFFER SIZE
LGBFSZ * 6 * BLKSZE ;SIZE OF A LARGE BUFFER(MUST BE MULTIPLE OF BLKSZE)
;** 6/12/84 **

;BUFFER AGES
LRU *  1 ;=> LEAST RECENTLY USED
MRU * &FF ;=> MOST RECENTLY USED

;*** DIRMAN MANIFESTS ***
;DIRECTORY OFFSETS
;(HEADER INFORMATION)
;NOTE THAT A ONE BYTE SEQUENCE NUMBER (INCREMENTED WHEN
;WRITING A DIR TO DISC) BRACKETS A DIRECTORY.
;THE LEADING SEQUENCE NUMBER GOES AT BYTE OFFSET 2
;AND THE TRAILING SQ NO IS THE LAST BYTE OF A DIR.
;THESE SQ NOS ARE USED TO DETECT DIRS WHICH HAVE NOT
;BEEN WRITTEN TO DISC COMPLETELY -
;NOTE DIRS CAN BE MULTI-SECTOR OBJECTS.
;SQ NOS ARE CHECKED WHENEVER A DIR IS LOADED.
 ^ 0
DRFRST # 2 ;PTR TO 1ST ENTRY (N.B. DON'T CHANGE THIS)
DRSQNO # 1 ;LEADING SEQUENCE NUMBER (1 BYTE)
DRNAME # &A ;(NAMLNT BYTES) DIRECTORY NAME
DRFREE # 2 ;PTR TO 1ST FREE ENTRY
DRENTS # 2 ;NUMBER OF DIRECTORY ENTRIES
DRSTAR # 0 ;FIRST ENTRY IN DIR
;(OFFSETS IN ENTRY)
 ^ 0
DRLINK # 2 ;PTR TO NEXT ENTRY (DON'T ALTER THIS)
DRTITL # &A ;TEXT NAME (PADDED WITH ZEROES)
DRLOAD # 4 ;LOAD ADDRESS
DREXEC # 4 ;EXECUTE ADDRESS
DRACCS # 1 ;ACCESS INFO
DRDATE # 2 ;DATE OF CREATION
DRSIN # 3 ;SIN OF OBJECT
DRENSZ * @ ;SIZE OF DIRECTORY ENTRY

;OFFSETS FOR DETAILS RETRIEVED FROM A DIRECTORY
;NOTE THAT IF THE SIZE OF THE INFORMATION (INFNXT) IS
;EVER CHANGED YOU MUST CHANGE THE SIZE OF THE
;BUFFERS:- USWORK,ATUSRI
 ^ 0
INFNAM # &A ;FILE TITLE
INFLOA # 4 ;LOAD ADDRESS
INFEXE # 4 ;EXECUTE ADDRESS
INFACC # 1 ;ACCESS INFO (TYPE & ACCESS VECTOR)
INFDTE # 2 ;DATE OF CREATION
INFSIN # 3 ;SIN OF OBJECT
INFDIS # 2 ;DISC NUMBER
INFSZE # 3 ;SIZE OF OBJECT
INFNXT * @ ;NUMBER OF BYTES IN DETAILS

;DIRMAN CONSTANTS
ACCMSK * &1F ;BITS 0 -> 4 (LWR/WR)
TLAMSK * &3F ;=> type/LWRWR mask
RWMSK * &F ;BITS 0 -> 3 (WR/WR)
DISCIN * ":" ;INDICATES DISC NAME IN FILE TITLE
TERMIN * &D ;STRING TERMINATOR
SEPART * "." ;FILE NAME SEPARATOR
NAMLNT * &A ;MAX LENGTH OF TEXT NAME (10 CHARS)
SPACE * " " ;SPACE CHARACTER
ROOT * "$" ;NAME OF ROOT DIRECTORY
MAXDIR * ((:MSB:(DRSTAR+255*DRENSZ))+1)*&100
 ;MAX SIZE A DIR IS ALLOWED TO BE
ENTTRM * 0 ;ENTRY TERMINATOR
EXTERM * &80 ;BLOCK TERMINATOR
JMPINS * &4C ;JMP INSTRUCTION
MAXENA * LGBFSZ / 27 ;NO. OF ENTRIES TYPE A
MAXENB * LGBFSZ / 68 ;""      ""      "   B
MAXENC * LGBFSZ / 11 ;""      ""      "   C
MAXEND * LGBFSZ / 18 ;""      ""      "   D


;*** AUTMAN & USRMAN MANIFESTS ***

MAXPW * 6 ;MAX SIZE OF PASSWORD
MAXID * 10 ;MAXIMUM SIZE OF SINGLE USER ID
MAXUNM * 2 * MAXID+1 ;MAX USER IDS PLUS DOT
UTFRLN * 4 ;length of free space counter

;PASSWORD FILE OFFSETS
 ^ 0
PWUSID # MAXUNM-1 ;USERID
PWPASS # MAXPW ;PASSWORD
PWFREE # UTFRLN ;free space for this user
PWFLAG # 1 ;FLAG (INUSE & SYSTEM PRIV)
PWENSZ * @ ;SIZE OF PASSWORD FILE ENTRY

;*** USRMAN MANIFESTS ***
;USERTB OFFSETS
 ^ 0
UTMCNO # 3 ;START OF MACHINE NO **25/12/86*
UTUSID # MAXUNM+1 ;START OF USERID
UTDISC # 2 ;CURRENTLY SELECTED DISC NUMBER
UTPRIV # 1 ;SYSTEM PRIVILEGE & INUSE FLAG
UTHSLD # 1 ;HANDLE FOR SELECTED DIR
 [ Pseudods = Yes
UTHUFD # 1 ;**26/6/87** handle for logon directory
 ]
UTHNDB # 1 ;BYTE INDICATING HANDLES IN USE PER MC
UTFREE # UTFRLN ;User disc space allocation ** 2/10/84 **
UTENSZ * @ ;SIZE OF A USERTB ENTRY
OPTMSK * &F ;Mask for user option bits
NTOPT * &F0 ;Complement of OPTMSK


;*** RNDMAN MANIFESTS ***
;HANDLE TABLE OFFSETS (HANDTB)
 ^ 0
HTHAND # 1 ;HANDLE NUMBER
HTMCNO # 3 ;MACHINE NUMBER OF OWNING M/C *25/12/86**
HTACC # 1 ;ACCESS TO & TYPE OF OBJECT
HTDISC # 2 ;DISC NUMBER OF OBJECT
HTSIN # 3 ;SIN OF OBJECT
HTMODE # 1 ;MODE OF USE FOR WHICH OPENED
HTRPTR # 2 ;Ptr. to RANDTB entry (2 bytes)
HTENSZ * @ ;SIZE OF A HANDTB ENTRY

;RANDTB OFFSETS
 ^ 0
RTCSFP # 3 ;Current sequential file pointer
;Note RDSTAR in randman assumes that the
;two pointers are consecutive in this table
RTOSFP # 3 ;Old sequential file pointer
RTHWM # 3 ;HIGH WATER MARK
RTFSZE # 3 ;FILE SIZE
RTDESC # 2 ;ADDRESS OF CACHE DESCRIPTOR(HINT)
RTINUS # 1 ;INUSE+SEQ. NUMBER
RTENSZ * @ ;SIZE OF EACH RANDTB ENTRY

;*** MAPMAN MANIFESTS ***
;MAPTB OFFSETS
 ^ 0
MPDCNO # 2 ;DISC NUMBER
MPNOCY # 2 ;NUMBER OF CYLINDERS
MPSECS # 3 ;NO. OF SECTORS PER DISC
MPDSCS # 1 ;NUMBER OF DISCS
MPSPCY # 2 ;SECTORS PER CYLINDER
MPBMSZ # 1 ;SIZE OF BIT MAP IN BLOCKS
MPADFT # 1 ;ADDED TO GET NEXT PHYSICAL DISC
MPDRNC # 1 ;INCREMENT TO NEXT LOGICAL DRIVE
MPRTSN # 3 ;SIN OF ROOT DIRECTORY
MPRTDT # 2 ;ROOT DATE
MPSCYL # 2 ;START CYLINDER
MP1BIT # 1 ;Non-zero if packed map, gives bytes/cyl
MPSZLN * @ ;End of part copied from sector zero
MPSCTT # 3 ;TOTAL NUMBER OF SECTORS
MPCYMP # 2 ;STORE ADDRESS OF CYLINDER MAP
MPTBSZ * @ ;SIZE OF MAPTB ENTRY

;** SECTOR ZERO INFO **
 ^ 0
MPDRNM # 4 ;POSN OF 'AFS0' IN SECTOR 0
MPSZNM # &10 ;POSITION OF NAME IN SEC. ZERO
MPSZNC # 2 ;NUMBER OF CYLINDERS PER DISC
MPSZNS # 3 ;NUMBER OF SECTORS PER DISC
MPSZDN # 1 ;NUMBER OF DISCS
MPSZSC # 2 ;SECTORS PER CYLINDER
MPSZSB # 1 ;SIZE OF BIT MAP
MPSZAF # 1 ;ADDITION FOR NEXT PHYSICAL DISC
MPSZDI # 1 ;INCREMENT FOR NEXT LOGICAL DRIVE
MPSZSI # 3 ;SIN OF ROOT
MPSZDT # 2 ;DATE OF ROOT
MPSZSS # 2 ;START SECTOR
MPSZ1B # 1 ;Non-zero if packed map, gives bytes/cyl
SZOFF * &F6 ;OFFSET TO DRIVE DATA SECTOR

; MAP BLOCK POINTERS
 ^ 0
BLKSN # 3
BLKNO # 3
MBSQNO # 1
MGFLG # 1
BILB # 2
MBENTS * @ ;START OF MAP BLOCK ENTRIES
ENSZ * 5 ;BYTES IN MAP BLOCK ENTRY
MXENTS * 49
LSTENT * MBENTS+(MXENTS-1)*ENSZ ;a better definition
LSTSQ * 255
BTINBK * 256 ;BYTES IN A NORMAL DISC BLOCK
;
;BIT MAP FLAGS

MPVAL * &FF ;offset of 'next bitmaps valid' flag

;
; OFFSETS IN CACHE CONTROL BLOCK
;
 ^ 0
CAFLG # 1
CBDA # 3
CBSA # 2
CBDR # 1
CBAGE # 1
CBSZ * @
;
; INFORMATION ABOUT BIT MAP AND MAP BLOCK CACHES
;
NOBTMP * 5 ;NUMBER OF BIT MAP CACHE BLOCKS
NOMPBK * 15 ;NUMBER OF MAP BLOCK CACHE ENTRIES
SZBMAR * NOBTMP*BTINBK ; NUMBER OF BYTES IN BIT MAP CACHE
SZMBAR * NOMPBK*BTINBK ; NUMBER OF BYTES IN MAP BLOCK CACHE
SZBMCB * NOBTMP*CBSZ ; SIZE OF CACHE CONTROL BLOCK ENTRIES
SZMBCB * NOMPBK*CBSZ ; DITTO FOR MAP BLOCKS

;NAME TABLE OFFSETS ETC.
DNAMLN * &10 ;SIZE OF DISC NAME
NTSIZE * 7 ;NO. OF ENTRIES
USED * 0 ;IN USE VALUE
UNUSED * &FE ;MOST RECENTLY USED VALUE
 ^ 0
NTNAME # DNAMLN ;DISC NAME
NTDNO # 2 ;DISC NO.
NTUSED # 1 ;IN USE PTR.
NTENSZ * @ ;SIZE OF ENTRY

;PAGE ZERO ADDRESSES
;NOTE THAT DOS USES (AD,C9,CB,DA->FF) FOR DISC I/O
 [ SYS=0
SAVCOM * &AD ;DISC TRANSFER COMMAND(READ/WRITE)
TRACK * &DA
SECTOR * &DB
WORK * &DF ;(DISC DRIVER DESCRIPTOR BLOCK)
DDRSTA * WORK ;STORE ADDRESS FOR BLKRD & BLKWR
DDRSPA * DDRSTA + 2 ;SPARE (I.E. NOT USED BY DISC DRIVER)
DDRSZE * DDRSPA + 2 ;NUMBER OF BYTES (LS FIRST) TO BE TRANSFERED
DDRSCT * DDRSZE + 2 ;LOGICAL START SECTOR NUMBER (MS FIRST)
CNTA * &F1 ;NUMBER OF RETRIES STILL TO GO
SECTNO * &F2 ;NUMBER OF SECTORS TO TRANSFER
RAMADR * &F7 ;2 BYTE STORE ADDRESS
 ]

;*** COMMAND PROC. MANIFESTS ***
;CONSTANTS
RXBUFL * 127 ;**8/2/88** Receive buffer length (<=127)
COPORT * &99
FIFLSZ * &400 ;Initial size of file created by FIND
BUFSZ * &500 ;TX BUFFER SIZE
;Function numbers
DRPRS * 1 ;Preserve in dir. man.
DRRTR * 2 ;Retrieve in dir. man
MAPCS * 1 ;Create map space
MAPFS * 2 ;Free map space
MAPENS * 6
;Bits and pieces
WAITCL * &50 ;No. of msecs wait for client
ONEMS * 5 ;No. of loops to give 1 msec (see WAIT)

PSAVD * COPORT+1 ;Data port in save
TXRPT * &FF ;Do 255 times
TXDLY * &14 ;Delay 20 msec
LF * &A
CR * &D
DOT * "."
FCCMND * 5 ;To recognise a command
FCCRET * 29 ; The create command 11/6/84 BC
HDRLEN * 5 ;Header of INCOMING message
MCTASK * &78 ;Mask for task number in control byte **1/5/86**
TXHDR * 2 ;Header length of OUTGOING message
CLIDLM * CR ;Delimiter in CLI table
CLIDL1 * CLIDLM-1
SAVFTO * HDRLEN+&B
LODFTO * HDRLEN
EXAFTO * HDRLEN+3
INFFTO * HDRLEN+1
FNDFTO * HDRLEN+2 ;File find, not dir. find ??


;STORE POINTERS
 [ SYS=0
FRESTR * &7A00
 |
 [ WINCH=0
 [ DONGLE = 0
FRESTR * &8A00
 |
FRESTR * &8B00
 ]
 |
FRESTR * &7A00 ;FIRST FREE STORE LOCATION
 ]
 ]

;STORE POINTERS
 ^ FRESTR
STKPTR # 2 ;VAL OF HARDWARE STACK PTR (STOP)
FREPTR # 2 ;PTR TO FREE STORE (GETVEC)
ENDPTR # 2 ;PTR TO END OF FREE STORE (GETVEC)
BIGBUF # 2 ;PTR TO BIG BUFFER (STRMAN)
NUMBCE # 1 ;NO. OF CACHE DECRIPTORS
CACHSZ # 2 ;CACHE SIZE

USERTB # 2 ;PTR TO START OF USERTB (USRMAN)
TITPTR # 2 ;PTR TO DIR NAME
USDISC # 2 ;HOLDS DISC NUMBER FOR USRMAN
USRACC # 1 ;ACCESS TO DIRECTORY
USRROT # 1 ;ROOT CHARACTER
USRSEP # 1 ;SEPARATOR CHARACTER
USRUFD # MAXUNM ;USERID
USRTER # 1 ;DIR NAME TERMINATOR
USRINF # INFNXT ;OBJECT DETAILS AREA(SEE DIRMAN.RETRV)
USWORK # 2 ;USRMAN WORK VARIABLE
USTEMP # 1 ;Temp general USRMAN store
UMHUFD # 1 ;Temp UFD store.
UMHCSD # 1
UMHLIB # 1
MCTEMP # 3 ;M/C NUMBER  **25/12/86**
USERS # 1 ;NO. OF USERS
USSYS # 1 ;flag to indicate priv'd user logged on
CACHTB # 2 ;PTR TO FIRST CACHE ENTRY DESCRIPTOR
FRECHN # 2 ;PTR TO CHAIN OF FREE CACHE DESCRIPTORS
AMTNED # 2 ;AMOUNT OF STORE NEEDED FOR OBJECT
STRTMP # 2 ;STRMAN TEMP VARIABLE
BSTSTA # 2 ;BEST START POSITION
BSTEND # 2 ;BEST END POSITION
MINCST # 2 ;MINIMUM COST
COST # 2
HANDTB # 2 ;PTR TO START OF HANDLE TABLE (RNDMAN)
RANDTB # 2 ;PTR TO START OF RANDOM ACCESS TABLE
RDBFAD # 2 ;Current buffer position (RNDMAN)
BTSXFD # 2 ;Bytes xferred in PB/GB (2 bytes) (RNDMAN)
BTSLFT # 2 ;Bytes left to transfer (2 bytes)
NEWFSZ # 3 ;New file size (arg to RDCHSZ routine) - 3 bytes
EOFFLG # 1 ;End-of-file flag (RNDMAN)
HTENTS # 1 ;NO. OF HAND. TBL. ENTRIES
RTNENT # 1 ;No. of RANDTB entries
INTEGR # 1 ;To hold an integer (RDINT)
GVWRKA # 2 ;GETVEC WORK VARIABLE
ENWRKA # 2 ;ENTRY WORK VAR
TEMPA # 2
TEMPB # 2
MCNUMB # 3 ;MC/NO LOOKED UP IN USERTB(USRMAN-FINDMC) **25/12/86**
DATE # 3 ;3 BYTE DATE VALUE Last byte = day
 [ Dongle=0
ORB # 1
IRB # 1
DDRB # 1
 ]
TIME # 5 ;TIME OF DAY
OTIME # 5 ;COMPARISON
NTIME # 5 ;WORK VARIABLE FOR TIME
SECS # 1 ;SECONDS
MINS # 1 ;MINUTES
HRS # 1 ;HOURS
DAYS # 1
MUNTHS # 1
REM # 1 ;DIVISION REMAINDER
DVSOR # 1 ;DIVISOR
DATBUF # &C ;Buffer for time chip data
LASTNM # 2 ;PTR TO 1ST CHAR OF LAST TEXT NAME(DIRMAN)
DRDSNM # &11 ;BUFFER TO HOLD DISC NAME(17BYTES)
DIRACC # 1 ;) TYPE & ACCESS TO DIR (OWNER/ANYBODY)
DRDISC # 2 ;) DISC NO OF CURRENT DIR
DIRSIN # 3 ;) SIN OF CURRENT DIR
DIRSTT # 2 ;) START BLK NO OF DIRECTORY (=0)
DIRBKS # 2 ;) NO OF BLKS IN DIR
DIRSTA # 2 ;STORE ADDRESS OF DIR
DIRSZE # 3 ;3 BYTE VARIABLE HOLDING SIZE OF DIR
TXTNAM # NAMLNT+1 ;TEXT NAME (PADDED WITH SPACES)
DIRTMP # 3 ;3 BYTE TEMPORARY VARIABLE
DMTEMP # 3 
OBJSIN # 3 ;TEMP VAR HOLDING SIN OF OBJECT
OBJACC # 1 ;TEMP VAR HOLDING ACC INFO FOR OBJECT
EXARG # 1
EXENTR # 1
EXENTS # 1
DMSTX # 1 ;1 BYTE
DRCNT # 1 ;1 BYTE LOCN.
EXRTN # 3 ;3 BYTES
TDATE # 2
DIRWC # 1 ;FLAG FOR WILD CARDS
WILD1 # 1 ;USED IN FNDTEX
WILD2 # 1
DIRFLG # 1
ATDRIV # 1 ;DRIVE NUMBER(AUTMAN)
ATSTRA # 2 ;STORE ADDRESS OF PW FILE
ATINF # INFNXT ;INFORMATION FROM DIRMAN
ATUSRI # UTENSZ ;USERINFO VECTOR FOR AUTMAN
ATWORK # 1 ;AUTMAN WORK VARIABLE
DOTFLG # 1 ;FLAG DOT HAS OCCURED
DRIVES # 1 ;NUMBER OF DRIVES ATTACHED TO FS
MAPTB # 2 ;HOLDS ADDRESS OF MAP TABLE(MAPMAN)
DIVPAR # 3
DIVTMP # 3 ;HOLDS BLOCKS TO ALLOCATE
NAMETB # 2 ;NAME TABLE
MAPTMP # 3 ;TEMP VARIABLE
MPTMPA # 3
MPTMPB # 3
MPTMPC # 3
TMPSPC # 3 ;TEMPORARY SECTORS PER CYLINDER
MPSZEQ # 1 ;Indicates if zero length chain
MPCHFL # 1 ;HOLDS END OF CHAIN FLAGS
MPDRVE # 1 ;HOLDS CURRENT DRIVE NUMBER
MPDSNO # 2 ;CURRENT DISC NO
MPSCST # 2 ;POINTER TO START OF DISC????
MPTMPD # 3 ;GENERAL PURPOSE VARIABLE
MPTMPE # 3 ;GENERAL PURPOSE VARIABLE
MKENVA # 3
SAVSC # 3
SAVPTB # 3 ;SAVE POINTER POSITION
SAVPTA # 3 ;SAVE POINTER
MBCBPT # 2 ;POINTER TO MAP BLOCK CONTROL BLOCKS
BMCBPT # 2 ;PONTER TO BIT MAP CONTROL BLOCK
NCBDB # 2 ;NUMBER OF CURRENT CONTROL BLOCK ENTRIES
CBSIN # 3 ;CURRENT CB SIN
CBSTA # 2 ;CURRENT CB STORE ADDRESS
CBTPPT # 2 ;CB TEMPORARY POINTER
RBDA # 3 ;TRANSFER BLOCK DISC ADDRESS
ERRTYP # 1 ;READ OR WRITE DISC ERROR
DNDLTE # 1 ;DELETE CURRENT MAP BLOCK?
RSTFLG # 1 ;CYLINDER MAP STARTUP FLAG
CURDSC # 2 ;CURRENT DISC NO.
NXTDNO # 2 ;NEXT DISC NO. ALLOCATION
CURDRV # 1 ;CURRENT DRIVE
LDRNB # 1 ;LOGICAL DRIVE NUMBER (DSCMAN)
DCSECT # 3 ;SECTOR NUMBER
DRIVNO # 1 ;ACTUAL DRIVE NUMBER TO BE SELECTED
DCSTAD # 2 ;STORE ADDRESS
NBLKS # 2 ;NUMBER OF DISC BLOCKS TO BE TRANSFERED
DATARA # 16 ;AREA FOR TEST OF DISC BLOCK VALIDITY
OLDFDR # 1 ;LAST FDRIVE USED
OLDSZE # 4
CTRACK # 1 ;COPY OF TRACK NUMBER
CSECTR # 1 ;COPY OF 1 BYTE SECTOR NUMBER
CADDR # 2 ;COPY OF STORE ADDRESS
SECTSD # 2 ;NUMB OF SECTORS ON A SIDE OF DISC
SECTS # 2 ;NO. OF SECTS TO XFER
DCRASH # 1 ;DISC CRASH INDICATION
 [ BBC=0
DSCCB # Length+4
SAVCOM # 1
TRACK # 1
SECTOR # 1
DDRSTA # 2
DDRSPA # 2
DDRSZE # 2
DDRSCT # 2
CNTA # 1
SECTNO # 1
DFNAME # 10
DFLOAD # 2
DFEXEC # 2
DFSIZE # 3
DFQUAL # 10
DFSECT # 10
RAMADR # 2
 ]
INTROT # 2 ;USED FOR A FILE TITLE (INIT)
USERNM # MAXUNM+1 ;HOLDS A USERID
BREGA # 3
 [ BBC=0
RXTAB # 1
RXCBN # 1
 ]
RXCBV # 0 ;RECEIVE CONTROL BLOCK VECTOR
CBFLG # 1 ;RECEIVE C.B. FIELDS
CBPORT # 1
CBSTID # 2
 [ SYS=0
CBBUF # 2
CBBUFE # 2
 |
CBBUF # 4
CBBUFE # 4
 ]
RXBUF # 1 ;Receive buffer
FCODE # 1 ;FN. code
CPUFD # 1
CPCSD # 1
CPLIB # 1
MIDRX # RXBUFL+RXBUFL+1-(MIDRX-RXBUF) ;**8/2/88**
RXBUFT # 1
TXBUF # 0
CCODE # 1 ;Command code
RTCODE # 1
MIDTX # &2E


;OTHER VARIABLES
COTEMP # 2
COWORK # 0
DETRAM # 0
DETNAM # INFNXT ;DETAILS FROM RETRIEVE
DETACC * DETNAM+INFACC
DETSIN * DETNAM+INFSIN
DETDIS * DETNAM+INFDIS
DETSZ * DETNAM+INFSZE
TOSEND # 3
OFFSET # 3
GBBXFD # 3 ;Bytes xfd in CP GETBYTES (3 bytes)
GBEFLG # 1 ;End of file flag (CP GETBYTES)
TXTBUF # RXBUFL ;file title buffer
MAPTBF * TXTBUF ;Buffer MAPTB information in MAPMAN.MPREDR
QPTR # 1
BPTR # 1
CURBLK # 2
OUTBSZ # 2
BBUF # 2
BBSIZE # 2
BBEND # 2
DANDS # 5
DSCERR # 1
RPLYPT # 1
DATAIN # 3
FINFLG # 1
FILLFL # 1
TIMER # 1
TIMER1 # 1
TIMER2 # 1
QUOTED # 1
TXJ # 1
TXD # 1
TXF # 1
MONFLG # 1
OLDRXB # 2
CDIRTB # 2
CVTDRV # 1
FSDNO # 2
HNDROT # 1
QUALIF # 1
TXBYTS # 2
TXBLKS # 2
MEMEND # 2
 [ 1=0
TSTACK # 1 ;Store stack pointer in MAPMAN & CONVERT
 ]
OLDBRK # 2 ;Store BRK vector in MAPMAN & CONVERT
OFF1 # 1 ;ARG TO MOVBLK
OFF2 # 1 ;ARG TO MOVBLK
STRPTR # 2 ;Ptr. used in AUTMAN
PTREND # 2 ;Ptr. used in AUTMAN
RIPPLE # 1
EVCHAR # 1
IOBUF # 2 ;new big buffer
IOBSIZ # 2
IOEND # 2
ODSCMN # 11
MPNWFR # UTFRLN ;user free space calculation
MPscor # 2 ;Bitmap sector origin (MAPMAN)
MCopat # 3 ;"Already open at station m.n"

DYNSTA * @ ;START OF DYNAMICALLY ALLOCATED STORE

 LNK UADE03
