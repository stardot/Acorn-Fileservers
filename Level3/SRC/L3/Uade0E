 OPT UADE0E ;FILE > Uade0E
 TTL File server file UADE0E
;********************************
;* DIRMAN U T I L I T I E S  2  *
;********************************

DETALS ROUT
 CLC ;COPY CRNTEN DETAILS INTO INFPTR
 LDA CRNTEN
 ADCIM DRTITL
 STA MOVFRM
 LDA CRNTEN+1
 ADCIM 0
 STA MOVFRM+1
 LDYIM INFDIS-1 ;COPY LOAD ADDR -> SIN
10 LDAIY MOVFRM
 STAIY INFPTR
 DEY
 BPL #10

;COPY DISC NO & SIZE OF OBJECT INTO DETAILS AREA

 JSR CRNSIN ;OBJSIN := SIN OF CRNTEN
 JMP RETDSZ

;********** MAKDIR RTN **********

;MAKDIR : CREATE A VIRGIN DIR

;ENTRY: DRDISC = DISC NUMBER
;DIRTMP := SIZE OF DIR REQUIRED(APPROX)
;EXRTN := SIN of parent, or zero if none (not coded)

;EXIT: A := RC
;ARGPTR STACK INITIALISED FOR PRESERVE


MAKDIR ROUT
 LDAIM 1 ;MapMan.CreateSpace
 JSR SETDSA ;PUT DISC NO ON NEWARG STACK
 LDYIM ARGD
 LDA DIRTMP
 STAIY NEWARG ;LS(SIZE)
 INY
 LDA DIRTMP+1 ;DIRTMP := SIZE OF NEW DIR
 STAIY NEWARG ;CS(SIZE)
 INY
 LDA DIRTMP+2
 STAIY NEWARG ;MS(SIZE)

 JSR JUSING ;pass pointer to user info **3/10/84**

 JSR MAPMAN ;MAPMAN.CREATE SPACE
 BNE #20

;SETUP DETAILS ON ARGPTR STACK FOR RETAIN RTN

 LDYIM ARGD
 LDAIY NEWARG
 STA DIRSIN
 LDYIM ARGQ
 STAIY ARGPTR
 LDYIM ARGE
 LDAIY NEWARG
 STA DIRSIN+1
 LDYIM ARGR
 STAIY ARGPTR
 LDYIM ARGF
 LDAIY NEWARG
 STA DIRSIN+2 ;DIRSIN := SIN OF NEW DIR
 LDYIM ARGS
 STAIY ARGPTR
 JSR DIROBJ ;OBJSIN := SIN OF NEW DIR

 LDYIM ARGF
 LDAIM 0
10 STAIY ARGPTR ;LOAD ADDR:=EXEC ADDR:=0
 INY
 CPYIM ARGN
 BCC #10

 LDAIM TYPDIR+LOCKED
 STAIY ARGPTR ;TYPE & ACCESS INFO
 
 INY
 LDA DATE
 STAIY ARGPTR
 INY
 LDA DATE+1
 STAIY ARGPTR ;DATE CREATED

 JSR LOADDR ;LOAD DIR INTO STORE
 BEQ #30

 CMPIM DRERRB
 BEQ #25 ;Press on here, but relock directory

;IF WE CANNOT LOAD IT THEN CLEAN UP

 PHA ;REMEMBER RC
 JSR ARGOBJ ;OBJSIN:=SIN OF NEWDIR
 JSR DELB ;FREE SPACE ALLOCATED IN DISC MAP
 PLA
20 RTS

;CLEAR DRFRST -> DRENTS

25 JSR INCCNT ;Relock broken directory **25/12/86**

30 LDA DIRSTA
 STA CLRPTR
 STA GENPTR
 LDA DIRSTA+1
 STA CLRPTR+1
 STA GENPTR+1
 LDYIM DRSTAR+DRENSZ ;**23/1/87** zero first entry also
 LDXIM 0
 JSR CLRSTR

;Make dummy unchained first entry for parent ptr **23/1/87**

 LDYIM DRSTAR
 LDAIM &FF
 STAIY GENPTR ;mark entry not chained
 INY
 STAIY GENPTR
 LDYIM DRSTAR+DRSIN
 LDA EXRTN ;copy SIN of parent
 STAIY GENPTR
 INY
 LDA EXRTN+1
 STAIY GENPTR
 INY
 LDA EXRTN+2
 STAIY GENPTR

;NOW FORMAT IT

 CLC
 LDA DIRSTA
 ADCIM DRSTAR+DRENSZ ;**23/1/87**
 STA CRNTEN
 LDA DIRSTA+1
 ADCIM 0
 STA CRNTEN+1 ;CRNTEN PTS TO FIRST ENTRY TO BE MARKED FREE
 JSR FORMAT
 BEQ #40

 JSR DELOBJ ;DELETE THE OBJECT

40 RTS

;FORMAT: RTN TO INCREASE THE NO OF FREE ENTRIES IN A DIR

;ENTRY:OBJSIN = SIN OF DIR
;CRNTEN = PTR TO NEXT POSN TO BE PLACED ON FREE CHAIN
;DIRTMP = SIZE OF DIR (IN BYTES)
;DPTRLD = PTR TO FIRST BYTE OF DIR

;EXIT : A = RC
;N.B. CRNTEN & DIRTMP ARE DESTROYED
;DPTRTR IS UPDATED


FORMAT ROUT
 JSR DECCRN ;CRNTEN -:=DRENSZ

 CLC ;WE WANT TO SUBTRACT ONE AS WELL
 LDA DIRTMP
 SBCIM DRENSZ
 STA DIRTMP
 BCS #05
 DEC DIRTMP+1 ;N.B. WE SUBTRACT ONE FOR THE TRAILING SQ NO

05 CLC
 LDA DIRTMP
 ADC DIRSTA
 STA DIRTMP
 LDA DIRTMP+1
 ADC DIRSTA+1
 STA DIRTMP+1 ;DIRTMP:=DIRSTA+DIRSIZE-DRENSZ-1

10 JSR INCCRN ;CRNTEN +:= DRENSZ

 LDA DIRTMP
 CMP CRNTEN
 LDA DIRTMP+1
 SBC CRNTEN+1
 BCC #20 ;BRANCH IF CRNTEN > DIRTMP

 JSR FREECH ;PLACE CRNTEN ON THE FREE CHAIN
 JMP #10

;NOW SHRINK THE DIR TO AN 'EXACT' SIZE

20 LDAIM 3
 JSR SETDSA ;PLACE DISCNO & OBJSIN ON NEWARG STACK

 LDA CRNTEN
 STA DIRSZE
 STA DPTRTR
 LDA CRNTEN+1
 STA DIRSZE+1 ;DIRSZE := CRNTEN
 STA DPTRTR+1 ;DPTRTR := PTR TO LAST BYTE OF DIR (SQ.NO.)
 INC DIRSZE ;ADD ON 1 FOR TRAILING SQ. NO.
 BNE #30
 INC DIRSZE+1 ;DIRSZE := CRNTEN + 1
30 SEC
 LDA DIRSZE
 SBC DIRSTA
 STA DIRSZE
 LDYIM ARGG
 STAIY NEWARG ;LS(SIZE)
 LDA DIRSZE+1
 SBC DIRSTA+1
 STA DIRSZE+1 ;DIRSZE := CRNTEN + 1 - DIRSTA
 INY
 STAIY NEWARG ;CS(SIZE)
 INY
 LDAIM 0
 STAIY NEWARG

 JSR JUSINF ;** 3/10/84 **

 JSR MAPMAN ;MAPMAN.CHANGESIZE
 BNE #40

;NOW INSERT TRAILING SQ. NO. AND THEN

 LDYIM DRSQNO
 LDAIY DPTRLD
 LDYIM 0
 STAIY DPTRTR ;SET TRAILING SQ. NO. = LEADING SQ. NO.

;NOTE FORMAT DOES NOT ENSURE THE DIR OR THE MAP.
;SO WE MARK THE DIR DIRTY IN CASE IT GETS REMOVED FROM THE CACHE.

 LDA DPTRLD
 STA GENPTR
 LDA DPTRLD+1
 STA GENPTR+1
 JSR MRKDRT ;MARK IT DIRTY

 LDAIM 0 ;RC := 0

40 RTS

JUSING LDYIM ARGB ;21/12/84
 LDAIY ARGPTR ;passed in original call
 TAX
 INY
 LDAIY ARGPTR

 LDYIM ARGH
 STAIY NEWARG
 DEY
 TXA
 STAIY NEWARG
 RTS

DECCRN ROUT
 SEC ;CRNTEN -:= DRENSZ
 LDA CRNTEN
 SBCIM DRENSZ
 STA CRNTEN
 BCS #10
 DEC CRNTEN+1
10 RTS



;********* EXAMINE UTILS ********


;ALL INFO IN MACHINE READABLE FORM
;AND FILE TITLE.

;ON ENTRY, INFPTR POINTS TO RESULT
;AREA. ON EXIT, INFPTR POINTS TO
;BYTE AFTER RESULT.

EXRTNA ROUT
 JSR MOVEFT ;10 BYTE FILE TITLE

 LDYIM DRLOAD
 LDXIM 0

;MOVE ALL OTHER INFO FROM DIR. TO
;RESULT AREA.

05 LDAIY CRNTEN
 STAIX INFPTR
 JSR INCIPT
 INY
 CPYIM DRENSZ
 BNE #05
 JSR CRNSIN ;GET SIN OF CURRENT ENTRY
 JSR SINSZE ;GET SIZE ON STACK
 BNE #20
 LDYIM ARGB ;COPY SIZE -> INFO AREA
 LDXIM 0
10 LDAIY NEWARG
 STAIX INFPTR
 JSR INCIPT
 INY
 CPYIM ARGE
 BNE #10
 TXA ;Successful exit
20 RTS


;ALL INFORMATION, FORMATTED IN CHAR. STRING

EXRTNB ROUT
 JSR OUTENT ;Output entry details
 BNE #10

ERTNBZ LDAIM ENTTRM ;Terminate string
 JSR OUTCH
 LDAIM 0
10 RTS


OUTENT ROUT
 JSR MOVEFT ;Print file title
 JSR OUTSP
 JSR OUTLEX
 JSR OUTSZE
 BNE #10 ;Map error
OUTEN2 JSR OUTACC
 LDXIM 4
 JSR OUTSPS
 JSR OUTDAT
 JSR OUTSIN
 LDAIM 0 ;Successful exit
10 RTS


;FILE TITLE + TITLE LENGTH, M/C READABLE

EXRTNC ROUT
 LDXIM 0
 LDAIM NAMLNT
 STAIX INFPTR ;File title length
 JSR INCIPT
 JSR MOVEFT ;Note pointer to locn. after f.t.
 LDAIM 0
 RTS ;Successful exit



;FILE TITLE + ACCESS IN CHAR FORM

EXRTND ROUT
 JSR MOVEFT
 JSR OUTSP
 JSR OUTACC
 JMP ERTNBZ


;*** MINOR UTILITIES ***


;MOVE FILE TITLE FROM DIRECTORY TO
;!INFPTR. ON EXIT, INFPTR POINTS TO
;BYTE AFTER FILE TITLE.

MOVEFT ROUT
 LDYIM DRTITL
 LDXIM 0
10 LDAIY CRNTEN
 STAIX INFPTR
 INY
 JSR INCIPT
 CPYIM DRTITL+NAMLNT
 BCC #10
 RTS


OUTZRO LDXIM  8
 LDAIM "0" ;Used to put out root load/exec addresses
OUTZLP JSR OUTCH
 DEX
 BNE OUTZLP
 RTS


OUTSPS JSR OUTSP
 DEX
 BNE OUTSPS
 RTS



;OUTPUT A SPACE AND INCREMENT INFPTR.

OUTSP LDAIM SPACE
OUTCH STX DMSTX
 LDXIM 0
 STAIX INFPTR
 LDX DMSTX
 JMP INCIPT ;INCREMENT POINTER


;FOUR BYTES IN REVERSE ORDER IN HEX
;FROM CURRENT DIR. ENTRY

;Y POINTS TO CURRENT ENTRY DATA.

OUTHEX INY
 INY
 INY
 LDAIM 0
 STA FILLFL ;Set space fill ON
 LDAIY CRNTEN
 JSR OUTBYT ;TOP DIGIT
 DEY
 LDAIY CRNTEN
 JSR OUTBYT
 DEY
 LDAIY CRNTEN
 JSR OUTBYT ;TWO DIGITS
 DEY
 LDAIY CRNTEN ;Fall into OUTBYT


;OUTPUT TOP OF A IN HEX

OUTBYT ROUT
 PHA
 LSRA
 LSRA
 LSRA
 LSRA
 JSR OUTDIG

 PLA
OUTDIG ANDIM &F
 BNE #10 ;Non-zero, don't worry about fill
 BIT FILLFL
 BPL #10 ;Switch -ev => fill space
 LDAIM SPACE
 BNE OUTCH ;Space and exit

10 PHA
 LDAIM 0
 STA FILLFL ;Printing a digit, so switch leading 0's off
 PLA
 CMPIM &A
 BCC #20
 ADCIM 6
20 ADCIM &30
 BNE OUTCH


;THREE BYTE SIN IN HEX

OUTSIN LDYIM DRSIN+2
 LDAIM 0
 STA FILLFL

 LDAIY CRNTEN
 JSR OUTBYT
 DEY
 LDAIY CRNTEN
 JSR OUTBYT
 DEY
 LDAIM 0
 STA FILLFL ;Switch leading spaces off
 LDAIY CRNTEN
 JMP OUTBYT


;OUTPUT DATE TO INFPTR IN DD/MM/YY FORMAT

OUTDAT ROUT
 LDYIM DRDATE
 LDAIY CRNTEN
 STA TDATE
 INY
 LDAIY CRNTEN
 STA TDATE + 1

OUTRTD

;ENTRY POINT FOR PRINTING ROOT DATE, SET IN
;TDATE DURING INITDV

 LDA TDATE
 JSR OUTDEC

 LDAIM ":"
 JSR OUTCH

 LDA TDATE + 1
 PHA
 ANDIM &F
 JSR OUTDEC ;MONTH
 LDAIM ":"
 JSR OUTCH

 PLA
 LSRA
 LSRA
 LSRA
 LSRA
 CLC

;ADD TO GET BASEYR

 ADCIM BASEYR
 JSR OUTDEC
 JMP OUTSP



;OUTPUT A IN DECIMAL. NOTE A IS
;ASSUMED <100 COZ ROUTINE ONLY
;USED IN WRITING DATE.

OUTDEC ROUT
 LDXIM &FF ;TOP DIGIT IS IN X
 SEC
10 INX
 SBCIM &A
 BCS #10 ;IF >=10, CARRY ON
 ADCIM &A
 PHA
 TXA ;OUTPUT TOP DIGIT
 JSR #20
 PLA
20 CLC
 ADCIM "0"
 JMP OUTCH



;OUTPUT ACCESS BYTE AS A PADDED
;CHAR STRING, 7 BYTE LONG. ON
;EXIT, INFPTR POINTS TO BYTE AFTER
;ACCESS STRING.

OUTACC ROUT
 LDYIM DRACCS ;OFFSET IN DIR. ENTRY
 LDAIY CRNTEN
 ASLA ;ONE LEFT SO ACCESS BITS ROTATED INTO B.7
OUTACA
 LDXIM 0
 LDYIM 0

;LOOP ROUND FIRST FOUR ACCESS FIELDS

10 JSR OACCCH
 INX
 CPXIM 4
 BNE #10

 PHA
 LDAIM "/"
 JSR OUTCH
 PLA

 JSR OACCCH ;OWNER ACCESS WRITE
 INX

;FINALLY OWNER ACCESS READ
 JSR OACCCH

;NOW PAD TO THE RIGHT, Y BEING
;NO OF SPACES NEEDED.

20 JSR OUTSP
 DEY
 BNE #20
 RTS

ACCTAB = "DLWRWR"

OACCCH ASLA
 PHA
 BMI #40
 INY ;ACCESS NOT SET, INC SPACE COUNT
 PLA
 RTS

40 LDAAX ACCTAB
 JSR OUTCH
 PLA
 RTS


;GET SIZE FROM MAP AND OUTPUT IN
;HEX (3 BYTES, 5 DIGITS).

OUTSZE ROUT
 JSR CRNSIN ;SET CURRENT SIN TO A VARIABLE
OUTSZA
 JSR SETDSN ;SET DISC NO. + SIN ON STACK
 JSR SINSZE ;GET SIZE FROM MAP
 BNE #20 ;ERROR ... EXIT

 LDYIM ARGD ;TOP BYTE OF SIZE
 LDAIM 0 ;NO leading spaces
 STA FILLFL
 LDAIY NEWARG
 JSR OUTBYT ;TOP DIGIT

 DEY
 LDAIY NEWARG
 JSR OUTBYT

 DEY
 LDAIY NEWARG
 JSR OUTBYT
 LDXIM 3
 JSR OUTSPS
 LDAIM 0 ;SUCCESSFUL EXIT

20 RTS



INCIPT ROUT
 INC INFPTR
 BNE #10
 INC INFPTR+1
10 RTS




;CHECK THAT THE NUMBER OF ENTRIES
;ASKED FOR OF A CERTAIN TYPE OF
;EXAMINE IS LESS THAN MAX. NO.

ENTTAB = MAXENA
 = MAXENB
 = MAXENC
 = MAXEND

CHKENS ROUT ;CHKENS
 LDX EXARG
 CPXIM 4
 BEQ #10 ;Asking for dir.name only, exit, C clear
 CMPIM 0 ;**1/5/87** If zero, set to max
 BEQ #05
 CMPAX ENTTAB
 RTS

05 LDAAX Enttab ;**1/5/87** load max for exam type
10 CLC
 RTS



;************ RETAIN *************

;RETAIN: RTN TO RETAIN A SIN IN A
;SPECIFIED DIRECTORY, WITH
;GIVEN FILE NAME.

;ENTRY: ARGUMENTS ON ARGPTR STACK, AS SPECIFIED
;FOR DIRMAN.DRPRES.

;EXIT :
;A = RC
;ARGB-C DISC NO
;ARGD-F SIN OF OBJECT TO BE DELETED

;NOTE OBJSIN CAN BE DESTROYED BY RETAIN

;FUNCTION:

;IF TYPE = TYPDIR
;THEN PUT LAST COMPONENT OF FILE TITLE IN DIR HEADER
;FI;
;IF ENTRY ALREADY EXISTS
;THEN CHECK THAT IT MAY BE DELETED;
;CHECK THAT TYPES AGREE;
;CALL MAPMAN.ENSURE(MAP)
;NOTE SIN OF OBJECT TO BE DELETED;
;UPDATE DIR ENTRY (all except access - including name);
;ENSURE DIRECTORY UPTO DATE ON DISC;
;RETURN(success,disc no,sin)
;ELIF ROOM FOR A NEW ENTRY
;THEN CALL MAPMAN.ENSURE(MAP);
;UPDATE DIRECTORY;
;ENSURE DIR UPTO DATE ON DISC;
;RETURN(success,0,0)
;ELSE RETURN(directory full)
;FI

RETAIN ROUT
 LDAIM &FF
RETA12 STA TEMPA ;skip DELCHK entry point
 JSR LOADTX
 LDA TXTNAM ;**1/6/87** prohibit pseudo-directory names
 JSR Testpd
 BNE #10
 LDA TXTNAM+1
 CMPIM &20
 BNE #10
 LDAIM DRERRA
 BNE #15

10 JSR FNDTEX ;DOES TEXT NAME ALREADY EXIST ?
 BNE #40

;ENTRY ALREADY EXISTS

 LDA TEMPA ;check entry point
 BEQ #25 ;skip if RENAME involved ** 25/9/84 **

 JSR DELCHK ;CAN IT BE DELETED ?
 BEQ #25
15 JSR UNLOCK ;UNLOCK THE LOADED DIR
20 RTS

;SEE IF TYPES MATCH

25 LDYIM ARGN
 LDAIY ARGPTR ;TYPE & ACCESS OF OBJECT TO BE PRESERVED
 ANDIM TYPE
 STA TEMPA
 LDYIM DRACCS
 LDAIY CRNTEN
 STA OBJACC ;OBJACC:=OLD ACCESS FIELD IN DIR
 ANDIM TYPE
 CMP TEMPA
 BEQ #30
 LDAIM DRERRK ;TYPES DON'T MATCH
 BNE #15


30 JSR RATDIR
 BNE #15
 JSR ENSMAP
 BNE #20
 
 JSR CRNSIN ;OBJSIN:=SIN OF OBJECT TO BE DELETED
 JSR COPYDT ;COPY OBJECT DETAILS INTO DIR
 JSR COPYNM ;Copy name TXTNAM -> dir. entry
 LDYIM DRACCS ;BUT KEEP OLD ACCESS FIELD
 LDA OBJACC
 STAIY CRNTEN
 JSR ARGDSN ;MOVE DISC NO & OBJSIN ONTO ARGPTR STACK
 JMP ENSRIT ;STRMAN.ENSURE(DIR)

;MAKE A NEW DIR ENTRY

40 JSR SETFRE ;DIRFRE := ADDR OF FREE ENTRY PTR
 BNE #50
 JSR UNLOCK

;THE DIR IS FULL SO TRY AND INCREASE ITS SIZE

 JSR CHZSZE ;INCREASE DIR SIZE
 BNE #20
 JSR LOADDR ;RELOAD THE DIR
 BEQ #10 ;TRY AGAIN
 RTS ;Failed, exit (directory unlocked) **25/12/86**

50 JSR RATDIR ;IF DIR THEN UPDATE NAME IN HEADER
 BNE #15
 JSR ENSMAP
 BNE #15
 
;REMOVE ENTRY FROM FREE CHAIN AND INSERT
;IT IN APPROPRIATE POSITION, ON THE IN USE CHAIN.

 LDYIM DRLINK
 LDAIY PREVEN
 STA TEMPA
 INY
 LDAIY PREVEN
 STA TEMPA+1 ;TEMPA := [PREVEN]

 DEY  ;Y:= DRLINK
 LDAIY DIRFRE
 STAIY PREVEN
 INY
 LDAIY DIRFRE
 STAIY PREVEN ;[PREVEN] := [DIRFRE]

 JSR SETCRN ;CRNTEN := STORE ADDRESS OF [DIRFRE]

 LDYIM DRLINK
 LDAIY CRNTEN
 STAIY DIRFRE
 INY
 LDAIY CRNTEN
 STAIY DIRFRE ;[DIRFRE] := [CRNTEN]
 DEY  ;Y:=DRLINK
 LDA TEMPA
 STAIY CRNTEN
 INY
 LDA TEMPA+1
 STAIY CRNTEN ;[CRNTEN] := TEMPA

;INCREMENT DIR ENTRY COUNT

 JSR SETGEN ;GENPTR := [DIRSTA]

 CLC
 LDYIM DRENTS
 LDAIY GENPTR
 ADCIM 1
 STAIY GENPTR
 INY
 LDAIY GENPTR
 ADCIM 0
 STAIY GENPTR ;[DIRSTA + DRENTS] +:= 1

;COPY TEXT NAME INTO DIR ENTRY

 JSR COPYNM

;COPY DETAILS ON ARGPTR STACK INTO DIR ENTRY

 JSR COPYDT
 JSR ENSRIT ;STRMAN.ENSURE(directory)
 JSR ARGDSN ;Copy Disc & SIN to stack, then zero SIN

;CLEAR SIN TO ZERO

 LDAIM 0
 LDYIM ARGD
 LDXIM 3
70 STAIY ARGPTR ;:=0
 INY
 DEX
 BNE #70
80 RTS


;RATDIR: IF RETAINING A DIR - WE COPY INTO ITS HEADER
;THE LAST COMPONENT OF A FILE TITLE.
;THIS IS THE DIR'S NAME & PROVIDED FOR THOSE
;CLIENTS WANTING TO DISPLAY A DIR'S NAME
;DURING EXAMINE.

RATDIR LDYIM ARGN
 LDAIY ARGPTR
 ANDIM TYPDIR
 BEQ #80

;AS WE ARE RETAINING A DIR WE MUST COPY THE CONTENTS
;OF TXTNAM INTO THE HEADER OF THIS DIR.

 JSR ARGOBJ ;OBJSIN:=SIN OF OBJECT TO BE PRESERVED
 JSR SINSZE ;FIND OUT THE DIR'S SIZE
 BNE #80
 LDYIM ARGE
 LDAIY NEWARG ;LS(NO OF BLOCKS)
 PHA
 INY
 LDAIY NEWARG ;MS(NO OF BLOCKS)
 PHA
 LDAIM 1
 JSR SETDSA ;PUT DISCNO & OBJSIN ON NEWARG STACK
 INY
 LDAIM 0
 STAIY NEWARG
 INY
 STAIY NEWARG ;BLOCK NO. = 0
 PLA
 LDYIM ARGJ
 STAIY NEWARG ;MS(NO OF BLOCKS)
 PLA
 DEY  ;Y:= ARGI
 STAIY NEWARG ;LS(NO OF BLOCKS)
 JSR STRMAN ;STRMAN.DISC ADDR->STORE ADDR
 BNE #80

;NOW THE DIR IS LOADED - SO COPY THE CONTENTS OF
;TXTNAM INTO THE HEADER OF THE DIR

 LDYIM ARGB
 LDAIY NEWARG
 STA GENPTR
 INY
 LDAIY NEWARG
 STA GENPTR+1
 CLC
 LDA GENPTR
 ADCIM DRNAME
 STA MOVTO
 LDA GENPTR+1
 ADCIM  0
 STA MOVTO+1
 LDAIM :LSB:TXTNAM
 STA MOVFRM
 LDAIM :MSB:TXTNAM
 STA MOVFRM+1
 LDXIM NAMLNT
 JSR MOVE

 LDYIM DRSTAR ;**08/02/87** 
 LDAIM &FF
 CMPIY GENPTR ;parent pointer in first entry?
 BNE #90
 INY
 CMPIY GENPTR
 BNE #90
 LDYIM DRSTAR+DRSIN ;yes, update to current parent
 LDA DIRSIN
 STAIY GENPTR
 INY
 LDA DIRSIN+1
 STAIY GENPTR
 INY
 LDA DIRSIN+2
 STAIY GENPTR

90 JSR MRKDRT ;MARK IT DIRTY
 LDAIM 2
 JSR SETRTN ;N.B. STR ADDR ALREADY ON NEWARG STACK
 LDYIM ARGD
 LDAIM UNLKIT
 STAIY NEWARG ;ENSURE & UNLOCK THE DIR
 JMP STRMAN


;COPY LOAD ADDR -> SIN, WHICH ARE ON ARGPTR STACK,
;INTO THE DIR ENTRY POINTED TO BY CRNTEN.

COPYDT LDAIM ARGF
 STA OFF1 ;Move from offset
 LDAIM DRLOAD
 STA OFF2 ;Move to offset
 LDXIM ARGPTR ;Move from ptr.
 LDYIM CRNTEN ;Move to ptr.
 LDAIM &E ;Move 14 bytes
 JMP MOVBLK


;Copy object name from TXTNAM to dir. entry

COPYNM LDAIM :LSB:TXTNAM
 STA MOVFRM
 LDAIM :MSB:TXTNAM
 STA MOVFRM+1
 CLC
 LDA CRNTEN
 ADCIM DRTITL
 STA MOVTO
 LDA CRNTEN+1
 ADCIM 0
 STA MOVTO+1
 LDXIM NAMLNT
 JMP MOVE


INCCRN ROUT
 CLC  ;CRNTEN +:= DRENSZ
 LDA CRNTEN
 ADCIM DRENSZ
 STA CRNTEN
 BCC #10
 INC CRNTEN + 1
10 RTS


ARGOBJ LDYIM ARGQ ;OBJSIN:=SIN OF OBJECT TO BE PRESERVED
 LDAIY ARGPTR
 STA OBJSIN
 INY
 LDAIY ARGPTR
 STA OBJSIN+1
 INY
 LDAIY ARGPTR
 STA OBJSIN+2
 RTS


ENSMAP JSR ARGOBJ ;ENSURE OBJECT'S MAP IS UPTO DATE ON DISC
ENSOMP LDAIM 6
 JSR SETDSA ;PUT DISC NO & OBJSIN ON NEWARG STACK
 JMP MAPMAN ;MAPMAN.ENSUREMAP


DELOBJ ROUT
 PHA  ;REMOVE NEWDIR FROM CACHTB
 JSR ARGOBJ ;OBJSIN:=SIN OF OBJECT WHICH WAS TO BE PRESERVED

 JSR REMOVE ;remove the cache entry
 TAX ;save RC
 PLA
 BNE #10
 TXA ;substitute RC here
10 CMPIM &C9 ;look for 'write protect'
 BEQ #30
 PHA
 JSR DELB ;rest of DLETIT
 TAX ;save RC
 PLA ;get old RC
 BNE #30 ;skip if there is previous error
 TXA ;else return new error
30 RTS


DELB ROUT
 LDAIM 2
 JSR SETDSA
 JSR JUSING ;** 21/12/84 **
 JSR MAPMAN ;MAPMAN.FREESPACE
 BNE #10
 LDAIM 6
 JSR SETDSA
 JSR MAPMAN ;MAPMAN.ENSURE MAP
 BEQ #20
10 JSR INTERR
20 RTS


REMOVE LDAIM 5
 JSR SETDSA ;REMOVE OBJSIN FROM CACHE
 JMP STRMAN ;STRMAN.REMOVE


;INCREASE THE SIZE OF A DIR

;ENTRY: DIRSIN = SIN OF DIR TO HAVE ITS SIZE CHANGED
;EXIT: A = RC

CHZSZE ROUT
 JSR DIROBJ ;OBJSIN := DIRSIN
 JSR REMOVE ;REMOVE OBJSIN FROM THE CACHE
 JSR SINSZE
 BNE #10
 LDYIM ARGB
 LDAIY NEWARG
 STA CRNTEN
 INY
 LDAIY NEWARG
 STA CRNTEN+1 ;CRNTEN:=EXACT CURRENT SIZE OF DIR
 LDYIM ARGE
 LDAIY NEWARG
 STA BREGA
 INY
 LDAIY NEWARG
 STA BREGA+1 ;BREGA := NUMBER OF BLOCKS
 LDAIM 0
 STA BREGA+2
 JSR MULTBS ;BREGA *:= BLKSZE
 CLC
 LDA BREGA
 ADCIM :LSB:BLKSZE
 STA DIRTMP
 LDA BREGA+1
 ADCIM :MSB:BLKSZE
 STA DIRTMP+1 ;DIRTMP:=SIZEOFDIR+BLKSZE(INTEGRAL NB OF BLKS)

;TEST FOR MAX SIZE OF DIR ALLOWED

 LDAIM :LSB:MAXDIR
 CMP DIRTMP
 LDAIM :MSB:MAXDIR
 SBC DIRTMP+1
 BCS #20
 LDAIM DRERRM
10 RTS 


20 LDAIM 3
 JSR SETDSA
 INY
 LDA DIRTMP
 STAIY NEWARG ;LS(NEW SIZE)
 INY
 LDA DIRTMP+1
 STAIY NEWARG ;CS(NEW SIZE)
 INY
 LDAIM 0
 STAIY NEWARG ;MS(NEW SIZE)

 JSR JUSINF ;** 3/10/84 **

 JSR MAPMAN ;MAPMAN.CHANGESIZE
 BNE #30

 JSR LDDR ;LOAD CURRENT DIR
 BNE #30

 LDA CRNTEN
 BNE #25
 DEC CRNTEN+1 
25 DEC CRNTEN ;CRNTEN-:=1(TO OVERWRITE OLD TRALNG SQ NO)
 CLC
 LDA DIRSTA
 ADC CRNTEN
 STA CRNTEN
 LDA DIRSTA+1
 ADC CRNTEN+1
 STA CRNTEN+1 ;CRNTEN PTS TO NEXT ENTRY TO BE MADE FREE

 JSR FORMAT ;FORMAT DIR

 JSR ENSRIT ;ENSURE ITS UPTO DATE ON DISC & UNLOCKIT
 BNE #30
;ENSURE THE OBJECT MAP

 JSR ENSOMP ;N.B. OBJSIN MUST = SIN OF DIR
 BEQ #30
 JSR INTERR

30 RTS

 LNK UADE0F
