 OPT UADE0E ;FILE > Uade0E
 TTL File server file UADE0E
;********************************
;* DIRMAN U T I L I T I E S  2  *
;********************************
DETALS CLC  ;COPY CRNTEN DETAILS INTO INFPTR
 LDA CRNTEN
 ADCIM DRTITL
 STA MOVFRM
 LDA CRNTEN + 1
 ADCIM  0
 STA MOVFRM + 1
 LDYIM  0
 LDXIM INFDIS ;COPY LOAD ADDR -> SIN
DETASB LDAIY MOVFRM
 STAIY INFPTR
 INY
 DEX
 BNE DETASB

;COPY DISC NO & SIZE OF OBJECT INTO DETAILS AREA

 JSR CRNSIN ;OBJSIN := SIN OF CRNTEN
 JSR RETDSZ

 RTS

;********** MAKDIR RTN **********

;MAKDIR : CREATE A VIRGIN DIR

;ENTRY: DRDISC = DISC NUMBER
;DIRTMP := SIZE OF DIR REQUIRED(APPROX)
;EXIT: A := RC
;ARGPTR STACK INITIALISED FOR PRESERVE


MAKDIR LDAIM 1
 JSR SETRTN ;MapMan.CreateSpace
 JSR SETDSN ;PUT DISC NO ON NEWARG STACK
 LDYIM ARGD
 LDA DIRTMP
 STAIY NEWARG ;LS(SIZE)
 INY
 LDA DIRTMP + 1 ;DIRTMP := SIZE OF NEW DIR
 STAIY NEWARG ;CS(SIZE)
 INY
 LDA DIRTMP + 2
 STAIY NEWARG ;MS(SIZE)

;** 3/10/84 **

 JSR JUSING ;pass pointer to user info


 JSR MAPMAN ;MAPMAN.CREATE SPACE
 BEQ MAKDRC
 JMP MAKDRZ

;SETUP DETAILS ON ARGPTR STACK FOR RETAIN RTN

MAKDRC LDYIM ARGD
 LDAIY NEWARG
 STA DIRSIN
 STA OBJSIN
 LDYIM ARGQ
 STAIY ARGPTR
 LDYIM ARGE
 LDAIY NEWARG
 STA DIRSIN + 1
 STA OBJSIN + 1
 LDYIM ARGR
 STAIY ARGPTR
 LDYIM ARGF
 LDAIY NEWARG
 STA DIRSIN + 2 ;DIRSIN := SIN OF NEW DIR
 STA OBJSIN + 2 ;OBJSIN := SIN OF NEW DIR
 LDYIM ARGS
 STAIY ARGPTR

 LDYIM ARGF
 LDAIM  0
 LDXIM  8
MAKDRD STAIY ARGPTR ;LOAD ADDR:=EXEC ADDR:=0
 INY
 DEX
 BNE MAKDRD

 LDAIM TYPDIR
 ORAIM LOCKED
 LDYIM ARGN
 STAIY ARGPTR ;TYPE & ACCESS INFO
 
 [ 1=0
 JSR SETDAT ;Read time chip if present
 ]
 LDYIM ARGO
 LDA DATE
 STAIY ARGPTR
 INY
 LDA DATE + 1
 STAIY ARGPTR ;DATE CREATED

 JSR LOADDR ;LOAD DIR INTO STORE
 BEQ MAKDRF

 CMPIM DRERRB
 BEQ MAKDRF

;IF WE CANNOT LOAD IT THEN CLEAN UP

 PHA  ;REMEMBER RC
 JSR UNLOCK
 JSR ARGOBJ ;OBJSIN:=SIN OF NEWDIR
 JSR DELB ;FREE SPACE ALLOCATED IN DISC MAP
 PLA
 BNE MAKDRZ

;CLEAR DRFRST -> DRENTS

MAKDRF LDA DIRSTA
 STA CLRPTR
 LDA DIRSTA + 1
 STA CLRPTR + 1
 LDYIM DRSTAR
 LDXIM  0
 JSR CLRSTR

;NOW FORMAT IT

 CLC
 LDA DIRSTA
 ADCIM DRSTAR
 STA CRNTEN
 LDA DIRSTA + 1
 ADCIM  0
 STA CRNTEN + 1 ;CRNTEN PTS TO FIRST ENTRY TO BE MARKED FREE
 JSR FORMAT
 BEQ MAKDRZ

 JSR DELOBJ ;DELETE THE OBJECT

MAKDRZ RTS

;FORMAT: RTN TO INCREASE THE NO OF FREE ENTRIES IN A DIR

;ENTRY:OBJSIN = SIN OF DIR
;CRNTEN = PTR TO NEXT POSN TO BE PLACED ON FREE CHAIN
;DIRTMP = SIZE OF DIR (IN BYTES)
;DPTRLD = PTR TO FIRST BYTE OF DIR

;EXIT : A = RC
;N.B. CRNTEN & DIRTMP ARE DESTROYED
;DPTRTR IS UPDATED


FORMAT JSR DECCRN ;CRNTEN -:=DRENSZ

 CLC  ;WE WANT TO SUBTRACT ONE AS WELL
 LDA DIRTMP
 SBCIM DRENSZ
 STA DIRTMP
 LDA DIRTMP + 1
 SBCIM  0
 STA DIRTMP + 1 ;N.B. WE SUBTRACT ONE FOR THE TRAILING SQ NO

 CLC
 LDA DIRTMP
 ADC DIRSTA
 STA DIRTMP
 LDA DIRTMP + 1
 ADC DIRSTA + 1
 STA DIRTMP + 1 ;DIRTMP:=DIRSTA+DIRSIZE-DRENSZ-1

FORMTD JSR INCCRN ;CRNTEN +:= DRENSZ

 LDA DIRTMP
 CMP CRNTEN
 LDA DIRTMP + 1
 SBC CRNTEN + 1
 BCC FORMTM ;BRANCH IF CRNTEN > DIRTMP

 JSR FREECH ;PLACE CRNTEN ON THE FREE CHAIN
 JMP FORMTD

;NOW SHRINK THE DIR TO AN 'EXACT' SIZE

FORMTM LDYIM ARGA
 LDAIM  3
 STAIY NEWARG
 JSR SETDSN ;PLACE DISCNO & OBJSIN ON NEWARG STACK

 LDA CRNTEN
 STA DIRSZE
 STA DPTRTR
 LDA CRNTEN + 1
 STA DIRSZE + 1 ;DIRSZE := CRNTEN
 STA DPTRTR + 1 ;DPTRTR := PTR TO LAST BYTE OF DIR (SQ.NO.)
 INC DIRSZE ;ADD ON 1 FOR TRAILING SQ. NO.
 BNE FORMTG
 INC DIRSZE + 1 ;DIRSZE := CRNTEN + 1
FORMTG SEC
 LDA DIRSZE
 SBC DIRSTA
 STA DIRSZE
 LDYIM ARGG
 STAIY NEWARG ;LS(SIZE)
 LDA DIRSZE + 1
 SBC DIRSTA + 1
 STA DIRSZE + 1 ;DIRSZE := CRNTEN + 1 - DIRSTA
 INY
 STAIY NEWARG ;CS(SIZE)
 INY
 LDAIM  0
 STAIY NEWARG

 JSR JUSINF ;** 3/10/84 **

 JSR MAPMAN ;MAPMAN.CHANGESIZE
 BNE FORMTZ

;NOW INSERT TRAILING SQ. NO. AND THEN

 LDYIM DRSQNO
 LDAIY DPTRLD
 LDYIM  0
 STAIY DPTRTR ;SET TRAILING SQ. NO. = LEADING SQ. NO.

;NOTE FORMAT DOES NOT ENSURE THE DIR OR THE MAP.
;SO WE MARK THE DIR DIRTY IN CASE IT GETS REMOVED FROM THE CACHE.

 LDA DPTRLD
 STA GENPTR
 LDA DPTRLD + 1
 STA GENPTR + 1
 JSR MRKDRT ;MARK IT DIRTY

 LDAIM  0 ;RC := 0

FORMTZ RTS

JUSING LDYIM ARGB ;21/12/84
 LDAIY ARGPTR ;passed in original call
 TAX
 INY
 LDAIY ARGPTR

 LDYIM ARGH
 STAIY NEWARG
 DEY
 TXA
 STAIY NEWARG
 RTS

DECCRN SEC  ;CRNTEN -:= DRENSZ
 LDA CRNTEN
 SBCIM DRENSZ
 STA CRNTEN
 LDA CRNTEN + 1
 SBCIM  0
 STA CRNTEN + 1
 RTS




;********* EXAMINE UTILS ********


EXRTNA

;ALL INFO IN MACHINE READABLE FORM
;AND FILE TITLE.

;ON ENTRY, INFPTR POINTS TO RESULT
;AREA. ON EXIT, INFPTR POINTS TO
;BYTE AFTER RESULT.

 JSR MOVEFT ;10 BYTE FILE TITLE

 LDYIM DRLOAD
 LDXIM  0

EXRALA   ;EXRALA

;MOVE ALL OTHER INFO FROM DIR. TO
;RESULT AREA.

 LDAIY CRNTEN
 STAIX INFPTR
 JSR INCIPT
 INY
 CPYIM DRENSZ
 BNE EXRALA
 JSR CRNSIN ;GET SIN OF CURRENT ENTRY
 JSR SINSZE ;GET SIZE ON STACK
 BNE ERTNAX
 LDYIM ARGB
 LDXIM  0 ;COPY SIZE -> INFO AREA
EXRALB LDAIY NEWARG
 STAIX INFPTR
 JSR INCIPT
 INY
 CPYIM ARGE
 BNE EXRALB
 TXA ;Successful exit

ERTNAX RTS




EXRTNB

;ALL INFORMATION, FORMATTED IN CHAR. STRING

 JSR OUTENT ;Output entry details
 BNE ERTNBX

ERTNBZ LDAIM ENTTRM ;Terminate string
 JSR OUTCH
 LDAIM  0
ERTNBX RTS


OUTENT JSR MOVEFT ;Print file title
 JSR OUTSP
 JSR OUTLEX
 JSR OUTSZE
 BNE OUTEE ;Map error
 JSR OUTACC
 LDXIM  4
 JSR OUTSPS
 JSR OUTDAT
 JSR OUTSIN
 LDAIM  0 ;Successful exit
OUTEE RTS



EXRTNC

;FILE TITLE + TITLE LENGTH, M/C READABLE

 LDXIM  0
 LDAIM NAMLNT
 STAIX INFPTR ;File title length
 JSR INCIPT
 JSR MOVEFT ;Note pointer to locn. after f.t.
 LDAIM  0
 RTS ;Successful exit




EXRTND


;FILE TITLE + ACCESS IN CHAR FORM

 JSR MOVEFT
 JSR OUTSP
 JSR OUTACC

 JMP ERTNBZ



;*** MINOR UTILITIES ***


MOVEFT

;MOVE FILE TITLE FROM DIRECTORY TO
;!INFPTR. ON EXIT, INFPTR POINTS TO
;BYTE AFTER FILE TITLE.

 LDYIM DRTITL
 LDXIM  0
 LDAIM NAMLNT ;NAME LENGTH
 STA DMTEMP

MFTLP LDAIY CRNTEN
 STAIX INFPTR
 INY
 JSR INCIPT
 DEC DMTEMP
 BNE MFTLP

 RTS



OUTZRO LDXIM  8
 LDAIM "0" ;Used to put out root load/exec addresses
OUTZLP JSR OUTCH
 DEX
 BNE OUTZLP
 RTS


OUTSPS JSR OUTSP
 DEX
 BNE OUTSPS
 RTS



OUTSP

;OUTPUT A SPACE AND INCREMENT INFPTR.

 LDAIM SPACE
OUTCH STX DMSTX
 LDXIM  0
 STAIX INFPTR
 LDX DMSTX
 JMP INCIPT ;INCREMENT POINTER


OUTHEX 

;FOUR BYTES IN REVERSE ORDER IN HEX
;FROM CURRENT DIR. ENTRY

;Y POINTS TO CURRENT ENTRY DATA.

 INY
 INY
 INY
 LDAIM  0
 STA FILLFL ;Set space fill ON
 LDAIY CRNTEN
 JSR OUTBYT ;TOP DIGIT
 DEY
 LDAIY CRNTEN
 JSR OUTBYT
 DEY
 LDAIY CRNTEN
 JSR OUTBYT ;TWO DIGITS
 DEY
 LDAIY CRNTEN
 JMP OUTBYT


OUTBYT   ;OUTBYT

;OUTPUT TOP OF A IN HEX

 PHA
 LSRA
 LSRA
 LSRA
 LSRA
 JSR OUTDIG

 PLA
OUTDIG ANDIM &F
 BNE ODON ;Non-zero, don't worry about fill
 BIT FILLFL
 BPL ODON ;Switch -ev => fill space
 LDAIM SPACE
 JMP OUTCH ;Space and exit

ODON PHA
 LDAIM  0 ;Printing a digit, so switch leading 0's off
 STA FILLFL
 PLA
 CMPIM &A
 BCC ODRTS
 ADCIM  6
ODRTS ADCIM &30
 JMP OUTCH


OUTSIN

;THREE BYTE SIN IN HEX

 LDYIM DRSIN + 2
 LDAIM &0
 STA FILLFL

 LDAIY CRNTEN
 JSR OUTBYT
 DEY
 LDAIY CRNTEN
 JSR OUTBYT
 DEY
 LDAIM  0
 STA FILLFL ;Switch leading spaces off
 LDAIY CRNTEN
 JMP OUTBYT





OUTDAT

;OUTPUT DATE TO INFPTR IN DD/MM/YY FORMAT

 LDYIM DRDATE
 LDAIY CRNTEN
 STA TDATE
 INY
 LDAIY CRNTEN
 STA TDATE + 1

OUTRTD

;ENTRY POINT FOR PRINTING ROOT DATE, SET IN
;TDATE DURING INITDV

 LDA TDATE
 
 [ Y2KPAT=1 ; Modify output for year 1997+
 JSR PUTDAT 
 LDAIM "/"
 |
 JSR OUTDEC

 LDAIM ":"
 ] 
 
 JSR OUTCH

 LDA TDATE + 1
 PHA
 ANDIM &F
 JSR OUTDEC ;MONTH

 [ Y2KPAT=1
 LDAIM "/"
 |
 LDAIM ":"
 ] 

 JSR OUTCH

 PLA
 LSRA
 LSRA
 LSRA
 LSRA
 CLC

;ADD TO GET BASEYR

 ADCIM BASEYR
 [ Y2KPAT=1
 JSR Y2KP25 
 |
 JSR OUTDEC
 ]
 
 JMP OUTSP



OUTDEC   ;OUTDEC

;OUTPUT A IN DECIMAL. NOTE A IS
;ASSUMED <100 COZ ROUTINE ONLY
;USED IN WRITING DATE.

 LDXIM &FF ;TOP DIGIT IS IN X
 SEC

ODLP INX
 SBCIM &A
 BCS ODLP ;IF >=10, CARRY ON

 ADCIM &A
 PHA

 TXA  ;OUTPUT TOP DIGIT
 JSR OUTNUM

 PLA

OUTNUM CLC
 ADCIM "0" ;CONVERT TO CHAR.
 JMP OUTCH




OUTACC

;OUTPUT ACCESS BYTE AS A PADDED
;CHAR STRING, 7 BYTE LONG. ON
;EXIT, INFPTR POINTS TO BYTE AFTER
;ACCESS STRING.

 LDYIM DRACCS ;OFFSET IN DIR. ENTRY
 LDAIY CRNTEN
 ASLA  ;ONE LEFT SO ACCESS BITS ROATATED INTO B.7
OUTACA LDXIM  0
 LDYIM  0

;LOOP ROUND FIRST FOUR ACCESS FIELDS

OALP JSR OACCCH
 INX
 CPXIM  4
 BNE OALP

 PHA
 LDAIM "/"
 JSR OUTCH
 PLA

 JSR OACCCH ;OWNER ACCESS WRITE
 INX

;FINALLY OWNER ACCESS READ
 JSR OACCCH

;NOW PAD TO THE RIGHT, Y BEING
;NO OF SPACES NEEDED.

OALPA JSR OUTSP
 DEY
 BNE OALPA
 RTS



OACCCH ASLA
 PHA
 BMI OAONA
 INY  ;ACCESS NOT SET, INC SPACE COUNT
 PLA
 RTS

OAONA LDAAX ACCTAB
 JSR OUTCH
 PLA
 RTS


ACCTAB = "DLWRWR"




OUTSZE

;GET SIZE FROM MAP AND OUTPUT IN
;HEX (3 BYTES, 5 DIGITS).

 JSR CRNSIN ;SET CURRENT SIN TO A VARIABLE
OUTSZA JSR SETDSN ;SET DISC NO. + SIN ON STACK
 JSR SINSZE ;GET SIZE FROM MAP
 BNE OSZEEX ;ERROR ... EXIT

 LDYIM ARGD ;TOP BYTE OF SIZE
 LDAIM  0 ;NO leading spaces
 STA FILLFL
 LDAIY NEWARG
 JSR OUTBYT ;TOP DIGIT

 DEY
 LDAIY NEWARG
 JSR OUTBYT

 DEY
 LDAIY NEWARG
 JSR OUTBYT
 LDXIM  3
 JSR OUTSPS
 LDAIM  0 ;SUCCESSFUL EXIT

OSZEEX RTS



INCIPT INC INFPTR
 BNE INCRTS
 INC INFPTR + 1
INCRTS RTS



CHKENS   ;CHKENS

;CHECK THAT THE NUMBER OF ENTRIES
;ASKED FOR OF A CERTAIN TYPE OF
;EXAMINE IS LESS THAN MAX. NO.

 LDX EXARG
 CPXIM  4
 BEQ CHENOK ;Asking for dir.name only, exit, C clear
 CMPAX ENTTAB
 RTS
CHENOK CLC
 RTS

ENTTAB = MAXENA
 = MAXENB
 = MAXENC
 = MAXEND


TSTERM   ;TSTERM

;IS FILE TITLE <term> only ??

 LDYIM  0
 LDAIY NAMPTR
 CMPIM TERMIN
 RTS




;************ RETAIN *************

;RETAIN: RTN TO RETAIN A SIN IN A
;SPECIFIED DIRECTORY, WITH
;GIVEN FILE NAME.

;ENTRY: ARGUMENTS ON ARGPTR STACK, AS SPECIFIED
;FOR DIRMAN.DRPRES.

;EXIT : A = RC
;ARGB = LS(DISC NO)
;ARGC = MS(DISC NO)
;ARGD = LS(SIN)
;ARGE = CS(SIN)
;ARGF = MS(SIN OF OBJECT TO BE DELETED)

;NOTE OBJSIN CAN BE DESTROYED BY RETAIN

;FUNCTION:

;IF TYPE = TYPDIR
;THEN PUT LAST COMPONENT OF FILE TITLE IN DIR HEADER
;FI;
;IF ENTRY ALREADY EXISTS
;THEN CHECK THAT IT MAY BE DELETED;
;CHECK THAT TYPES AGREE;
;CALL MAPMAN.ENSURE(MAP)
;NOTE SIN OF OBJECT TO BE DELETED;
;UPDATE DIR ENTRY (all except access - including name);
;ENSURE DIRECTORY UPTO DATE ON DISC;
;RETURN(success,disc no,sin)
;ELIF ROOM FOR A NEW ENTRY
;THEN CALL MAPMAN.ENSURE(MAP);
;UPDATE DIRECTORY;
;ENSURE DIR UPTO DATE ON DISC;
;RETURN(success,0,0)
;ELSE RETURN(directory full)
;FI


RETAIN LDAIM -1
RETA12 STA TEMPA ;skip DELCHK entry point
 JSR LOADTX
RETANA JSR FNDTEX ;DOES TEXT NAME ALREADY EXIST ?
 BNE RETANM

;ENTRY ALREADY EXISTS

 LDA TEMPA ;check entry point
 BEQ RETANB ;skip if RENAME involved ** 25/9/84 **

 JSR DELCHK ;CAN IT BE DELETED ?
 BEQ RETANB
RETCLN JSR UNLOCK ;UNLOCK THE LOADED DIR
 JMP RETANZ

;SEE IF TYPES MATCH

RETANB LDYIM ARGN
 LDAIY ARGPTR ;TYPE & ACCESS OF OBJECT TO BE PRESERVED
 ANDIM TYPE
 STA TEMPA
 LDYIM DRACCS
 LDAIY CRNTEN
 STA OBJACC ;OBJACC:=OLD ACCESS FIELD IN DIR
 ANDIM TYPE
 CMP TEMPA
 BEQ RETAND
 JSR UNLOCK
 LDAIM DRERRK ;TYPES DON'T MATCH
 JMP RETANZ

RETAND JSR RATDIR ;IF DIR THEN UPDATE NAME IN HEADER
 BNE RETCLN

 JSR ENSMAP ;ENSURE MAP OF OBJECT TO BE RETAINED
 BEQ RETANK
 JMP RETANZ
RETANK JSR CRNSIN ;OBJSIN:=SIN OF OBJECT TO BE DELETED
 JSR COPYDT ;COPY OBJECT DETAILS INTO DIR
 JSR COPYNM ;Copy name TXTNAM -> dir. entry
 LDYIM DRACCS ;BUT KEEP OLD ACCESS FIELD
 LDA OBJACC
 STAIY CRNTEN
 JSR ARGDSN ;MOVE DISC NO & OBJSIN ONTO ARGPTR STACK
 JSR ENSRIT ;STRMAN.ENSURE(DIR)
 JMP RETANZ

;MAKE A NEW DIR ENTRY

RETANM JSR SETFRE ;DIRFRE := ADDR OF FREE ENTRY PTR
 BNE RETANP
 JSR UNLOCK

;THE DIR IS FULL SO TRY AND INCREASE ITS SIZE

 JSR CHZSZE ;INCREASE DIR SIZE
 BEQ RETANO
 JMP RETANZ
RETANO JSR LOADDR ;RELOAD THE DIR
 BEQ RETANA ;TRY AGAIN
 JSR UNLOCK
 JMP RETANZ

RETANP JSR RATDIR ;IF DIR THEN UPDATE NAME IN HEADER
 BNE RETCLN ;GO AND UNLOCK THE LOADED DIR

 JSR ENSMAP ;ENSURE MAP OF OBJECT TO BE RETAINED
 BEQ RETANT
 JSR UNLOCK ;UNLOCK THE LOADED DIR
 JMP RETANZ

;REMOVE ENTRY FROM FREE CHAIN AND INSERT
;IT IN APPROPRIATE POSITION, ON THE IN USE CHAIN.

RETANT LDYIM DRLINK
 LDAIY PREVEN
 STA TEMPA
 INY
 LDAIY PREVEN
 STA TEMPA + 1 ;TEMPA := [PREVEN]

 DEY  ;Y:= DRLINK
 LDAIY DIRFRE
 STAIY PREVEN
 INY
 LDAIY DIRFRE
 STAIY PREVEN ;[PREVEN] := [DIRFRE]

 JSR SETCRN ;CRNTEN := STORE ADDRESS OF [DIRFRE]

 LDYIM DRLINK
 LDAIY CRNTEN
 STAIY DIRFRE
 INY
 LDAIY CRNTEN
 STAIY DIRFRE ;[DIRFRE] := [CRNTEN]
 DEY  ;Y:=DRLINK
 LDA TEMPA
 STAIY CRNTEN
 INY
 LDA TEMPA + 1
 STAIY CRNTEN ;[CRNTEN] := TEMPA

;INCREMENT DIR ENTRY COUNT

 JSR SETGEN ;GENPTR := [DIRSTA]

 CLC
 LDYIM DRENTS
 LDAIY GENPTR
 ADCIM  1
 STAIY GENPTR
 INY
 LDAIY GENPTR
 ADCIM  0
 STAIY GENPTR ;[DIRSTA + DRENTS] +:= 1

;COPY TEXT NAME INTO DIR ENTRY

 JSR COPYNM

;COPY DETAILS ON ARGPTR STACK INTO DIR ENTRY

 JSR COPYDT
 JSR ENSRIT ;STRMAN.ENSURE(directory)
 JSR ARGDSN ;Copy Disc & SIN to stack, then zero SIN

;CLEAR SIN TO ZERO

 LDAIM  0
 LDYIM ARGD
 LDXIM  3
RETANQ STAIY ARGPTR ;:=0
 INY
 DEX
 BNE RETANQ
RETANZ RTS


;RATDIR: IF RETAINING A DIR - WE COPY INTO ITS HEADER
;THE LAST COMPONENT OF A FILE TITLE.
;THIS IS THE DIR'S NAME & PROVIDED FOR THOSE
;CLIENTS WANTING TO DISPLAY A DIR'S NAME
;DURING EXAMINE.


RATDIR LDYIM ARGN
 LDAIY ARGPTR
 ANDIM TYPDIR
 BEQ RATDRZ

;AS WE ARE RETAINING A DIR WE MUST COPY THE CONTENTS
;OF TXTNAM INTO THE HEADER OF THIS DIR.

 JSR ARGOBJ ;OBJSIN:=SIN OF OBJECT TO BE PRESERVED
 JSR SINSZE ;FIND OUT THE DIR'S SIZE
 BNE RATDRZ
 LDYIM ARGE
 LDAIY NEWARG ;LS(NO OF BLOCKS)
 PHA
 INY
 LDAIY NEWARG ;MS(NO OF BLOCKS)
 PHA
 LDYIM ARGA
 LDAIM  1
 STAIY NEWARG
 JSR SETDSN ;PUT DISCNO & OBJSIN ON NEWARG STACK
 LDYIM ARGG
 LDAIM  0
 STAIY NEWARG
 INY
 STAIY NEWARG ;BLOCK NO. = 0
 PLA
 LDYIM ARGJ
 STAIY NEWARG ;MS(NO OF BLOCKS)
 PLA
 DEY  ;Y:= ARGI
 STAIY NEWARG ;LS(NO OF BLOCKS)
 JSR STRMAN ;STRMAN.DISC ADDR->STORE ADDR
 BNE RATDRZ

;NOW THE DIR IS LOADED - SO COPY THE CONTENTS OF
;TXTNAM INTO THE HEADER OF THE DIR

 LDYIM ARGB
 LDAIY NEWARG
 STA GENPTR
 INY
 LDAIY NEWARG
 STA GENPTR + 1
 CLC
 LDA GENPTR
 ADCIM DRNAME
 STA MOVTO
 LDA GENPTR + 1
 ADCIM  0
 STA MOVTO + 1
 LDAIM TXTNAM
 STA MOVFRM
 LDAIM /(TXTNAM )
 STA MOVFRM + 1
 LDXIM NAMLNT
 JSR MOVE
 JSR MRKDRT ;MARK IT DIRTY
 LDYIM ARGA
 LDAIM  2
 STAIY NEWARG ;N.B. STR ADDR ALREADY ON NEWARG STACK
 LDYIM ARGD
 LDAIM UNLKIT
 STAIY NEWARG ;ENSURE & UNLOCK THE DIR
 JSR STRMAN
RATDRZ RTS


;COPYDT: COPY LOAD ADDR -> SIN, WHICH ARE ON ARGPTR STACK,
;INTO THE DIR ENTRY POINTED TO BY CRNTEN.


COPYDT LDAIM ARGF
 STA OFF1 ;Move from offset
 LDAIM DRLOAD
 STA OFF2 ;Move to offset
 LDXIM ARGPTR ;Move from ptr.
 LDYIM CRNTEN ;Move to ptr.
 LDAIM &E ;Move 14 bytes
 JMP MOVBLK



COPYNM

;Copy object name from TXTNAM to dir. entry

 LDAIM TXTNAM
 STA MOVFRM
 LDAIM /(TXTNAM )
 STA MOVFRM + 1
 CLC
 LDA CRNTEN
 ADCIM DRTITL
 STA MOVTO
 LDA CRNTEN + 1
 ADCIM  0
 STA MOVTO + 1
 LDXIM NAMLNT
 JMP MOVE



INCCRN CLC  ;CRNTEN +:= DRENSZ
 LDA CRNTEN
 ADCIM DRENSZ
 STA CRNTEN
 LDA CRNTEN + 1
 ADCIM  0
 STA CRNTEN + 1
 RTS


ARGOBJ LDYIM ARGQ ;OBJSIN:=SIN OF OBJECT TO BE PRESERVED
 LDAIY ARGPTR
 STA OBJSIN
 INY
 LDAIY ARGPTR
 STA OBJSIN + 1
 INY
 LDAIY ARGPTR
 STA OBJSIN + 2
 RTS


ENSMAP JSR ARGOBJ ;ENSURE OBJECT'S MAP IS UPTO DATE ON DISC
ENSOMP JSR SETDSN ;PUT DISC NO & OBJSIN ON NEWARG STACK
 LDYIM ARGA
 LDAIM  6
 STAIY NEWARG
 JMP MAPMAN ;MAPMAN.ENSUREMAP


DELOBJ PHA  ;REMOVE NEWDIR FROM CACHTB
 JSR ARGOBJ ;OBJSIN:=SIN OF OBJECT WHICH WAS TO BE PRESERVED

 [ &00=0
 JSR REMOVE ;remove the cache entry
 BEQ DELOB3
 TAX ;save RC
 PLA
 BNE DELOB4
 TXA ;substitute RC here
DELOB4 PHA
DELOB3 PLA
 PHA ;restore stack
 CMPIM &C9 ;look for 'write protect'
 BEQ DELOB1

 JSR DELB;rest of DLETIT
 ]
 BEQ DELOB1 ;ok return
 TAX ;save RC
 PLA ;get old RC
 BNE DELOB2 ;skip if there is previous error
 TXA ;else return new error
 BNE DELOB2 ;always branch here
DELOB1 PLA ;tidy up stack
DELOB2 RTS 


; JSR REMOVE ;REMOVE OBJECT FROM CACHE
; BNE DELZ ;**** 17/3/83 ****
DELB JSR SETDSN
 JSR JUSING ;** 21/12/84 **
 LDYIM ARGA
 LDAIM  2
 STAIY NEWARG
 JSR MAPMAN ;MAPMAN.FREESPACE
 BNE DELX
 JSR SETDSN
 LDYIM ARGA
 LDAIM  6
 STAIY NEWARG
 JSR MAPMAN ;MAPMAN.ENSURE MAP
 BEQ DELZ
DELX JSR INTERR
DELZ RTS


REMOVE JSR SETDSN ;REMOVE OBJSIN FROM CACHE
 LDYIM ARGA
 LDAIM  5
 STAIY NEWARG
 JSR STRMAN ;STRMAN.REMOVE
 RTS

;CHZSZE: INCREASE THE SIZE OF A DIR

;ENTRY: DIRSIN = SIN OF DIR TO HAVE ITS SIZE CHANGED
;EXIT: A = RC

CHZSZE LDA DIRSIN
 STA OBJSIN
 LDA DIRSIN + 1
 STA OBJSIN + 1
 LDA DIRSIN + 2
 STA OBJSIN + 2 ;OBJSIN := DIRSIN
 JSR REMOVE ;REMOVE OBJSIN FROM THE CACHE
 JSR SINSZE
 BEQ CHZSZB
 JMP CHZSZZ
CHZSZB LDYIM ARGB
 LDAIY NEWARG
 STA CRNTEN
 INY
 LDAIY NEWARG
 STA CRNTEN + 1 ;CRNTEN:=EXACT CURRENT SIZE OF DIR
 LDYIM ARGE
 LDAIY NEWARG
 STA BREGA
 INY
 LDAIY NEWARG
 STA BREGA + 1 ;BREGA := NUMBER OF BLOCKS
 LDAIM  0
 STA BREGA + 2
 JSR MULTBS ;BREGA *:= BLKSZE
 CLC
 LDA BREGA
 ADCIM BLKSZE
 STA DIRTMP
 LDA BREGA + 1
 ADCIM /(BLKSZE )
 STA DIRTMP + 1 ;DIRTMP:=SIZEOFDIR+BLKSZE(INTEGRAL NB OF BLKS)

;TEST FOR MAX SIZE OF DIR ALLOWED

 [ 1=0 ;***
 SEC
 LDA DIRTMP
 SBCIM MAXDIR
 STA TEMPA
 LDA DIRTMP + 1
 SBCIM /(MAXDIR )
 BCC CHZSZD
 ORA TEMPA
 BEQ CHZSZD
 LDAIM DRERRM ;RC:=MAX SIZE OF DIR REACHED
 BNE CHZSZZ
 |
 LDAIM MAXDIR
 CMP DIRTMP
 LDAIM /MAXDIR
 SBC DIRTMP+1
 BCS CHZSZD

 LDAIM DRERRM
 BNE CHZSZZ
 ] 


CHZSZD LDAIM  3
 JSR SETRTN
 JSR SETDSN
 LDYIM ARGG
 LDA DIRTMP
 STAIY NEWARG ;LS(NEW SIZE)
 INY
 LDA DIRTMP + 1
 STAIY NEWARG ;CS(NEW SIZE)
 INY
 LDAIM  0
 STAIY NEWARG ;MS(NEW SIZE)

 JSR JUSINF ;** 3/10/84 **

 JSR MAPMAN ;MAPMAN.CHANGESIZE
 BNE CHZSZZ

 JSR LDDR ;LOAD CURRENT DIR
 BNE CHZSZZ

 SEC
 LDA CRNTEN
 SBCIM  1
 STA CRNTEN
 LDA CRNTEN + 1
 SBCIM  0
 STA CRNTEN + 1 ;CRNTEN-:=1(TO OVERWRITE OLD TRALNG SQ NO)
 CLC
 LDA DIRSTA
 ADC CRNTEN
 STA CRNTEN
 LDA DIRSTA + 1
 ADC CRNTEN + 1
 STA CRNTEN + 1 ;CRNTEN PTS TO NEXT ENTRY TO BE MADE FREE

 JSR FORMAT ;FORMAT DIR

 JSR ENSRIT ;ENSURE ITS UPTO DATE ON DISC & UNLOCKIT
 BNE CHZSZZ
;ENSURE THE OBJECT MAP

 JSR ENSOMP ;N.B. OBJSIN MUST = SIN OF DIR
 BEQ CHZSZZ
 JSR INTERR

CHZSZZ RTS

 LNK UADE0F
