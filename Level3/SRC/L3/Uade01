 OPT 2 ; FILE > Uade01
 TTL File server file UADE01

 ORG &400

;*************************
;printing on/off per file
;*************************

ON * 4+1 ;printer on, new page
OFF * 2 ;printer off

UADE01 * Off
UADE02 * Off
UADE03 * Off
UADE04 * Off
UADE05 * Off
UADE06 * Off
RMAN01 * Off
RMAN02 * Off
RMAN03 * Off
RMAN04 * Off
RMAN05 * Off
UADE0A * Off
UADE0B * Off
UADE0C * Off
UADE0D * Off
UADE0E * Off
UADE0F * Off
UADE10 * Off
UADE11 * Off
UADE12 * Off
UADE13 * Off
UADE14 * Off
MBBMCM * Off
UADE15 * Off
UADE16 * Off
UADE17 * Off
UADE18 * Off
UADE19 * Off
UADE20 * Off

 OPT UADE01 ;select allotted printer option

;*********************************
;*    H E A D E R  F I L E  1    *
;*********************************

; Supported languages

English * 0
Italian * 1 ; **18/2/87**

BBC * &00
Winch * &00 ;If Winchester discs
Sys * &FF ;flags to indicate which type of FS
Ztime * &FF
FS * &FF
Dongle * 0 ;Real Time Clock present(=0) absent(=1)
CHACK * 1 ; no(=0) Apply the Clock Hack Patch (=1)

Debug * 0 ;Make this +ve for debug letters

Verla * "2" ;Version level .... two digits
Verlb * "4" ;Range 0-99

Lang * English
Mask * &3F ;protection state (&3F for service system)
Yes * 0
No * &FFFF

;*** MODULE CODE NAMES ***

;* NOTE WHENEVER A MODULE IS ENTERED *
;* IT PLACES ITS NAME ON THE ARGUMENT *
;* STACK (THIS IS DONE BY THE ENTER RTN) *


MODUSR * &10 ;=> USRMAN (THE USERTB MANAGER)
MODAUT * &20 ;=> AUTMAN (THE AUTHENTICATOR)
MODSTR * &30 ;=> STRMAN (THE STORE MANAGER)
MODDIR * &40 ;=> DIRMAN (THE DIRECTORY MANAGER)
MODMAP * &50 ;=> MAPMAN (THE MAP MANAGER)
MODRND * &60 ;=> RNDMAN (THE RANDOM ACCESS MANAGER)
MODDSC * &70 ;=> DSCMAN (THE DISC MANAGER)
MODCOM * &80 ;=> CMND. PROCESSOR PSEUDO NAME

EXTER0 * &C0 ;=> external (BBC Machine) number

;USRMAN RETURN CODES

URERRA * EXTER0-1 ;MACHINE NUMBER NOT IN USERTB
URERRB * EXTER0-8 ;USERTB FULL
URERRD * MODUSR+4 ;OBJECT NOT A DIRECTORY
URERRE * EXTER0-&12 ;USER NOT LOGGED ON
URERRF * MODUSR+6 ;M/C NUMBER EQUALS ZERO

;STRMAN RETURN CODES

STERRB * MODSTR+2 ;SIN = 0
STERRD * MODSTR+4 ;REF COUNT = $00
STERRE * MODSTR+5 ;SIZE TOO BIG OR SIZE=0 !
STERRF * MODSTR+6 ;INVALID WINDOW ADDRESS
STERRG * MODSTR+7 ;NO FREE CACHE DESCRIPTORS
STERRH * MODSTR+8 ;WINDOW REF COUNT > 0
STERRK * MODSTR+&0B ;REF COUNT = $FF
STERRL * MODSTR+&0C ;STORE DEADLOCK !!
STERRM * MODSTR+&0D ;ARITH OVERFLOW IN TSTGAP

;DIRMAN RETURN CODES

DRERRA * &CC ;INVALID SEPARATOR IN FILE TITLE
DRERRB * MODDIR+2 ;BROKEN DIRECTORY
DRERRC * &D6 ;OBJECT NOT FOUND
DRERRD * EXTER0-2 ;OBJECT NOT A DIRECTORY
DRERRE * EXTER0-3 ;INSUFFICIENT ACCESS
DRERRF * MODDIR+6 ;WRONG ARG TO SET/READ OBJECT ATTRIBUTES
DRERRG * &C3 ;DIR ENTRY LOCKED
DRERRI * &C2 ;OBJECT IN USE (I.E. OPEN)
DRERRJ * EXTER0-&C ;DIR NOT EMPTY
DRERRK * EXTER0-&11 ;TYPES DON'T MATCH
DRERRL * MODDIR+12 ;NO WRITE ACCESS
DRERRM * EXTER0-&D ;MAX DIR SIZE REACHED
DRERRN * MODDIR+14 ;CLIENT ASKS FOR TOO MANY ENTRIES
DRERRO * MODDIR+15 ;BAD ARG. TO EXAMINE
DRERRP * MODDIR+1 ;cdir too big

;AUTMAN RETURN CODES

ATERRA * MODAUT+1 ;CANNOT FIND PASSWORD FILE
ATERRB * EXTER0- 4 ;USERID NOT FOUND IN PW FILE
ATERRC * EXTER0- 5 ;INCORRECT PASSWORD
ATERRD * EXTER0- 6 ;INSUFFICIENT PRIVILEGE
ATERRE * EXTER0- 7 ;SYNTAX ERROR IN PASSWORD
ATERRF * EXTER0-&F ;USERID ALREADY IN PASSWORD FILE
ATERRG * &AC ;bad user name in PW file**13/4/83**
ATERRH * EXTER0-&E ;PASSWORD FILE FULL UP
ATERRI * MODAUT+9 ;OBJECT '$.PASSWORDS' HAS WRONG TYPE


;RNDMAN RETURN CODES

RDERRA * MODRND+1 ;RNDMAN.RESTART CALLED TWICE
RDERRB * &DE ;INVALID HANDLE
RDERRC * &C0 ;HANDLE QUOTA EXHAUSTED
RDERRD * MODRND+4 ;HANDTB FULL
RDERRE * RDERRA ;OBJECT NOT OPEN
RDERRF * MODRND+6 ;RNDMAN.COPY NOT FOR FILE OBJECTS
RDERRG * MODRND+7 ;RANDTB FULL
RDERRH * &C2 ;File already open
RDERRI * MODRND+9 ;Object not file
RDERRJ * &DF ;END OF FILE
RDERRK * DRERRE ;Insufficient access
RDERRL * EXTER0-&9 ;Attempt to point outside file
RDERRM * MODRND+&0D ;Invalid arg to RDSTAR
RDERRN * &C1 ;File not open for update
RDERRO * &D4 ;File not open for input ** 15/11/84 **



;MAPMAN RETURN CODES

MPERRA * &C8 ;DISC NUMBER NOT FOUND
MPERRB * &C6 ;DISC SPACE EXHAUSTED
MPERRC * MODMAP+3 ;SIN NOT FOR START OF CHAIN
MPERRD * MODMAP+4 ;DISC NOT A FILE SERVER DISC
MPERRF * MODMAP+6 ;ILLEGAL DRIVE NUMBER
MPERRI * MODMAP+9 ;NEW MAP DOESN'T FIT IN OLD SPACE
MPERRJ * MODMAP+&0A ;DISC OF SAME NAME ALREADY IN USE !
MPERRK * &D6 ;DISC NAME NOT FOUND
MPERRL * EXTER0-&A ;DISC ERROR ON MAP READ/WRITE
MPERRM * MODMAP+11 ;NO MORE SPACE IN MAP DESCRIPTORS
MPERRN * MODMAP+12 ;Insufficient user free space (yay!)


;DSCMAN RETURN CODES

DCERRA * MODDSC+1 ;INVALID NUMBER OF SECTORS
DCERRB * MODDSC+2 ;STORE ADDRESS OVERFLOW
DCERRC * MODDSC+3 ;ACCESSING BEYOND END OF FILE
DCERRE * &C9 ;DISC PROTECTED
DCERRF * &C7 ;UNRECOVERABLE DISC ERROR


;COMMAND PROC Errors

RNAMQQ * EXTER0-&10 ;Renaming across two discs
LODERA * EXTER0-&B ;Trying to load a directory
LODERB * DRERRE ;Insufficient access
SAVERA * MODCOM+3 ;Too much data sent from client
WAITER * MODCOM+4 ;Wait bombs out
COERRA * MODCOM+5 ;Invalid function code

SAERRA * &CF ;Invalid setaccess string
SYNERR * &FE
NAMERR * &FD ;Bad file name etc.
NUMERR * &F0 ;Bad number
SAERRC * MODCOM+&0A ;File too big
WOTERR * &FE
SPERRA * MODCOM+&0C ;Bad privilege letter
PBERRA * MODCOM+&0D ;Excess data in PUTBYTES
INFERA * MODCOM+&0E ;Bad INFO argument.
ARGERR * MODCOM+&0F ;Bad arg to RDAR
DTERR * MODCOM+&10 ;Bad date and time


;INTERNAL  ERRORS

IERRAA *  1 ;(SETFS) FRAME SIZE TOO BIG
IERRAB *  2 ;(ENTRY) FUNCT CODE = 0
IERRAC *  3 ;(ENTRY) UNKNOWN ENTRY REASON
IERRAD *  4 ;(GETVEC) SIZE TOO BIG
IERRAE *  5 ;(GETVEC) INSUFFICIENT SPACE
IERRAF *  6 ;(GETVEC) SIZE OF STORE REQUESTED = 0
IERRAH *  8 ;(GETINT) NOT A DIGIT
IERRAI *  9 ; UNABLE TO OPEN RXCB
IERRAJ * 10 ;(RDBTMP) BIT MAP DISC ERROR
IERRAK * 11 ;writing to sector zero


         ;NEW ERRORS FOR LEVEL3

 ;F4 ;Memory map error
 ;F5 ;Internal bit map cache error
 ;F6 ;cached bit map holds no free sectors
 ;F8 ;write error (data read <> data written)
 ;F9 ;attempting to zero an illegal amount of disc
 ;FA ;multiple block allocate fails
 ;FB ;memory error during initial MEMTST
 ;FC ;single block allocate fails

;COMMAND CODES SENT TO CLIENT

CCSAVE * 1
CCLOAD * 2
CCCAT * 3
CCINF * 4
CCLGON * 5
CCSDIS * 6
CCSDIR * 7
CCCMND * 8
CCSLIB * 9
CCDSCS * &A
CCUSRS * &B

;M A N I F E S T S
;ODDS AND ENDS
Oswrch * &FFEE ;BBC addresses here
Osrdch * &FFE0
Oscrlf * &FFE7
Oscli * &FFF7
Osasci * &FFE3
Osword * &FFF1
Osbyte * &FFF4

Stksze * &FF ;Size of argument stack
FDcyls * 80 ;No of cylinders per floppy
FDside * 2 ;No of sides per disc
FDsecs * 16 ;No of sectors per track (side)
Maxuse * 80 ;Maximum number of users
Baseyr * 81 ;Base year for date = 1981
Thisyr * 88 ;Earliest year acceptable

ESC * &1B
ABTCH * "Q"
ACK * 6
NACK * &15

;DIRTY MARKER (CLEAN=0)

DIRTY * &FF
UNLKIT * &FF

;INTER MODULE ARGUMENT STACK CONSTANTS

FRAMSZ * 0 ;POSN OF FRAME SIZE ON ARGUMENT STACK
MODNME * 1 ;POSN OF MODULE NAME ON ARGUMENT STACK
ENTRES * 2 ;POSN OF MODULE ENTRY REASON ON ARGUMENT STACK
FINFO * ENTRES+1 ;SIZE OF INFO STORED ON ARGUMENT STACK

ARGA * FINFO ;FOR FUNCTION CODE AND RETURN CODE
ARGB * ARGA+1
ARGC * ARGB+1
ARGD * ARGC+1
ARGE * ARGD+1
ARGF * ARGE+1
ARGG * ARGF+1
ARGH * ARGG+1
ARGI * ARGH+1
ARGJ * ARGI+1
ARGK * ARGJ+1
ARGL * ARGK+1
ARGM * ARGL+1
ARGN * ARGM+1
ARGO * ARGN+1
ARGP * ARGO+1
ARGQ * ARGP+1
ARGR * ARGQ+1
ARGS * ARGR+1
ARGT * ARGS+1

;DISC BLOCK SIZE
BLKSZE * &100 ;= 256 BYTES


;FLAGS AND MASKS (ACCESS BITS ETC.)
READAC * 1 ;BIT0 -> READ ACCESS
WRITAC * 2 ;BIT1 -> WRITE ACCESS
LOCKED * &10 ;BIT4 -> LOCK BIT
TYPE * &20 ;BIT5 -> TYPE BIT (DIR/FILE)
LOPRIV * &20 ;BIT5 -> Low privilege bit
OWNER * &40 ;BIT6 -> OWNER ACCESS BIT
SYSTPV * &40 ;BIT6 -> SYSTEM PRIVILEGE
NTSYST * &BF ;Complement of SYSTPV
INUSE * &80 ;BIT7 -> IN USE BIT
FILEJC * &80 ;BIT7 -> FILE JUST CREATED
TYPFIL * 0 ;OBJECT TYPE = FILE
TYPDIR * &20 ;OBJECT TYPE = DIRECTORY
ANYBDY * 0 ;ANYBODY ACCESS
RDWRAC * 3 ;READ WRITE ACCESS
RWLACC * &13 ;Read/write/locked access
ACCDEF * &C ;Owner RW, public no access
TXFLAG * &80
RXFLAG * &7F
MONON * &FF
MONOFF *  0 ;Monitor switch


;D O S  ROUTINES AND ADDRESSES

TRADD * 1
CMD * 5
LENGTH * &B

;PAGE ZERO

 ^ &B0
ARGPTR # 2 ;PTR TO CUR STK ARGS
NEWARG # 2 ;PTR TO NEW ARGS

 ^ &20
CLRPTR # 2 ;PTR USED BY CLRSTR RTN
MOVFRM # 2 ;PTR USED BY MOVE & COMPAR RTNS
MOVTO # 2 ;PTR USED BY MOVE & COMPAR RTNS
COMPTR # 2 ;PTR TO COMND LINE (RDLINE)
GENPTR # 2 ;PTR AVAILABLE TO ALL MODULES
USTPTR # 2 ;PTR TO USERTB (USRMAN/FINDMC)
URMPPT # 2 ;PTR TO USERINFO(USRMAN)
PREV # 2 ;PTR TO PREVIOUS CACHE ENTRY(STRMAN)
CRNT # 2 ;PTR TO CURRENT CACHE ENTRY(STRMAN)
CMPPTR # 2 ;PTR TO ARGUMENTS (STRMAN)
NAMPTR # 2 ;PTR TO FILE TITLE (DIRMAN)
PREVEN # 2 ;PTR TO PREVIOUS DIR ENTRY (DIRMAN)
CRNTEN # 2 ;CURRENT DIR ENTRY (DIRMAN)
TXTPTR # 2 ;USED TO PT TO CHARS IN TXTNAM(DIRMAN)
DIRFRE # 2 ;PTR TO FREE CHAIN PTR (DIRMAN)
INFPTR # 2 ;PTR TO STORE AREA FOR RETRIEVE INFO
DPTRLD # 2 ;PTR TO FIRST BYTE OF A DIR
DPTRTR # 2 ;PTR TO LAST BYTE OF DIR
DRUSIN # 2 ;PTR TO USERINFO
HNDPTR # 2 ;PTR TO HANDLE INFO (SET BY FNDHND)
RNDPTR # 2 ;PTR TO OBJECT DETAILS (RNDMAN)
RNDTMP # 3 ;Temp (RNDMAN) **
AUTPTR # 2 ;POINTER TO USERID (AUTMAN)
PWFPTR # 2 ;PASSWORD FILE POINTER(AUTMAN)
ATUSPT # 2 ;PTR TO AUTMAN'S USERINFO AREA
JWORK # 2 ;Used in UADE14
MAPPTR # 2 ;PTR TO BASE OF DISC MAP
MPSCPT # 2 ;POINTER INTO MAP
MPMBPT # 2 ;MAP BLOCK PTR
MAPENT # 2 ;PTR. TO MAP TABLE ENTRY
MPCYPT # 2 ;PTR TO CYLINDER MAP
MAPGEN # 2 ;GENERAL MAP MANAGER PTR
GNCBPT # 2 ;GENERAL CONTROL BLOCK POINTER
DNMPTR # 2 ;PTR TO DISC NAME (MAPMAN)
DNMBUF # &12 ;DISC NAME BUFFER
DSCTMP # 2 ;PTR TO A MAP'S DIRTY FLAG (DSCMAN)
CVTUPT # 2 ;USER INF. PTR. CVT. PROG.
SCTPTR # 2 ;PTR TO SECTOR ZERO (SEE STRTFS)
NETCB # 2 ;POINTER TO NET CONTROL BLOCK (C.PROC.)
RTEPTR # 2 ;Ptr. to RNDTAB entry
RDUPTR # 2 ;Ptr. to user id. in RNDPTR
COZERO # 12 ;12 byte area used by C.proc.
 ;zero page used in RENAME 24/9/84
LAST * COZERO
NAME * LAST+1
ONAME * NAME+1
RTYPE * ONAME+1
PTR * RTYPE+1
PTR1 * PTR+2
REXIST * PTR1+2
 ;***
VSTPTR # 2 ;are used by VSTRNG only
OLDEV # 2 
GP1 # 2 ;ANOTHER GENERAL POINTER

BRKPTR * &FD ;2 byte pointer used in MOS BRK handling

 LNK UADE02
