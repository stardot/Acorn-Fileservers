
 OPT 2 ; FILE > Uade01
 TTL File server file UADE01

 ORG &400

;*************************
;printing on/off per file
;*************************

ON * 4+1 ;printer on, new page
OFF * 2 ;printer off

UADE01 * OFF
UADE02 * OFF
UADE03 * OFF
UADE04 * OFF
UADE05 * OFF
UADE06 * OFF
RMAN01 * OFF
RMAN02 * OFF
RMAN03 * OFF
RMAN04 * OFF
RMAN05 * OFF
UADE0A * OFF
UADE0B * OFF
UADE0C * OFF
UADE0D * OFF
UADE0E * OFF
UADE0F * OFF
UADE10 * OFF
UADE11 * OFF
UADE12 * OFF
UADE13 * OFF
UADE14 * OFF
MBBMCM * OFF
UADE15 * OFF
UADE16 * OFF
UADE17 * OFF
UADE18 * OFF
UADE19 * OFF
UADE20 * OFF

 OPT 4 ;newpage
 OPT UADE01 ;select allotted printer option

;*********************************
;*    H E A D E R  F I L E  1    *
;*********************************

BBC * &00
WINCH * &00 ;IF WINCHESTER DISCS
SYS * &FF ;flags to indicate which type of FS
ZTIME * &FF
FS * &FF
DONGLE * 0 ;Real Time Clock present(=0) absent(=1)


VERLA * "0"
VERLB * "1"
DEBUG *  0 ;Make this +ve for debug letters
MASK * &FF ;protection state


;*** MODULE CODE NAMES ***

;* NOTE WHENEVER A MODULE IS ENTERED *
;* IT PLACES ITS NAME ON THE ARGUMENT *
;* STACK (THIS IS DONE BY THE ENTER RTN) *


MODUSR * &10 ;=> USRMAN (THE USERTB MANAGER)
MODAUT * &20 ;=> AUTMAN (THE AUTHENTICATOR)
MODSTR * &30 ;=> STRMAN (THE STORE MANAGER)
MODDIR * &40 ;=> DIRMAN (THE DIRECTORY MANAGER)
MODMAP * &50 ;=> MAPMAN (THE MAP MANAGER)
MODRND * &60 ;=> RNDMAN (THE RANDOM ACCESS MANAGER)
MODDSC * &70 ;=> DSCMAN (THE DISC MANAGER)
MODCOM * &80 ;=> CMND. PROCESSOR PSEUDO NAME

EXTER0 * &C0 ;=> external (BBC Machine) number

;USRMAN RETURN CODES

URERRA * EXTER0 - 1 ;MACHINE NUMBER NOT IN USERTB
URERRB * EXTER0 - 8 ;USERTB FULL
URERRD * MODUSR + 4 ;OBJECT NOT A DIRECTORY
URERRE * EXTER0 -&12 ;USER NOT LOGGED ON
URERRF * MODUSR + 6 ;M/C NUMBER EQUALS ZERO

;STRMAN RETURN CODES

STERRB * MODSTR + 2 ;SIN = 0
STERRD * MODSTR + 4 ;REF COUNT = $00
STERRE * MODSTR + 5 ;SIZE TOO BIG OR SIZE=0 !
STERRF * MODSTR + 6 ;INVALID WINDOW ADDRESS
STERRG * MODSTR + 7 ;NO FREE CACHE DESCRIPTORS
STERRH * MODSTR + 8 ;WINDOW REF COUNT > 0
STERRK * MODSTR +&0B ;REF COUNT = $FF
STERRL * MODSTR +&0C ;STORE DEADLOCK !!
STERRM * MODSTR +&0D ;ARITH OVERFLOW IN TSTGAP

;DIRMAN RETURN CODES

DRERRA * &CC ;INVALID SEPARATOR IN FILE TITLE
DRERRB * MODDIR + 2 ;BROKEN DIRECTORY
DRERRC * &D6 ;OBJECT NOT FOUND
DRERRD * EXTER0 - 2 ;OBJECT NOT A DIRECTORY
DRERRE * EXTER0 - 3 ;INSUFFICIENT ACCESS
DRERRF * MODDIR + 6 ;WRONG ARG TO SET/READ OBJECT ATTRIBUTES
DRERRG * &C3 ;DIR ENTRY LOCKED
DRERRI * &C2 ;OBJECT IN USE (I.E. OPEN)
DRERRJ * EXTER0 -&C ;DIR NOT EMPTY
DRERRK * EXTER0 -&11 ;TYPES DON'T MATCH
DRERRL * MODDIR +12 ;NO WRITE ACCESS
DRERRM * EXTER0 -&D ;MAX DIR SIZE REACHED
DRERRN * MODDIR +14 ;CLIENT ASKS FOR TOO MANY ENTRIES
DRERRO * MODDIR +15 ;BAD ARG. TO EXAMINE
DRERRP * MODDIR +1 ;cdir too big

;AUTMAN RETURN CODES

ATERRA * MODAUT + 1 ;CANNOT FIND PASSWORD FILE
ATERRB * EXTER0 - 4 ;USERID NOT FOUND IN PW FILE
ATERRC * EXTER0 - 5 ;INCORRECT PASSWORD
ATERRD * EXTER0 - 6 ;INSUFFICIENT PRIVILEGE
ATERRE * EXTER0 - 7 ;SYNTAX ERROR IN PASSWORD
ATERRF * EXTER0 -&F ;USERID ALREADY IN PASSWORD FILE
ATERRG * &AC ;bad user name in PW file**13/4/83**
ATERRH * EXTER0 -&E ;PASSWORD FILE FULL UP
ATERRI * MODAUT + 9 ;OBJECT '$.PASSWORDS' HAS WRONG TYPE


;RNDMAN RETURN CODES

RDERRA * MODRND + 1 ;RNDMAN.RESTART CALLED TWICE
RDERRB * &DE ;INVALID HANDLE
RDERRC * &C0 ;HANDLE QUOTA EXHAUSTED
RDERRD * MODRND + 4 ;HANDTB FULL
RDERRE * RDERRA ;OBJECT NOT OPEN
RDERRF * MODRND + 6 ;RNDMAN.COPY NOT FOR FILE OBJECTS
RDERRG * MODRND + 7 ;RANDTB FULL
RDERRH * &C2 ;File already open
RDERRI * MODRND + 9 ;Object not file
RDERRJ * &DF ;END OF FILE
RDERRK * DRERRE ;Insufficient access
RDERRL * EXTER0 -&9 ;Attempt to point outside file
RDERRM * MODRND +&0D ;Invalid arg to RDSTAR
RDERRN * &C1 ;File not open for update
RDERRO * &D4 ;File not open for input ** 15/11/84 **



;MAPMAN RETURN CODES

MPERRA * &C8 ;DISC NUMBER NOT FOUND
MPERRB * &C6 ;DISC SPACE EXHAUSTED
MPERRC * MODMAP + 3 ;SIN NOT FOR START OF CHAIN
MPERRD * MODMAP + 4 ;DISC NOT A FILE SERVER DISC
MPERRF * MODMAP + 6 ;ILLEGAL DRIVE NUMBER
MPERRI * MODMAP + 9 ;NEW MAP DOESN'T FIT IN OLD SPACE
MPERRJ * MODMAP +&0A ;DISC OF SAME NAME ALREADY IN USE !
MPERRK * &D6 ;DISC NAME NOT FOUND
MPERRL * EXTER0 -&A ;DISC ERROR ON MAP READ/WRITE
MPERRM * MODMAP + 11 ;NO MORE SPACE IN MAP DESCRIPTORS
MPERRN * MODMAP + 12 ;Insufficient user free space (yay!)


;DSCMAN RETURN CODES

DCERRA * MODDSC + 1 ;INVALID NUMBER OF SECTORS
DCERRB * MODDSC + 2 ;STORE ADDRESS OVERFLOW
DCERRC * MODDSC + 3 ;ACCESSING BEYOND END OF FILE
DCERRE * &C9 ;DISC PROTECTED
DCERRF * &C7 ;UNRECOVERABLE DISC ERROR


;COMMAND PROC Errors

RNAMQQ * EXTER0 -&10 ;Renaming accross two discs
LODERA * EXTER0 -&B ;Trying to load a directory
LODERB * DRERRE ;Insufficient access
SAVERA * MODCOM + 3 ;Too much data sent from client
WAITER * MODCOM + 4 ;Wait bombs out
COERRA * MODCOM + 5 ;Invalid function code

SAERRA * &CF ;Invalid setaccess string
SYNERR * &FE
NAMERR * &FD ;Bad file name etc.
SAERRC * MODCOM +&0A ;File too big
WOTERR * &FE
SPERRA * MODCOM +&0C ;Bad priviledge letter
PBERRA * MODCOM +&0D ;Excess data in PUTBYTES
INFERA * MODCOM +&0E ;Bad INFO argument.
ARGERR * MODCOM +&0F ;Bad arg to RDAR
DTERR * MODCOM +&10 ;Bad date and time



;INTERNAL  ERRORS

IERRAA *  1 ;(SETFS) FRAME SIZE TOO BIG
IERRAB *  2 ;(ENTRY) FUNCT CODE = 0
IERRAC *  3 ;(ENTRY) UNKNOWN ENTRY REASON
IERRAD *  4 ;(GETVEC) SIZE TOO BIG
IERRAE *  5 ;(GETVEC) INSUFFICIENT SPACE
IERRAF *  6 ;(GETVEC) SIZE OF STORE REQUESTED = 0
IERRAH *  8 ;(GETINT) NOT A DIGIT
IERRAI *  9 ; UNABLE TO OPEN RXCB
IERRAJ * 10 ;(RDBTMP) BIT MAP DISC ERROR
IERRAK * 11 ;writing to sector zero


         ;NEW ERRORS FOR LEVEL3

F6 ;cached bit map holds no free sectors
FC ;single block allocate fails
FA ;multiple block allocate fails
F9 ;attempting to zero an illegal amount of disc
F8 ;write error (data read <> data written)
F5 ;Internal bit map cache error


;COMMAND CODES SENT TO CLIENT

CCSAVE *  1
CCLOAD *  2
CCCAT *  3
CCINF *  4
CCLGON *  5
CCSDIS *  6
CCSDIR *  7
CCCMND *  8
CCSLIB *  9
CCDSCS * &A
CCUSRS * &B

;M A N I F E S T S
;ODDS AND ENDS
OSWRCH * &FFEE ;BBC addresses here
OSRDCH * &FFE0
OSCRLF * &FFE7
OSCLI * &FFF7
OSASCI * &FFE3
OSWORD * &FFF1
OSBYTE * &FFF4

STKSZE * &FF ;SIZE OF ARGUMENT STACK
MAXUSE * 80 ; Maximum number of users
BASEYR * 81 ;BASE YEAR FOR DATE = 1981
THISYR * 85 ;Earliest year acceptable
ESC * &1B
ABTCH * "Q"
ACK *  6
NACK * &15
;BOOLEAN CONSTANTS


;DIRTY MARKER (CLEAN=0)

DIRTY * &FF
UNLKIT * &FF

;INTER MODULE ARGUMENT STACK CONSTANTS

FRAMSZ *  0 ;POSN OF FRAME SIZE ON ARGUMENT STACK
MODNME *  1 ;POSN OF MODULE NAME ON ARGUMENT STACK
ENTRES *  2 ;POSN OF MODULE ENTRY REASON ON ARGUMENT STACK
FINFO * ENTRES + 1 ;SIZE OF INFO STORED ON ARGUMENT STACK

ARGA * FINFO ;FOR FUNCTION CODE AND RETURN CODE
ARGB * ARGA + 1
ARGC * ARGB + 1
ARGD * ARGC + 1
ARGE * ARGD + 1
ARGF * ARGE + 1
ARGG * ARGF + 1
ARGH * ARGG + 1
ARGI * ARGH + 1
ARGJ * ARGI + 1
ARGK * ARGJ + 1
ARGL * ARGK + 1
ARGM * ARGL + 1
ARGN * ARGM + 1
ARGO * ARGN + 1
ARGP * ARGO + 1
ARGQ * ARGP + 1
ARGR * ARGQ + 1
ARGS * ARGR + 1
ARGT * ARGS + 1

;DISC BLOCK SIZE
BLKSZE * &100 ;= 256 BYTES

;FLAGS AND MASKS (ACCESS BITS ETC.)
READAC *  1 ;BIT0 -> READ ACCESS
WRITAC *  2 ;BIT1 -> WRITE ACCESS
LOCKED * &10 ;BIT4 -> LOCK BIT
TYPE * &20 ;BIT5 -> TYPE BIT (DIR/FILE)
OWNER * &40 ;BIT6 -> OWNER ACCESS BIT
SYSTPV * &40 ;BIT6 -> SYSTEM PRIVILEGE
NTSYST * &BF ;Complement of SYSTPV
INUSE * &80 ;BIT7 -> IN USE BIT
FILEJC * &80 ;BIT7 -> FILE JUST CREATED
TYPFIL *  0 ;OBJECT TYPE = FILE
TYPDIR * &20 ;OBJECT TYPE = DIRECTORY
ANYBDY *  0 ;ANYBODY ACCESS
RDWRAC *  3 ;READ WRITE ACCESS
RWLACC * &13 ;Read/write/locked access
ACCDEF * &C ;Owner RW, public no access
TXFLAG * &80
RXFLAG * &7F
MONON * &FF
MONOFF *  0 ;Monitor switch


;D O S  ROUTINES AND ADDRESSES

TRADD *  1
CMD *  5
LENGTH * &B

;PAGE ZERO

ARGPTR * &B0 ;PTR TO CUR STK ARGS
NEWARG * ARGPTR + 2 ;PTR TO NEW ARGS

CLRPTR * &20 ;PTR USED BY CLRSTR RTN
MOVFRM * CLRPTR + 2 ;PTR USED BY MOVE & COMPAR RTNS
MOVTO * MOVFRM + 2 ;PTR USED BY MOVE & COMPAR RTNS
COMPTR * MOVTO + 2 ;PTR TO COMND LINE(RDLINE)
GENPTR * COMPTR + 2 ;PTR AVAILABLE TO ALL MODULES
USTPTR * GENPTR + 2 ;PTR TO USERTB (USRMAN/FINDMC)
URMPPT * USTPTR + 2 ;PTR TO USERINFO(USRMAN)
PREV * URMPPT + 2 ;PTR TO PREVIOUS CACHE ENTRY(STRMAN)
CRNT * PREV + 2 ;PTR TO CURRENT CACHE ENTRY(STRMAN)
CMPPTR * CRNT + 2 ;PTR TO ARGUMENTS (STRMAN)
NAMPTR * CMPPTR + 2 ;PTR TO FILE TITLE (DIRMAN)
PREVEN * NAMPTR + 2 ;PTR TO PREVIOUS DIR ENTRY (DIRMAN)
CRNTEN * PREVEN + 2 ;CURRENT DIR ENTRY (DIRMAN)
TXTPTR * CRNTEN + 2 ;USED TO PT TO CHARS IN TXTNAM(DIRMAN)
DIRFRE * TXTPTR + 2 ;PTR TO FREE CHAIN PTR (DIRMAN)
INFPTR * DIRFRE + 2 ;PTR TO STORE AREA FOR RETRIEVE INFO
DPTRLD * INFPTR + 2 ;PTR TO FIRST BYTE OF A DIR
DPTRTR * DPTRLD + 2 ;PTR TO LAST BYTE OF DIR
DRUSIN * DPTRTR + 2 ;PTR TO USERINFO
HNDPTR * DRUSIN + 2 ;PTR TO HANDLE INFO (SET BY FNDHND)
RNDPTR * HNDPTR + 2 ;PTR TO OBJECT DETAILS (RNDMAN)
AUTPTR * RNDPTR + 2 ;POINTER TO USERID (AUTMAN)
PWFPTR * AUTPTR + 2 ;PASSWORD FILE POINTER(AUTMAN)
ATUSPT * PWFPTR + 2 ;PTR TO AUTMAN'S USERINFO AREA
JWORK * ATUSPT + 2 ;Used in UADE14
MAPPTR * JWORK + 2 ;PTR TO BASE OF DISC MAP
MPSCPT * MAPPTR + 2 ;POINTER INTO MAP
MPMBPT * MPSCPT + 2 ;MAP BLOCK PTR
MAPENT * MPMBPT + 2 ;PTR. TO MAP TABLE ENTRY
MPCYPT * MAPENT + 2 ;PTR TO CYLINDER MAP
MAPGEN * MPCYPT + 2 ;GENERAL MAP MANAGER PTR
GNCBPT * MAPGEN + 2 ;GENERAL CONTROL BLOCK POINTER
DNMPTR * GNCBPT + 2 ;PTR TO DISC NAME (MAPMAN)
DNMBUF * DNMPTR + 2 ;DISC NAME BUFFER
DSCTMP * DNMBUF +&12 ;PTR TO A MAP'S DIRTY FLAG (DSCMAN)
CVTUPT * DSCTMP + 2 ;USER INF. PTR. CVT. PROG.
SCTPTR * CVTUPT + 2 ;PTR TO SECTOR ZERO (SEE STRTFS)
NETCB * SCTPTR + 2 ;POINTER TO NET CONTROL BLOCK (C.PROC.)
RTEPTR * NETCB + 2 ;Ptr. to RNDTAB entry
RDUPTR * RTEPTR + 2 ;Ptr. to user id. in RNDPTR
COZERO * RDUPTR + 2 ;12 byte area used by C.proc.
;zero page used in RENAME 24/9/84

LAST * COZERO
NAME * LAST+1
ONAME * NAME+1
RTYPE * ONAME+1
PTR * RTYPE+1
PTR1 * PTR+2
REXIST * PTR1+2
;***
VSTPTR * COZERO + 12 ;area used by VSTRNG only
OLDEV * VSTPTR + 2
GP1 * OLDEV + 2 ;ANOTHER GENERAL POINTER

BRKPTR * &FD ;2 byte pointer used in MOS BRK handling

 LNK UADE02
