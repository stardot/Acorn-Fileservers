 OPT UADE0B ;FILE > Uade0B
 TTL File server file UADE0B



;**********************************
;*        STRMAN UTILITIES        *
;**********************************



CRDESC
 TYA ;CREATE A NEW DESCRIPTOR
 PHA
 TXA
 PHA
 LDYIM CESIZE
 LDXIM  0
 JSR GETVEC
 STY CRNT
 STY CLRPTR
 STX CRNT + 1 ;CRNT := ADDR OF NEW DESCRIPTOR
 STX CLRPTR + 1
 LDYIM CESIZE
 LDXIM  0
 JSR CLRSTR ;CLEAR DESCRIPTOR TO ZERO
 PLA
 TAX
 PLA
 TAY
 RTS

MKFREE TXA
 PHA  ;PUSH X
 LDXIM CESIZE ;CLEAR CRNT DESCRIPTOR
 LDAIM  0
 TAY
MKFREB STAIY CRNT
 INY
 DEX
 BNE MKFREB
 LDA FRECHN ;PLACE CRNT DESCRIPTOR ON FREE CHAIN
 LDYIM CENEXT
 STAIY CRNT
 LDA FRECHN + 1
 INY
 STAIY CRNT ;NEXT OF CRNT := (FRECHN)
 LDA CRNT
 STA FRECHN
 LDA CRNT + 1
 STA FRECHN + 1 ;FRECHN := CRNT
 PLA
 TAX  ;PULL X
 RTS


FRDESC LDA FRECHN ;REMOVE A DESCRIPTOR FROM FREE CHAIN
 STA CRNT
 LDA FRECHN + 1
 STA CRNT + 1 ;CRNT := PTR TO A FREE ENTRY
 ORA CRNT
 BNE FRDECA
 LDAIM STERRG ;NO FREE CACHE DESCRIPTORS
 JSR INTERR
FRDECA LDYIM CENEXT
 LDAIY CRNT
 STA FRECHN
 INY
 LDAIY CRNT
 STA FRECHN + 1 ;FRECHN:=NEXT OF CRNT
 RTS


STCRNT LDA CACHTB ;PREV:=CACHTB;CRNT:=NEXT OF PREV
 STA PREV
 LDA CACHTB + 1
 STA PREV + 1
 LDYIM CENEXT
 LDAIY PREV
 STA CRNT
 INY
 LDAIY PREV
 STA CRNT + 1
 RTS


INSRCH JSR STCRNT ;INITIALISE CRNT,CMPPTR
 CLC
 LDA ARGPTR
 ADCIM ARGB
 STA CMPPTR
 LDA ARGPTR + 1
 ADCIM  0
 STA CMPPTR + 1
 RTS


NEXTCE LDYIM CENEXT ;PREV:=CRNT;CRNT:=NEXT OF CRNT
 LDAIY CRNT
 INY
 ORAIY CRNT
 BEQ NEXTCZ ;NO MORE ENTRIES (A=0)
 LDA CRNT
 STA PREV
 LDA CRNT + 1
 STA PREV + 1
 DEY  ;Y := CENEXT
 LDAIY CRNT
 TAX
 INY
 LDAIY CRNT
 STA CRNT + 1
 TXA
 STA CRNT
 LDAIM &FF ;A INDICATES THAT THERE ARE MORE ENTRIES
NEXTCZ RTS


COMP TXA  ;COMPARE CRNT ENTRY WITH X ARGS
 TAY
COMPA DEY
 LDAIY CMPPTR
 CMPIY CRNT
 BNE COMPZ
 DEX
 BNE COMPA
COMPZ TXA
 RTS


TSTSIN LDYIM ARGD
 LDAIY ARGPTR
 INY
 ORAIY ARGPTR
 INY
 ORAIY ARGPTR
 BNE TSTY
 LDAIM STERRB ;SIN = 0
 BNE TSTZ
TSTY LDAIM  0
 BEQ TSTZ
TSTZ RTS


RETSTA LDYIM CESTA
 LDAIY CRNT
 LDYIM ARGB
 STAIY ARGPTR ;LS(STORE ADDRESS)
 LDYIM CESTA + 1
 LDAIY CRNT
 LDYIM ARGC
 STAIY ARGPTR ;MS(STORE ADDRESS)
 INY  ;Y := ARGD
 LDA CRNT
 STAIY ARGPTR
 INY
 LDA CRNT + 1
 STAIY ARGPTR ;ADDRESS OF CRNT DESCRIPTOR
 RTS


READ JSR MRKCLN ;MARK BUFFER CLEAN
 LDYIM ARGA
 LDAIM  1 ;READ OBJECT
 STAIY NEWARG ;DSCMAN.READ
 JMP TRANSF


ENSURE JSR TSTMRK ;IS IT DIRTY?
 BEQ ENSURZ
 LDYIM ARGA
 LDAIM  2
 STAIY NEWARG
 JSR TRANSF ;WRITE IT TO DISC

 BNE ENSURZ
 JSR MRKCLN ;preserve return code from TRANSF
ENSURZ RTS


TRANSF LDA CRNT
 STA MOVFRM
 LDA CRNT + 1
 STA MOVFRM + 1
 CLC
 LDA NEWARG
 ADCIM ARGB
 STA MOVTO
 LDA NEWARG + 1
 ADCIM  0
 STA MOVTO + 1
 LDXIM &B ;DISC NO -> STORE ADDRESS
 JSR MOVE
 JMP DSCMAN


REMVIT PHA  ;PUSH A
 JSR TSTCNT
 BEQ REMOV
 LDAIM STERRH
 JSR INTERR
REMOV LDYIM CENEXT ;REMOVE CRNT FROM IN USE CHAIN
 LDAIY CRNT
 STAIY PREV
 PHA
 INY
 LDAIY CRNT
 STAIY PREV ;NEXT OF PREV := NEXT OF CRNT
 PHA
 JSR MKFREE ;PLACE IT ON FREE CHAIN
 PLA
 STA CRNT + 1
 PLA
 STA CRNT ;CRNT := NEXT OF PREV
 PLA  ;PULL A
 RTS


;EXPELL: ROUTINE TO REMOVE OBJECTS FROM THE CACHE.
;ENTRY: X := 2 => MATCH ON DISC NUMBER (I.E. ARGB&ARGC)
;X := 5 => MATCH ON DISC NUMBER + SIN

;THE ENTRY EXPELA IS USED FROM STRDRT WITH
;A NON-ZERO TO INDICATE THAT ONLY DIRTY
;BLOCKS SHOULD BE REMOVED FROM THE CACHE.

EXPELL LDAIM  0 ;=> REMOVE ALL BLOCKS REGARDLESS
EXPELA PHA
 STX STRTMP ;STRTMP := X
 JSR INSRCH
EXPLLC LDX STRTMP
 JSR COMP ;COMPARE DISC NUMBER & (POSSIBLY) SIN
 BNE EXPLLF
 JSR TSTCNT
 BEQ EXPLLD
 LDAIM STERRH ;REF COUNT > 0
 JSR INTERR

;ENSURE THE OBJECT & THEN REMOVE IT FROM THE CACHE

EXPLLD PLA
 PHA
 BEQ EXPLLG ;EQ => REMOVE ALL BLOCKS
 JSR TSTMRK ;NZ => REMOVE DIRTY BLOCKS ONLY
 BEQ EXPLLF ;NOT DIRTY, GO TO NEXT BLOCK
EXPLLG JSR ENSURE
  [ 1=1 
 LDYIM CEAGE ; AGE ENTRY DRAMATICALLY LH 3/12/85
 LDAIM &80
 STAIY CRNT
 BNE EXPLLF  ; NB branch always so can't detect disc errors.

 |
 JSR REMVIT ;REMOVE IT FROM CACHE & PLACE ON FREE CHAIN
 BNE EXPLLX ;skip if disc error
 ]

 LDYIM CENEXT ; REMVIT shuffles blocks down so process new current.
 LDAIY CRNT
 INY
 ORAIY CRNT
 BNE EXPLLC
EXPLLF JSR NEXTCE ;PREV:=CRNT;CRNT:=NEXT OF CRNT
 BNE EXPLLC
 PLA  ;RESTORE STACK                     

 LDAIM  0 ;RC:=0
 RTS

EXPLLX TAX ;save A, clean stack
 PLA
 TXA
 RTS


FNDSTA LDYIM ARGB ;FIND CACHE ENTRY WITH GIVEN STORE ADDRESS
 LDAIY ARGPTR
 STA STRTMP
 INY
 LDAIY ARGPTR
 STA STRTMP + 1
 JSR STCRNT
FNDSAA LDYIM CESTA
 LDAIY CRNT
 CMP STRTMP
 BNE FNDSAC
 INY
 LDAIY CRNT
 CMP STRTMP + 1
 BEQ FNDSAZ
FNDSAC JSR NEXTCE
 BNE FNDSAA
 LDAIM STERRF ;INVALID WINDOW ADDRESS
FNDSAZ RTS


DECGEN SEC
 LDYIM CESTA
 LDAIY CRNT
 SBCIM  1
 STA GENPTR
 INY
 LDAIY CRNT
 SBCIM  0
 STA GENPTR + 1
 RTS


MRKCLN PHA  ;MARK STORE BUFFER CLEAN
 TYA  ;SAVE A & Y
 PHA  ;PUSH Y
 JSR DECGEN ;GENPTR SHOULD CONTAIN ADDRESS OF BUFFER
 LDAIM  0 ;A := 0
 TAY  ;Y := 0
 STAIY GENPTR ;[GENPTR] := 0
 PLA
 TAY  ;PULL Y
 PLA  ;PULL A
 RTS


TSTMRK JSR DECGEN ;TEST DIRTY MARKER
 LDYIM  0 ;NOTE THIS RTN DESTROYS A & Y
 LDAIY GENPTR ;A:=[GENPTR]
 RTS


INCCNT LDYIM CERCNT ;INCREMENT REFERENCE COUNT
 LDAIY CRNT
 CMPIM &FF
 BNE INCCNA
 LDAIM STERRK ;REFERENCE COUNT = $FF
 JSR INTERR
INCCNA CLC
 ADCIM  1
 STAIY CRNT
 RTS


DECCNT LDYIM CERCNT ;DECREMENT REFERENCE COUNT
 LDAIY CRNT
 BNE DECCNA
 LDAIM STERRD ;REFERENCE COUNT = 0
 JSR INTERR
DECCNA SEC
 SBCIM  1
 STAIY CRNT
 RTS


TSTCNT LDYIM CERCNT ;TEST VALUE OF REFERNENCE COUNT
 LDAIY CRNT
 RTS


;FREEST: GET AMTNED WORTH OF FREE STORE.
;EXIT : A = RC
;CRNT POINTS TO DESCRIPTOR WITH STORE ADDRESS SET

;FUNCTION:-
;1) AGE ALL THE ENTRIES IN THE CACHE
;2)FIND OUT THE MOST COST EFFECTIVE AREA
;OF MEMORY TO USE.

;WHILE crnt <> 0 AND min cost <> 0
;DO IF amount needed<=(storeaddrOFcrnt-storeaddrOFprev
;- lengthOFprev-2)
;THEN IF cost<min cost
;THEN min cost := cost;
;best start := prev;
;best end := crnt
;FI;
;prev:=nextOFprev;
;cost:=cost-costOFprev
;ELSE IF ref count OF crnt <> 0
;THEN prev := crnt;
;cost := 0
;ELSE cost +:= cost OF crnt
;FI;
;crnt := next OF crnt
;FI
;OD;

;WHILE crnt <> best end
;DO ensure(crnt); #ENSURE WINDOW UPTO DATE ON DISC#
;remove(crnt) #REMOVE CRNT FROM IN USE CHAIN#
;OD;

;crnt := get free descriptor;
;straddrOFcrnt:=straddrOFprev+lengthOFprev+1




FREEST LDA AMTNED
 ORA AMTNED + 1
 BNE FREETA
 LDAIM STERRE
 JMP FREETZ

;FIRST,AGE EACH OBJECT IN THE CACHE

FREETA JSR STCRNT ;PREV:=CACHTB;CRNT:=NEXT OF PREV

FREETB LDYIM CEAGE
 LDAIY CRNT
 CMPIM LRU
 BEQ FREETD
 SEC
 SBCIM  1
 STAIY CRNT ;AGE OF CRNT -:= 1
FREETD JSR NXTCRN
 BNE FREETB

;NOW SEE WHICH IS THE BEST AREA OF MEMORY TO USE

 JSR STCRNT
 LDAIM  0
 STA BSTSTA
 STA BSTSTA + 1 ;BSTSTA : = 0
 STA BSTEND
 STA BSTEND + 1 ;BSTEND := 0
 STA COST
 STA COST + 1 ;COST := 0
 LDAIM &FF
 STA MINCST
 LDAIM &7F
 STA MINCST + 1 ;MINCST := $7FFF

FREETL JSR TSTGAP
 BEQ FREEJC
 JMP FREETQ

;SEE IF COST < MIN COST

FREEJC LDXIM &FF ;X<>0 here
 LDA COST
 PHA
 LDA COST + 1
 PHA ;save cost for new algorithm

 LDYIM CENEXT
 LDAIY PREV
 STA GP1
 INY
 LDAIY PREV
 STA GP1 + 1 ;intermediate pointer

 LDAIY GP1
 CMP CRNT + 1
 BNE FREEJA
 DEY
 LDAIY GP1
 CMP CRNT
 BNE FREEJA ;skip if not single slot

 LDYIM CEAGE
 LDAIY GP1 ;get the age
 TAX
 STA COST ;make new account
 LDAIM  0
 STA COST + 1

 LDY AMTNED + 1
 LDA AMTNED
 BEQ FREEJB
 INY

FREEJB DEY
 BEQ FREEJA
 CLC
 TXA
 ADC COST
 STA COST
 BCC FREEJB
 INC COST + 1
 BNE FREEJB

FREEJA LDA COST
 CMP MINCST
 LDA COST + 1
 SBC MINCST + 1
 BCS FREETM

 LDA PREV
 STA BSTSTA
 LDA PREV + 1
 STA BSTSTA + 1 ;BSTSTA := PREV
 LDA CRNT
 STA BSTEND
 LDA CRNT + 1
 STA BSTEND + 1 ;BSTEND := CRNT
 LDA COST
 STA MINCST
 LDA COST + 1
 STA MINCST + 1 ;MINCST := COST
 ORA MINCST
 TAX

FREETM PLA
 STA COST + 1
 PLA
 STA COST ;restore old value of COST
 TXA
 BEQ FREETV ;I.E. FOUND A GAP
 LDYIM CENEXT
 LDAIY PREV
 TAX
 INY
 LDAIY PREV
 STA PREV + 1
 TXA
 STA PREV ;PREV := NEXT OF PREV

 LDYIM CEBLKS
 LDAIY PREV ;get length
 TAX ;count around the loop

FREEK SEC
 LDA COST
 LDYIM CEAGE
 SBCIY PREV
 STA COST
 LDA COST + 1
 SBCIM  0
 STA COST + 1 ;cost -:= cost OF prev*length OF prev
 DEX
 BNE FREEK ;count for length of blocks
 JMP FREETL

FREETQ JSR TSTCNT
 BEQ FREETR

;COST := 0; PREV := CRNT

 LDAIM  0
 STA COST
 STA COST + 1
 LDA CRNT
 STA PREV
 LDA CRNT + 1
 STA PREV + 1
 JMP FREETT

FREETR
 [ &00=0
 LDYIM CEBLKS
 LDAIY CRNT ;grab length (one byte only)
 TAX ;count around loop
 ]

FREET1 CLC  ;cost +:=(cost OF crnt)*(length OF crnt)
 LDA COST
 LDYIM CEAGE
 ADCIY CRNT
 STA COST
 BCC FREET2
 INC COST + 1
FREET2
 [ &00=0
 DEX
 BNE FREET1 ;continue until all done
 ]

FREETT JSR NXTCRN ;CRNT := NEXT OF CRNT
 BEQ FREETS
 JMP FREETL

;FIRST SEE IF WE FOUND AN AREA OF MEMORY TO USE

FREETS LDA BSTSTA
 ORA BSTSTA + 1
 BNE FREETV
 LDAIM STERRL ;STORE DEADLOCK !!!!
 JSR INTERR

;NOW REMOVE ALL THE OBJECTS IN THE GAP

FREETV LDA BSTSTA
 STA PREV
 LDA BSTSTA + 1
 STA PREV + 1 ;PREV := BSTSTA
 LDYIM CENEXT
 LDAIY PREV
 STA CRNT
 INY
 LDAIY PREV
 STA CRNT + 1 ;CRNT := NEXT OF PREV

;NOW CREATE THE GAP (IF NECESSARY)

 LDAIM  0
 PHA ;save RC
FREETW LDA BSTEND ;WE MUST DO THIS TEST FIRST
 CMP CRNT
 BNE FREETX
 LDA BSTEND + 1
 CMP CRNT + 1
 BNE FREETX

 JSR NEWDES ;GET FREE DESCR,CHAIN IT IN,CALC STORE ADDR
 PLA ;RC here
FREETZ RTS

FREETX JSR ENSURE
 BEQ FREETY

 CMPIM &C9 ;look for protected disc
 BEQ FREETU ;skip as object is now removed anyway

 JSR INTERR
FREETY JSR REMVIT
 JMP FREETW

FREETU TAX
 PLA; change old RC
 BNE FREETP
 TXA
FREETP PHA ;change return code
 JMP FREETY


NEWDES JSR FRDESC ;CRNT := NEW DESCRIPTOR

;storeaddrOFcrnt:=storeaddrOFprev+lengthOFprev+1

 JSR LNTPRE
 SEC  ;BECAUSE WE WANT TO ADD 1
 LDYIM CESTA
 LDAIY PREV
 ADC BREGA
 STAIY CRNT
 INY
 LDAIY PREV
 ADC BREGA + 1
 STAIY CRNT

;NOW CHAIN IT IN

 LDYIM CENEXT
 LDAIY PREV
 STAIY CRNT
 INY
 LDAIY PREV
 STAIY CRNT ;NEXT OF CRNT := NEXT OF PREV
 DEY  ;Y:=CENEXT
 LDA CRNT
 STAIY PREV
 INY
 LDA CRNT + 1
 STAIY PREV ;NEXT OF PREV := CRNT
 RTS


LNTPRE LDYIM CEBLKS ;BREGA := LENGTH OF PREV (IN BYTES)
 LDAIY PREV
 STA BREGA
 INY
 LDAIY PREV
 STA BREGA + 1
 JMP MULTBS


;TSTGAP: A:= IF amount needed <= storeaddrOFcrnt-
;storeaddrOFprev-lengthOFprev-2
;THEN 0
;ELSE FF
;FI

TSTGAP JSR LNTPRE ;BREGA := LENGTH OF PREV(IN BYTES)
 CLC
 LDYIM CESTA
 LDAIY CRNT
 SBCIY PREV
 STA STRTMP
 INY
 LDAIY CRNT
 SBCIY PREV
 STA STRTMP + 1 ;STRTMP:=straddrOFcrnt-straddrOFprev-1
 SEC
 LDA BREGA
 ADC AMTNED
 STA BREGA
 LDA BREGA + 1
 ADC AMTNED + 1
 STA BREGA + 1 ;BREGA:=amountneeded+lengthOFprev+1
 BVC TSTGB
 LDAIM STERRM ;OVERFLOW!!!
 JSR INTERR
TSTGB SEC
 LDA STRTMP
 SBC BREGA
 LDA STRTMP + 1
 SBC BREGA + 1
 BMI TSTGL
 LDAIM  0 ;I.E. GAP BIG ENOUGH
 BEQ TSTGZ
TSTGL LDAIM &FF ;I.E GAP TOO SMALL
TSTGZ RTS


NXTCRN LDYIM CENEXT ;CRNT := NEXT OF CRNT
 LDAIY CRNT
 TAX
 INY
 LDAIY CRNT
 STA CRNT + 1
 TXA
 STA CRNT
 ORA CRNT + 1 ;A:= CRNT ! CRNT +01
 RTS

 LNK UADE0C
