 OPT UADE12 ;> Uade12
 TTL File server file UADE12

;** MAPMAP UTILS II(2) **

SMPPTR  ;SMPPTR

;SET POINTER TO ENTRY IN MAP TABLE
;CORRESPONDING TO DRIVE IN CURDRV.
;POINTER IS IN BOTH MAPPTR AND
;MAPENT.

 LDX CURDRV
 LDA MAPTB
 STA MAPPTR
 LDA MAPTB + 1
 STA MAPPTR + 1

SMPPTL DEX
 BMI SMPPTX

 JSR MPADMP
 JMP SMPPTL

SMPPTX LDA MAPPTR
 STA MAPENT
 LDA MAPPTR + 1
 STA MAPENT + 1
 RTS


;RDDATA: READ DISC INFO FROM SECTOR 0 INTO
;STORE STARTING AT ADDRESS IN FREPTR.

;ENTRY: A = DRIVE NUMBER

;EXIT:  A = RC

;FUNCTION: -
;0) SET FDRIVE, OLDFDR & SELECT & START DRIVE
;1) SEEK TRACK ZERO
;2) READ SECTOR 0

;RDSZRO ENTRY POINT FOR USE WHEN
;DDRSTA POINTER ALREADY SET UP.

RDDATA PHA
 LDA FREPTR
 STA DSCCB+TRADD
 LDA FREPTR + 1
 STA DSCCB+TRADD + 1 ;DDRSTA:=STORE ADDR FOR SECTOR
 LDAIM  0
 STA DSCCB
 STA DSCCB+TRADD+ 2
 STA DSCCB+TRADD+ 3
 PLA

 [ WINCH=0
RDSTWO STA DRIVNO
 LSRA
 RORA
 RORA
 RORA
 STA DSCCB+CMD+ 1
 LDAIM &08
 STA DSCCB+CMD
 LDAIM  0
 STA DSCCB+CMD+ 2
 STA DSCCB+CMD+ 4
 STA DSCCB+CMD+ 5
 STA DSCCB+LENGTH
 STA DSCCB+LENGTH+ 2
 STA DSCCB+LENGTH+ 3
 LDA DSCCB+TRADD
 STA MPCYPT
 LDA DSCCB+TRADD+1
 STA MPCYPT+1
 LDAIM  0 ;SECTOR ZERO
 STA RBDA
 STA DSCCB+CMD+ 3
 LDAIM  1
 STA DSCCB+LENGTH+ 1
RDDLP JSR DSCCMD
 BNE RDSEC1
 LDYIM SZOFF
 LDAIY MPCYPT
 STA DSCCB+CMD+3
 INY
 LDAIY MPCYPT
 STA DSCCB+CMD+2
 INY
 LDA DRIVNO
 LSRA
 RORA
 RORA
 RORA
 ORAIY MPCYPT
 STA DSCCB+CMD+1
 JSR DSCCMD
 BEQ RDDND
RDSEC1 LDA RBDA
 BNE RDDND
 LDAIM 1
 STA RBDA
 STA DSCCB+CMD+3
 JMP RDDLP
RDDND RTS
 |
RDSTWO STA DSCCB ;SET DRIVE NNNUMBER

 STA DSCCB+PARAMS ;TRACK ZERO
 LDAIM  2 ;SECTOR TWO
 STA DSCCB+PARAMS+ 1 ;SECTOR TWO
 LDAIM  3 ;NUMBER OF PPARAMETERS
 STA DSCCB+NOPRMS
 LDAIM &21 ; ONE SECTOR
 STA DSCCB+PARAMS+ 2
 LDAIM &53 ;FOR READ
 STA DSCCB+CMD

 JSR DSCCMD

 RTS
 ]

;
; MAKE AN ENTRY IN THE MAP BLOCK
;
; ON ENTRY
;     MKENVA HOLD THE NUMBER OF BLOCKS TO ALLOCATE
;     MAPTMP POINT TO THE MAP BLOCK
;
; ON EXIT
;     C SET IF FAILED
;
; USES
;     MAPGEN
;     MPTMPE
;
MKEN LDYIM MPSPCY
 LDAIY MAPPTR
 STA TMPSPC
 INY
 LDAIY MAPPTR
 STA TMPSPC + 1
 LDA MAPGEN
 PHA
 LDA MAPGEN + 1
 PHA
 LDA MAPTMP ;GET POINTER TO MAP BLOCK
 STA MAPGEN
 LDA MAPTMP+ 1
 STA MAPGEN+ 1
 JSR GETPOS ;GET NEXT FREE POSITION IN MAP BLOCK
 BCS MES1 ;BRANCH IF ROOM
 JMP MECNT
MES1 LDYIM MPCYMP ;GET ADDRESS OF CYLINDER MAP
 LDAIY MAPPTR
 STA MAPGEN
 INY
 LDAIY MAPPTR
 STA MAPGEN+ 1
 SEC
 LDYIM  0 ;CHECK IF ROOM FOR ANOTHER BLOCK
 LDAIY MAPGEN
 SBCIM  1
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 SBCIM  0
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 SBCIM  0
 STAIY MAPGEN
 BCS NOSS1
 JMP NOSPC
NOSS1 LDA MAPTMP
 STA MPMBPT
 STA CBSTA
 LDA MAPTMP + 1
 STA MPMBPT + 1
 STA CBSTA + 1
 JSR MMBLKD
 JSR GTCYPS ;GET CLOSET CYCLINDER BLOCK
 LDA MAPGEN
 STA MPTMPB
 LDA MAPGEN + 1
 STA MPTMPB + 1
 LDA MPTMPE
 STA MPTMPC ;NEW CYLINDER COUNT
 LDA MPTMPE+ 1
 STA MPTMPC+ 1
 JSR RDBTMP
 JSR ALBLK ;GET NEW MAP BLOCK
 SEC
 JSR RDMPBK ;GET AREA OF STORE FOR IT
 LDA ERRTYP
 BEQ MKR1
 JSR ULMB
 JMP NOSPC
MKR1 CLC
 LDA MPMBPT ;GET POINTER TO OLD MAP BLOCK
 STA CBSTA
 ADCIM LSTENT ;POINT TO LAST ENTRY
 STA MPMBPT
 LDA MPMBPT+ 1
 STA CBSTA + 1
 ADCIM /(LSTENT)
 STA MPMBPT+ 1
 LDYIM  0 ;SAVE SIN OF NEW MAP BLOCK
 LDA MPTMPA
 STAIY MPMBPT
 INY
 LDA MPTMPA+ 1
 STAIY MPMBPT
 INY
 LDA MPTMPA+ 2
 STAIY MPMBPT
 INY ;NOW SAVE LENGTH
 LDAIM  1
 STAIY MPMBPT
 INY
 LDAIM  0
 STAIY MPMBPT
 JSR MMBWT
 JSR ULMB
 CLC
 LDYIM MPCYMP ;GET ADDRESS OF CYLINDER MAP
 LDAIY MAPPTR
 STA MAPGEN
 ADCIM  3 ;POINT TO START OF ENTRIES
 STA MPTMPB
 INY
 LDAIY MAPPTR
 STA MAPGEN + 1
 ADCIM  0
 STA MPTMPB+ 1
 JSR GTCYPS
 LDA MAPGEN
 STA MPCYPT
 LDA MAPGEN + 1
 STA MPCYPT + 1
 LDA MPTMPE
 STA MPTMPC
 LDA MPTMPE + 1
 STA MPTMPC + 1
 JSR RDBTMP
 LDA MAPTMP
 STA MAPGEN ;SAVE ADDRESS OF NEW MAP BLOCK
 LDA MAPTMP+ 1
 STA MAPGEN+ 1
; TEST 27/10/83
 JSR SIZE
 LDA MPTMPD
 CMP MKENVA
 LDA MPTMPD + 1
 SBC MKENVA + 1
 BCS MKOK1
 LDA MPTMPD
 STA MKENVA
 LDA MPTMPD + 1
 STA MKENVA + 1
; END OF TEST 27/10/83
 [ &FF=0
 LDA MPTMPC+ 1
 PHA ;SAVE MPTMPC
 LDA MPTMPC
 PHA
MELP1 LDA MPTMPC
 ORA MPTMPC+ 1
 BEQ MEBBC ;LOOKING FOR POSTION IN CYLINDER MAP
 CLC
 LDA MPTMPB
 ADCIM  2
 STA MPTMPB+ 1
 ADCIM  0
 STA MPTMPB+ 1
 SEC
 LDA MPTMPC
 SBCIM  1
 STA MPTMPC
 LDA MPTMPC+ 1
 SBCIM  0
 STA MPTMPC+ 1
 JMP MELP1
MEBBC PLA
 STA MPTMPC ;RESTORE MPTMPC
 PLA
 STA MPTMPC+ 1
 ]
MKOK1 JSR GETPOS ;GET FREE POSITION IN MAP BLOCK
MECNT LDAIM  0
 STA MPTMPE
 STA MPTMPE+ 1 ;ZERO VARIABLES
 STA MPTMPE+ 2
 TAY
MELP3 LDAIY MPSCPT ;LOOK FOR BLOCKS TO ALLOCATE
 BEQ MEADD ;NOT FOUND
 LDXIM  8
MELP9 RORA
 BCS MECNT2
 DEX
 INC MPTMPE ;STILL NOT FOUND
 BNE MELP9
 INC MPTMPE+ 1
 JMP MELP9 ;CHECK NEXT ONE
MEADD CLC ;NEXT BYTE SO ADD 8
 LDA MPTMPE
 ADCIM  8
 STA MPTMPE
 LDA MPTMPE+ 1
 ADCIM  0
 STA MPTMPE+ 1
 INY
 JMP MELP3
MECNT2 PHA
 LDA MKENVA
 STA MPTMPB
 LDA MKENVA + 1
 STA MPTMPB + 1
 PLA
MELP8 CLC
 RORA
 PHP
 PHA
 SEC
 LDA MPTMPB
 SBCIM  1
 STA MPTMPB
 LDA MPTMPB + 1
 SBCIM  0
 STA MPTMPB + 1
 ORA MPTMPB
 BEQ MESK3
 PLA
 PLP
 DEX
 BNE MELP8
 STAIY MPSCPT
 INY
 LDAIY MPSCPT
 LDXIM  8
 RORA
 JMP MELP8
MESK3 PLA
 PLP
 DEX
MELP7 RORA
 DEX
 BNE MELP7
 STAIY MPSCPT
 LDA MPTMPC
 PHA
 LDA MPTMPC+ 1
 PHA ;SAVE POSITION
MELP4 LDA MPTMPC ;NOW GET DISC ADDRESS
 ORA MPTMPC+ 1 ;IF ZERO THS IS IT!
 BEQ MESK2
 CLC
 LDA MPTMPE
 ADC TMPSPC
 STA MPTMPE
 LDA MPTMPE+ 1
 ADC TMPSPC + 1
 STA MPTMPE+ 1
 LDA MPTMPE+ 2
 ADCIM  0
 STA MPTMPE+ 2
 SEC
 LDA MPTMPC
 SBCIM  1
 STA MPTMPC
 LDA MPTMPC + 1
 SBCIM  0
 STA MPTMPC + 1
 JMP MELP4
MESK2 PLA
 STA MPTMPC + 1
 PLA
 STA MPTMPC
 LDYIM  0 ;SAVE THE DISC ADDRESS
 LDA MPTMPE
 STAIY MAPGEN
 INY
 LDA MPTMPE+ 1
 STAIY MAPGEN
 INY
 LDA MPTMPE+ 2
 STAIY MAPGEN
 INY
 LDA MKENVA ;SAVE SIZE
 STAIY MAPGEN
 LDA MKENVA+ 1
 INY
 STAIY MAPGEN
 LDA MPSCPT
 STA CBSTA
 LDA MPSCPT + 1
 STA CBSTA + 1
 JSR MBMWT ;MARK BIT MAP WRITTEN TO
 LDA MAPTMP
 STA CBSTA
 LDA MAPTMP + 1
 STA CBSTA + 1
 JSR MMBWT ;MARK MAP BLOCK WRITTEN
 SEC
 LDA DIVTMP
 SBC MKENVA
 STA DIVTMP
 LDA DIVTMP + 1
 SBC MKENVA + 1
 STA DIVTMP + 1
 CLC ;FLAG EVERYTHING OK
MEND PLA
 STA MAPGEN + 1
 PLA
 STA MAPGEN
 RTS
NOSPC CLC
 LDYIM  0
 LDAIY MAPGEN
 ADCIM  1
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADCIM  0
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADCIM  0
 STAIY MAPGEN
 SEC ;NO GOOD
 JMP MEND

;ALLOCATE ONE BLOCK
;
; LOOKS IN CURRENT BIT MAP AND RETURNS THE SIN 
; OF THE FIRST FREE BLOCK
;
; ON ENTRY
;      MPTMPC HOLDS THE CYLINDER NUMBER
;      MPSCPT POINTS TO THE CURRENT BIT MAP
;
; ON EXIT
;      MPTMPA HOLDS THE SIN OF THE ALLOCATED BLOCK
;
; USES
;      MPCYPT
;
ALBLK LDAIM  0 ;ZERO VARIABLES
 STA MPTMPA
 STA MPTMPA+ 1
 STA MPTMPA+ 2
 LDA MPSCPT ;COPY POINTER TO USE
 STA MPCYPT
 LDA MPSCPT + 1
 STA MPCYPT + 1
ALNX LDYIM  0
 LDAIY MPCYPT ;FIND FREE BLOCK
 BEQ ALS8
ALLP RORA ;NOW FIND THE SECTOR
 BCS ALGT ;FOUND WHEN C SET
 INC MPTMPA ;KEEP LOOKING
 BNE ALLP
 INC MPTMPA + 1
 JMP ALLP
ALS8 CLC
 LDA MPTMPA ;MOVE TO NEXT BYTE
 ADCIM  8
 STA MPTMPA
 LDA MPTMPA+ 1
 ADCIM  0
 STA MPTMPA+ 1
 INC MPCYPT
 BNE ALSK1
 INC MPCYPT+ 1 ;*** M OAKLEY 27/1/86 ***
ALSK1 JMP ALNX
ALGT PHA ;SAVE TO MARK AS ALLOCATED
 LDA MPTMPA
 ANDIM  7
 TAX
 INX
 PLA
 CLC
ALLP2 ROLA
 DEX
 BNE ALLP2
 STAIY MPCYPT ;BLOCK MARKED ALLOCATED
 LDA MPTMPC
 STA MAPTMP
 LDA MPTMPC+ 1
 STA MAPTMP+ 1
ALLP3 LDA MAPTMP
 ORA MAPTMP+ 1
 BEQ ALND ;GET DISC ADDRESS
 LDYIM MPSPCY
 CLC
 LDA MPTMPA
 ADCIY MAPPTR
 STA MPTMPA
 INY
 LDA MPTMPA+ 1
 ADCIY MAPPTR
 STA MPTMPA+ 1
 LDA MPTMPA+ 2
 ADCIM  0
 STA MPTMPA+ 2
 SEC
 LDA MAPTMP ;DECREMENT CYLINDER COUNT
 SBCIM  1
 STA MAPTMP
 LDA MAPTMP+ 1
 SBCIM  0
 STA MAPTMP+ 1
 JMP ALLP3
ALND LDA MPTMPB ;GET POINTER TO CYLINDER MAP
 STA MPCYPT
 LDA MPTMPB+ 1
 STA MPCYPT+ 1
 LDYIM  0 ;DECREMENT FREE COUNT
 SEC
 LDAIY MPCYPT
 SBCIM  1
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 SBCIM  0
 STAIY MPCYPT
 LDYIM MPCYMP
 LDAIY MAPPTR
 STA MPCYPT
 INY
 LDAIY MAPPTR
 STA MPCYPT + 1
 LDA MPSCPT
 STA CBSTA
 LDA MPSCPT + 1
 STA CBSTA + 1
 JSR MBMWT ;MARK BIT MAP WRITTEN
 LDA MPTMPA
 ORA MPTMPA + 1
 ORA MPTMPA + 2
 BNE AND
 LDAIM &FC
 JSR INTERR
AND RTS
; ALLOCATE A SERIES OF BLOCKS
;
; ON ENTRY
;      MPCYPT POINTS TO POSITION IN CYLINDER MAP
;      DIVTMP HOLDS NUMBER OF SECTORS REQUIRED
;      MPSCPT POINTS TO BIT MAP
;      MAPPTR POINTS TO MAP TABLE
;      MAPTMP POINTS TO MAP BLOCK
;      MPTMPC HOLDS CYLINDER NUMBER
;
; ON EXIT
;      DIVTMP HOLDS NUMBER OF BLOCKS LEFT
;      C SET IF FAILED
;
; USES
;      MAPGEN
;
ABLKS LDYIM MPCYMP
 LDAIY MAPPTR ;GET POINTER TO START OF CYLINDER MAP
 STA MAPGEN
 INY
 LDAIY MAPPTR
 STA MAPGEN+ 1
 JSR SIZE ;GET SIZE OF THIS BLOCK
 LDA MPTMPD ;MPTMPD HAS SIZE
 CMP DIVTMP ;SEE IF WE NEED THEM ALL
 LDA MPTMPD+ 1
 SBC DIVTMP+ 1
 BCC ABSALL
 LDA DIVTMP+ 2
 BNE ABSALL ;ABSALL ALLOCATES ALL BLOCKS
 LDA DIVTMP
 STA MKENVA ;MAKE ENTRY IN MAP BLOCK
 LDA DIVTMP+ 1
 STA MKENVA+ 1
ABSMKE JSR MKEN
 BCS ABSFLD ;ALL DONE SO FINISH
 LDA ERRTYP
 BNE ABSFLD
 LDYIM  0
 SEC
 LDAIY MPCYPT
 SBC MKENVA
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 SBC MKENVA + 1
 STAIY MPCYPT
 LDYIM  0
 LDAIY MPCYPT
 CMPIM &FF
 BNE ABSNM1
 INY
 LDAIY MPCYPT
 CMPIM &FF
 BNE ABSNM1
 LDAIM &FA
 JSR INTERR
ABSNM1 CLC
 RTS
ABSFLD JSR DAGRP ;NOT ABLE TO MAKE ENTRY
 LDYIM  0
 CLC
 LDAIY MAPGEN ;INCREASE FREE COUNT
 ADC MKENVA
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADC MKENVA+ 1
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADCIM  0
 STAIY MAPGEN
 SEC ;TO INDICATE FAILURE
 RTS
ABSALL LDA MPTMPD
 STA MKENVA ;PREPARE TO MAKE ENTRY IN MAP BLOCK
 LDA MPTMPD+ 1
 STA MKENVA+ 1
 JMP ABSMKE


; DEALLOCATE MAP BLOCK
;
;   DEALLOCATES THE SPECIFIED MAP BLOCK. OVERWRITES THE SEQUENCE NUBERS
;   SO THAT IT WILL NO LONGER APPEAR AS A MAP BLOCK
;
; ON ENTRY
;     MPTMPA HOLDS THE SIN OF THE MAP BLOCK
;     MPCYPT POINTS TO THE CYLINDER MAP
;
; USES
;     MPTMPA,MPTMPD,MPTMPC,MPSCPT
;
DAMPBK LDYIM MPSPCY
 LDAIY MAPPTR
 STA TMPSPC
 INY
 LDAIY MAPPTR
 STA TMPSPC + 1
 LDA MPTMPA ;DEALLOCATE MAP BLOCK
 STA CBSIN
 LDA MPTMPA + 1
 STA CBSIN + 1
 LDA MPTMPA + 2
 STA CBSIN + 2
 JSR FNDMB ; GNCBPT POINTS TO CURRENT ENTRY
 LDYIM CBSA
 LDAIY GNCBPT
 STA MPSCPT ;SAVE POINTER TO MAP BLOCK
 STA CBSTA
 INY
 LDAIY GNCBPT
 STA MPSCPT + 1
 STA CBSTA + 1
 LDYIM MBSQNO
 LDAIM &FF
 STAIY MPSCPT ;SAVE INVALID SQ.NO.
 CLC
 LDA MPSCPT
 ADCIM LSTSQ
 STA MPSCPT
 LDA MPSCPT + 1
 ADCIM /(LSTSQ )
 STA MPSCPT + 1
 LDAIM  0
 TAY
 STAIY MPSCPT
 JSR MMBWT
 LDAIM  0
 STA MPTMPC ; ZERO VARIABLES
 STA MPTMPC + 1
DMBLP1 SEC
 LDA MPTMPA
 SBC TMPSPC ; FIND CYLINDER NUMBER
 STA MPTMPA
 LDA MPTMPA + 1
 SBC TMPSPC + 1
 STA MPTMPA + 1
 LDA MPTMPA + 2
 SBCIM  0
 STA MPTMPA + 2
 BCC DMBCNT ; CYLINDER FOUND
 INC MPTMPC ;INCREMENT CYLINDER COUNT
 BNE DMBLP1
 INC MPTMPC + 1
 JMP DMBLP1
DMBCNT JSR RDBTMP ; GET THE RELEVCANT BIT MAP TO STORE
 CLC
 LDA MPTMPA ; GET WHICH BLOCK OF THIS CYLINDER
 ADC TMPSPC
 STA MPTMPA
 LDA MPTMPA + 1
 ADC TMPSPC + 1
 STA MPTMPA + 1
 LDA MPTMPA + 2
 ADCIM  0
 STA MPTMPA + 2
 LDYIM  0
DMBLP2 SEC ;GET POSITION IN BIT MAP
 LDA MPTMPA
 SBCIM  8
 STA MPTMPA
 LDA MPTMPA + 1
 SBCIM  0
 STA MPTMPA + 1
 BCC DMBSK1 ; POSITION FOUND IF BRANCH
 INY
 JMP DMBLP2
DMBSK1 CLC
 LDA MPTMPA ; GET OLD POSITION BACK
 ADCIM  8
 STA MPTMPA
 LDA MPTMPA + 1
 ADCIM  0
 STA MPTMPA + 1
 LDX MPTMPA
 INX
 LDAIY MPSCPT ; X HOLDS POSITION IN BYTE A HOLDS THE BYTE
DMBLP3 RORA ;MOVE TO CORRECT POSITION
 DEX
 BNE DMBLP3
 SEC
 LDX MPTMPA ;BLOCK IS FLAGGED FREE AND X HOLDS NUMBER OF SHIFTS
 INX
DMBLP4 ROLA ; UNTIL BACK TO CORRECT POSITION
 DEX
 BNE DMBLP4
 STAIY MPSCPT ; SAVE FLAGS
 CLC
 LDA MPCYPT ;NOW MAKE COUNTS CORRECT
 ADCIM  3
 STA MAPGEN
 LDA MPCYPT + 1
 ADCIM  0
 STA MAPGEN + 1
 LDA MPTMPC
 STA MPTMPE
 LDA MPTMPC + 1
 STA MPTMPE + 1
DMBLP5 LDA MPTMPE
 ORA MPTMPE + 1
 BEQ DMBSK2
 CLC
 LDA MAPGEN
 ADCIM  2
 STA MAPGEN
 LDA MAPGEN + 1
 ADCIM  0
 STA MAPGEN + 1
 SEC
 LDA MPTMPE
 SBCIM  1
 STA MPTMPE
 LDA MPTMPE + 1
 SBCIM  0
 STA MPTMPE + 1
 JMP DMBLP5
DMBSK2 LDYIM  0
 CLC
 LDAIY MAPGEN ;INCREMENT FREE BLOCK COUNT
 ADCIM  1
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADCIM  0
 STAIY MAPGEN
 LDYIM  0
 CLC
 LDAIY MPCYPT
 ADCIM  1
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 ADCIM  0
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 ADCIM  0
 STAIY MPCYPT
 LDA MPSCPT
 STA CBSTA
 LDA MPSCPT + 1
 STA CBSTA + 1
 JMP MBMWT ; NOW FINISHED
;
; DALLOCATE A GROUP OF BLOCKS
;    MARKS THE ENTRIES IN THE SPECIFIED BIT MAP FREE ASND INCREASES THE FREE BLOCK COUNT
;
; ON ENTRY
;     MPSCPT POINTS TO RELEVANT ENTRY IN MAP BLOCK
;     MPCYPT POINTS TO CYLINDER MAP
;     MAPTMP POINTS TO MAP BLOCK
;
; USES
;     MPTMPC,MAPGEN,MPTMPD,MAPTMP
;
DAGRP LDA MAPTMP
 PHA
 LDA MAPTMP + 1
 PHA
 LDYIM  0
 STY MPTMPC ; ZERO VALUES
 STY MPTMPC + 1
 LDAIY MPSCPT ; GET SIN
 STA MPTMPD
 INY
 LDAIY MPSCPT
 STA MPTMPD + 1
 INY
 LDAIY MPSCPT
 STA MPTMPD + 2
 LDA MPSCPT ; SAVE MAP BLOCK POINTER
 STA MAPGEN
 LDA MPSCPT + 1
 STA MAPGEN + 1

DAGLP1 LDYIM MPSPCY
 SEC ; NOW FIND CYLINDER
 LDA MPTMPD
 SBCIY MAPPTR
 STA MPTMPD
 INY
 LDA MPTMPD + 1
 SBCIY MAPPTR
 STA MPTMPD + 1
 LDA MPTMPD + 2
 SBCIM  0
 STA MPTMPD + 2
 BCC DAGGT ; END FOUND
 INC MPTMPC ; COUNT TO NEXT CYLINDER
 BNE DAGLP1
 INC MPTMPC + 1
 JMP DAGLP1
DAGGT LDYIM MPSPCY
 CLC
 LDA MPTMPD ; RESTORE BLOCK COUNT
 ADCIY MAPPTR
 STA MPTMPD
 INY
 LDA MPTMPD + 1
 ADCIY MAPPTR
 STA MPTMPD + 1
 LDA MPTMPD + 2
 ADCIM  0
 STA MPTMPD + 2
 LDA MPTMPC ; SAVE CYLINDER NUMBER
 STA MAPTMP
 LDA MPTMPC + 1
 STA MAPTMP + 1
 JSR RDBTMP
 LDYIM  0
DAGLP2 SEC ; GET POSITION IN BIT MAP
 LDA MPTMPD
 SBCIM  8
 STA MPTMPD
 LDA MPTMPD + 1
 SBCIM  0
 STA MPTMPD + 1
 LDA MPTMPD + 2
 SBCIM  0
 STA MPTMPD + 2
 BCC DAGFD ; WHEN POSITION FOUND
 INY
 JMP DAGLP2
DAGFD CLC ; GET BIT POSITION BACK
 LDA MPTMPD
 ADCIM  8
 STA MPTMPD
 LDA MPTMPD + 1
 ADCIM  0
 STA MPTMPD + 1
 LDA MPTMPD + 2
 ADCIM  0
 STA MPTMPD + 2
 LDA MPTMPD
 STA MPTMPC ; SAVE BIT COUNT
 INC MPTMPC
 LDAIY MPSCPT ; GET CORRECT BYTE
 LDXIM  9
DAGLP3 RORA ; ROTATE TO GET CORRECT POSITION
 DEX
 DEC MPTMPC
 BNE DAGLP3
 PHA ;SAVE VALUE
 TYA
 PHA ; SAVE POSITION
 LDYIM  3
 LDAIY MAPGEN ; GET NUMBER OF BLOCKS TO BE DEALLOCATED
 STA MPTMPC
 INY
 LDAIY MAPGEN
 STA MPTMPC + 1
 PLA ; GET POSITION BACK
 TAY
 PLA
DAGNX SEC ;MARK BLOCK FREE
 RORA
 DEX
 BEQ DAGEOB
 PHP
 PHA ; SAVE VALUE
DAGNX1 SEC
 LDA MPTMPC
 SBCIM  1 ; DECREMENT COUNT
 STA MPTMPC
 LDA MPTMPC + 1
 SBCIM  0
 STA MPTMPC + 1
 ORA MPTMPC ; CHECK FOR END
 BEQ DAGSK1
 PLA ; GET VALUE BACK
 PLP
 JMP DAGNX ; DEALLOCATE NEXT BLOCK
DAGEOB STAIY MPSCPT ; SAVE NEW VALUE
 INY
 LDAIY MPSCPT ; GET NEXT VALUE
 RORA ; POSITION CORRECTLY
 PHP
 PHA
 LDXIM  8 ;GIVE X CORRECT VALUE
 JMP DAGNX1
DAGSK1 CPXIM  0
 BEQ DAGSK2 ; BRANCH IF POSITION CORRECT
 PLA ;BLOCKS HAVE BEEN DEALLOCATED SO CORRECT POSITION
 PLP
DAGLP4 RORA
 DEX
 BNE DAGLP4 ; KEEP GOING UNTIL BACK RIGHT
 BEQ DAGSK4
DAGSK2 PLA
 PLP
DAGSK4 STAIY MPSCPT ;SAVE VALUE
 LDA MPSCPT
 STA CBSTA
 LDA MPSCPT + 1
 STA CBSTA + 1
 JSR MBMWT
 LDYIM  3 ; NOW CORRECT FREE BLOCK COUNT
 LDAIY MAPGEN
 STA MPTMPC
 INY
 LDAIY MAPGEN
 STA MPTMPC + 1
 LDYIM  0
 CLC ; NOW ADD TO FREE BLOCK COUNT
 LDA MPTMPC
 ADCIY MPCYPT
 STAIY MPCYPT
 INY
 LDA MPTMPC + 1
 ADCIY MPCYPT
 STAIY MPCYPT
 INY
 LDAIM  0
 ADCIY MPCYPT
 STAIY MPCYPT
 CLC ; NOW GET POSITION IN CYCLINDER MAP
 LDAIM  3
 ADC MPCYPT
 STA MPSCPT
 LDAIM  0
 ADC MPCYPT + 1
 STA MPSCPT + 1
DAGLP5 LDA MAPTMP
 ORA MAPTMP + 1 ; HAVE WE GOT THERE ?
 BEQ DAGSK3
 CLC ; MOVE TO NEXT ENTRY
 LDA MPSCPT
 ADCIM  2
 STA MPSCPT
 LDA MPSCPT + 1
 ADCIM  0
 STA MPSCPT + 1
 SEC ; DECREMENT CYLINDER COUNT
 LDA MAPTMP
 SBCIM  1
 STA MAPTMP
 LDA MAPTMP + 1
 SBCIM  0
 STA MAPTMP + 1
 JMP DAGLP5
DAGSK3 CLC ; NOW DO THE ADD
 LDYIM  0
 LDAIY MPSCPT
 ADC MPTMPC
 STAIY MPSCPT
 INY
 LDAIY MPSCPT
 ADC MPTMPC + 1
 STAIY MPSCPT
 LDA MAPGEN ; RESTORE SOME VALUES
 STA MPSCPT
 LDA MAPGEN + 1
 STA MPSCPT + 1
 LDYIM  0
 LDAIM  0
 LDXIM  5
DAGZLP STAIY MPSCPT
 INY
 DEX
 BNE DAGZLP
 PLA
 STA MAPTMP + 1
 STA CBSTA + 1
 PLA
 STA MAPTMP
 STA CBSTA
 JMP MMBWT

CLRBLK
;   DEALLOCATES ALL BLOCKS FROM A GIVEN ENTRY.
;   THE ORIGINAL MAP BLOCK WILL BE DELETED IF A FLAG IS SET.
;
; ON ENTRY
;     MPTMPA HOLDS THE SIN OF THE MAP BLOCK
;     MPSCPT HOLDS THE OFFSET IN THE MAP BLOCK
;     MPTMPE IF NON-ZERO IMPLIES MAP BLOCK TO BE DELETED
;
 LDYIM MPCYMP
 LDAIY MAPPTR
 STA MPCYPT
 INY
 LDAIY MAPPTR
 STA MPCYPT + 1
 CLC
 JSR RDMPBK ; MAKE SURE MAP BLOCK IS IN STORE
 BEQ CBSK9
 JMP CBSK2
CBSK9 CLC
 LDA MAPTMP ; GET POINTER TO MAP BLOCK
 STA MPMBPT
 ADC MPSCPT ; GET CURRENT POSITION
 STA MPSCPT
 LDA MAPTMP + 1
 STA MPMBPT + 1
 ADC MPSCPT + 1
 STA MPSCPT + 1
CBLP1 LDYIM  0 ; CHECK IF END OF BLOCK
 LDAIY MPSCPT
 INY
 ORAIY MPSCPT
 INY
 ORAIY MPSCPT
 BNE CBSSK1 ; END OF MAP BLOCK REACHED
 JMP CBCNT
CBSSK1 CLC
 LDA MPMBPT
 ADCIM LSTENT
 TAX
 LDA MPMBPT + 1
 ADCIM /(LSTENT)
 CPX MPSCPT ; CHECK FOR LAST ENTRY
 BNE CBDA1
 CMP MPSCPT + 1
 BNE CBDA1
 LDYIM  0 ; GET NEW SIN
 LDAIY MPSCPT
 STA MPTMPB
 INY
 LDAIY MPSCPT
 STA MPTMPB + 1
 INY
 LDAIY MPSCPT
 STA MPTMPB + 2

 LDYIM 4
 LDAIM 0
CBSSJ STAIY MPSCPT ;clear out this pointer
 DEY
 BPL CBSSJ ;**14/9/84**
 LDA MPTMPE
 BEQ CBSSK
 LDA DNDLTE
 BNE CBSSK
 JSR DAMPBK ; DEALLOCATE THE MAP BLOCK IF NEEDED
CBSSK LDAIM  0
 STA DNDLTE
 LDAIM  1
 STA MPTMPE
 LDA MPTMPB
 STA MPTMPA
 LDA MPTMPB + 1
 STA MPTMPA + 1
 LDA MPTMPB + 2
 STA MPTMPA + 2
 CLC
 JSR RDMPBK ; READ IN NEW MAP BLOCK
 CLC
 LDA MAPTMP ;TRANSFER POINTER
 STA MPMBPT
 ADCIM MBENTS ; GET TO POINT TO START OF ENTRIES
 STA MPSCPT
 LDA MAPTMP + 1
 STA MPMBPT + 1
 ADCIM /(MBENTS )
 STA MPSCPT + 1
CBDA1 JSR DAGRP
 LDA SAVSC
 BNE CBNDL
 INC SAVSC
 JSR ENSMB
 JSR ULBM
CBNDL CLC ; MOVE TO NEXT ENTRY
 LDA MPSCPT
 ADCIM ENSZ
 STA MPSCPT
 LDA MPSCPT + 1
 ADCIM /(ENSZ )
 STA MPSCPT + 1
 JMP CBLP1
CBCNT LDA MPTMPE
 BEQ CBSK2
 LDA DNDLTE
 BNE CBSK2
 JSR DAMPBK
CBSK2 RTS

 LNK UADE13
: