 OPT UADE12 ;> Uade12
 TTL File server file UADE12

;** MAPMAP UTILS II(2) **

;SET POINTER TO ENTRY IN MAP TABLE
;CORRESPONDING TO DRIVE IN CURDRV.
;POINTER IN BOTH MAPPTR AND MAPENT.

SMPPTR ROUT
 LDX CURDRV
 LDA MAPTB
 STA MAPPTR
 LDA MAPTB+1
 STA MAPPTR+1
10 DEX
 BMI #20
 JSR MPADMP
 JMP #10

20 LDA MAPPTR
 STA MAPENT
 LDA MAPPTR+1
 STA MAPENT+1
 RTS

;RDDATA: READ DISC INFO FROM SECTOR 0 INTO
;STORE STARTING AT ADDRESS IN FREPTR.

;ENTRY: A = DRIVE NO.

;EXIT:  A = RC

;FUNCTION: -
;0) SET FDRIVE, OLDFDR & SELECT & START DRIVE
;1) SEEK TRACK ZERO
;2) READ SECTOR 0

;RDSTWO ENTRY POINT FOR USE WHEN
;DDRSTA POINTER ALREADY SET UP.

RDDATA ROUT
 LDY FREPTR
 STY DSCCB+TRADD
 LDY FREPTR+1
 STY DSCCB+TRADD+1 ;DDRSTA:=STORE ADDR FOR SECTOR
 LDYIM 0
 STY DSCCB
 STY DSCCB+TRADD+2
 STY DSCCB+TRADD+3


 [ WINCH=0
RDSTWO STA Drivno
 LDXIM Length+3-Cmd
 LDAIM 0
00 STAAX Dsccb+Cmd ;Zero part of disc CB ** 27/9/86 **
 DEX
 BPL #00
 LDA Drivno
 LSRA
 RORA
 RORA
 RORA
 STA DSCCB+CMD+1
 LDAIM &08
 STA DSCCB+CMD
 LDA DSCCB+TRADD
 STA MPCYPT
 LDA DSCCB+TRADD+1
 STA MPCYPT+1
 LDAIM 0
 STA RBDA ;Sector zero
 INC DSCCB+LENGTH+1 ;All was zero
10 JSR DSCCMD
 BNE #20
 LDYIM SZOFF
 LDAIY MPCYPT
 STA DSCCB+CMD+3
 INY
 LDAIY MPCYPT
 STA DSCCB+CMD+2
 INY
 LDA DRIVNO
 LSRA
 RORA
 RORA
 RORA
 ORAIY MPCYPT
 STA DSCCB+CMD+1
 JSR DSCCMD
 BEQ #30
20 LDY Dsccb ;Bad drive? **27/9/86 **
 CPYIM &65
 BEQ #30 ;Don't bother with alternate
 LDY RBDA
 BNE #30
 INC RBDA
 INC DSCCB+CMD+3
 BNE #10

30 TAX ;Set CC
 RTS
 |
RDSTWO STA DSCCB ;SET DRIVE NUMBER

 STA DSCCB+PARAMS ;TRACK ZERO
 LDAIM  2 ;SECTOR TWO
 STA DSCCB+PARAMS+ 1 ;SECTOR TWO
 LDAIM  3 ;NUMBER OF PARAMETERS
 STA DSCCB+NOPRMS
 LDAIM &21 ; ONE SECTOR
 STA DSCCB+PARAMS+ 2
 LDAIM &53 ;FOR READ
 STA DSCCB+CMD

 JSR DSCCMD

 RTS
 ]

;
; MAKE AN ENTRY IN THE MAP BLOCK
;
; ON ENTRY
;   MKENVA HOLD THE NUMBER OF BLOCKS TO ALLOCATE
;   MAPTMP POINT TO THE MAP BLOCK
;   MPTMPC points to allocation cylinder number
;
; ON EXIT
;   C SET IF FAILED
;
; USES : MAPGEN, MPTMPA, MPTMPB, MPTMPC, MPTMPE
;
MKEN ROUT
 LDYIM MPSPCY
 LDAIY MAPPTR
 STA TMPSPC
 INY
 LDAIY MAPPTR
 STA TMPSPC+1
 LDA MAPGEN
 PHA
 LDA MAPGEN+1
 PHA
 LDA MAPTMP ;GET POINTER TO MAP BLOCK
 STA MAPGEN
 LDA MAPTMP+1
 STA MAPGEN+1
 JSR GETPOS ;GET NEXT FREE POSITION IN MAP BLOCK
 BCS #10 ;BRANCH IF ROOM
 JMP #30
10 LDYIM MPCYMP ;GET ADDRESS OF CYLINDER MAP
 LDAIY MAPPTR
 STA MAPGEN
 INY
 LDAIY MAPPTR
 STA MAPGEN+1
 SEC
 LDYIM 0 ;CHECK IF ROOM FOR ANOTHER BLOCK
 LDAIY MAPGEN
 SBCIM 1
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 SBCIM 0
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 SBCIM 0
 STAIY MAPGEN
 BCC #15
 LDA MAPTMP
 STA MPMBPT
 STA CBSTA
 LDA MAPTMP+1
 STA MPMBPT+1
 STA CBSTA+1
 JSR MMBLKD
 JSR GTCYPS ;get closest cylinder block
 LDA MAPGEN
 STA MPTMPB
 LDA MAPGEN+1
 STA MPTMPB+1
 LDA MPTMPE
 STA MPTMPC ;NEW CYLINDER COUNT
 LDA MPTMPE+1
 STA MPTMPC+1
 JSR RDBTMP
 BNE #12 ;**23/2/87** Failed
 JSR ALBLK ;GET NEW MAP BLOCK
 SEC
 JSR RDMPBK ;GET AREA OF STORE FOR IT
 LDA ERRTYP
 BEQ #20
12 JSR ULMB
15 JMP #90

20 CLC
 LDA MPMBPT ;GET POINTER TO OLD MAP BLOCK
 STA CBSTA
 ADCIM :LSB:LSTENT ;POINT TO LAST ENTRY
 STA MPMBPT
 LDA MPMBPT+1
 STA CBSTA+1
 ADCIM :MSB:LSTENT
 STA MPMBPT+1
 LDYIM 0 ;SAVE SIN OF NEW MAP BLOCK
 LDA MPTMPA
 STAIY MPMBPT
 INY
 LDA MPTMPA+1
 STAIY MPMBPT
 INY
 LDA MPTMPA+2
 STAIY MPMBPT
 INY ;NOW SAVE LENGTH
 LDAIM 1
 STAIY MPMBPT
 INY
 LDAIM 0
 STAIY MPMBPT
 JSR MMBWT
 JSR ULMB
 CLC
 LDYIM MPCYMP ;GET ADDRESS OF CYLINDER MAP
 LDAIY MAPPTR
 STA MAPGEN
 ADCIM 3 ;POINT TO START OF ENTRIES
 STA MPTMPB
 INY
 LDAIY MAPPTR
 STA MAPGEN+1
 ADCIM 0
 STA MPTMPB+1
 JSR GTCYPS
 LDA MAPGEN
 STA MPCYPT
 LDA MAPGEN+1
 STA MPCYPT+1
 LDA MPTMPE
 STA MPTMPC
 LDA MPTMPE+1
 STA MPTMPC+1
 JSR RDBTMP
 BNE #12 ;**23/12/87** Failed
 LDA MAPTMP
 STA MAPGEN ;SAVE ADDRESS OF NEW MAP BLOCK
 LDA MAPTMP+1
 STA MAPGEN+1
 JSR SIZE
 LDA MPTMPD ;number of contiguous blocks
 CMP MKENVA
 LDA MPTMPD+1
 SBC MKENVA+1
 BCS #25
 LDA MPTMPD
 STA MKENVA
 LDA MPTMPD+1
 STA MKENVA+1
25 JSR GETPOS ;GET FREE POSITION IN MAP BLOCK
30 LDAIM 0
 STA MPTMPE
 STA MPTMPE+1 ;ZERO VARIABLES
 STA MPTMPE+2
 TAY
35 LDAIY MPSCPT ;LOOK FOR BLOCKS TO ALLOCATE
 BEQ #45 ;NOT FOUND
 LDXIM 8
40 RORA
 BCS #50
 DEX
 INC MPTMPE ;STILL NOT FOUND
 BNE #40
 INC MPTMPE+1
 JMP #40 ;CHECK NEXT ONE

45 CLC ;NEXT BYTE SO ADD 8
 LDA MPTMPE
 ADCIM 8
 STA MPTMPE
 INY
 BCC #35
 INC MPTMPE+1
 CLC ;**1/7/88**
 BCC #35

50 PHA
 LDA MPTMPE
 ORA MPTMPE+1
 STA MPTMPB+2 ;**23/1/87** Flag for start of cylinder
 LDA MKENVA
 STA MPTMPB
 LDA MKENVA+1
 STA MPTMPB+1
 PLA
55 CLC
 RORA
 PHP
 PHA
 LDA MPTMPB
 BNE #57
 DEC MPTMPB+1
57 DEC MPTMPB
 LDA MPTMPB+1
 ORA MPTMPB
 BEQ #60
 PLA
 PLP
 DEX
 BNE #55
 STAIY MPSCPT
 INY
 LDAIY MPSCPT
 LDXIM 8
 RORA
 JMP #55

60 PLA
 PLP
 DEX
65 RORA
 DEX
 BNE #65
 STAIY MPSCPT
 LDA MPTMPC
 PHA
 LDA MPTMPC+1
 PHA ;SAVE POSITION
70 LDA MPTMPC ;NOW GET DISC ADDRESS
 ORA MPTMPC+1 ;IF ZERO THS IS IT!
 BEQ #80
 CLC
 LDA MPTMPE
 ADC TMPSPC
 STA MPTMPE
 LDA MPTMPE+1
 ADC TMPSPC+1
 STA MPTMPE+1
 BCC #75
 INC MPTMPE+2
75 LDA MPTMPC
 BNE #77
 DEC MPTMPC+1
77 DEC MPTMPC
 JMP #70
 
80 PLA
 STA MPTMPC+1
 PLA
 STA MPTMPC

 [ 1=1 ;Attempt map entry merge *** 27/05/86 ***
 LDA MPTMPB+2 ;**23/1/87** do not merge if start of cylinder
 BEQ #83
 SEC
 LDA MAPGEN ;if (MAPGEN-MAPTMP)=MBENTS ; unless first entry
 SBC MAPTMP
 TAY
 LDA MAPGEN+1
 SBC MAPTMP+1
 BNE #81
 CPYIM MBENTS
 BEQ #83
81 SEC
 LDA MAPGEN ;then $( MAPGEN-:=ENSZ ; previous entry
 PHA
 SBCIM :LSB:ENSZ
 STA MAPGEN
 LDA MAPGEN+1
 PHA
 SBCIM :MSB:ENSZ
 STA MAPGEN+1
 SEC
 LDYIM 0 ;        CBSTA:=MPTMPE-SIN(MAPGEN) ; separation of extents
 LDA MPTMPE
 SBCIY MAPGEN
 STA CBSTA
 INY
 LDA MPTMPE+1
 SBCIY MAPGEN
 STA CBSTA+1
 INY
 LDA MPTMPE+2
 SBCIY MAPGEN
 BNE #82 ;        ; (not too long)
 INY
 LDA CBSTA ;        if (CBSTA=LEN(MAPGEN)) ; do extents abut
 CMPIY MAPGEN
 BNE #82
 INY
 LDA CBSTA+1
 CMPIY MAPGEN
 BNE #82
 DEY
 CLC
 LDA MKENVA ;        then $( LEN(MAPGEN)+:=MKENVA ; yes, extend previous
 ADCIY MAPGEN
 STAIY MAPGEN
 INY
 LDA MKENVA+1
 ADCIY MAPGEN
 STAIY MAPGEN
 PLA
 PLA
 JMP #84 ;                goto #84 $)
        
82 PLA ;        MAPGEN+:=ENSZ ; else separate extents so make new entry
 STA MAPGEN+1
 PLA
 STA MAPGEN
 ]

83 LDYIM 0 ;SAVE THE DISC ADDRESS
 LDA MPTMPE
 STAIY MAPGEN
 INY
 LDA MPTMPE+1
 STAIY MAPGEN
 INY
 LDA MPTMPE+2
 STAIY MAPGEN
 INY
 LDA MKENVA ;SAVE SIZE
 STAIY MAPGEN
 LDA MKENVA+1
 INY
 STAIY MAPGEN
84 LDA MPscor ;**23/1/87**
 STA CBSTA
 LDA MPscor+1
 STA CBSTA+1
 JSR MBMWT ;MARK BIT MAP WRITTEN TO
 LDA MAPTMP
 STA CBSTA
 LDA MAPTMP+1
 STA CBSTA+1
 JSR MMBWT ;MARK MAP BLOCK WRITTEN
 SEC
 LDA DIVTMP
 SBC MKENVA
 STA DIVTMP
 LDA DIVTMP+1
 SBC MKENVA+1
 STA DIVTMP+1
 CLC ;FLAG EVERYTHING OK
85 PLA
 STA MAPGEN+1
 PLA
 STA MAPGEN
 RTS

90 CLC
 LDYIM 0
 LDAIY MAPGEN
 ADCIM 1
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADCIM 0
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADCIM 0
 STAIY MAPGEN
 SEC ;NO GOOD
 BCS #85

;ALLOCATE ONE BLOCK
;
; LOOKS IN CURRENT BIT MAP AND RETURNS THE SIN 
; OF THE FIRST FREE BLOCK
;
; ON ENTRY
;   MPTMPC HOLDS THE CYLINDER NUMBER
;   MPSCPT POINTS TO THE CURRENT BIT MAP
;
; ON EXIT
;   MPTMPA HOLDS THE SIN OF THE ALLOCATED BLOCK
;
; USES : MPCYPT
;
ALBLK ROUT ;ZERO VARIABLES
 LDAIM 0
 STA MPTMPA
 STA MPTMPA+1
 STA MPTMPA+2
 LDA MPSCPT ;COPY POINTER TO USE
 STA MPCYPT
 LDA MPSCPT+1
 STA MPCYPT+1
10 LDYIM 0
 LDAIY MPCYPT ;FIND FREE BLOCK
 BEQ #30
20 RORA ;NOW FIND THE SECTOR
 BCS #50 ;FOUND WHEN C SET
 INC MPTMPA ;KEEP LOOKING
 BNE #20
 INC MPTMPA+1
 JMP #20

30 CLC
 LDA MPTMPA ;MOVE TO NEXT BYTE
 ADCIM 8
 STA MPTMPA
 BCC #35
 INC MPTMPA+1
35 INC MPCYPT
 BNE #10
 INC MPCYPT+1
 JMP #10

50 PHA ;SAVE TO MARK AS ALLOCATED
 LDA MPTMPA
 ANDIM 7
 TAX
 INX
 PLA
 CLC
60 ROLA
 DEX
 BNE #60
 STAIY MPCYPT ;BLOCK MARKED ALLOCATED
 LDA MPTMPC
 STA MAPTMP
 LDA MPTMPC+1
 STA MAPTMP+1
70 LDA MAPTMP
 ORA MAPTMP+1
 BEQ #80 ;GET DISC ADDRESS
 LDYIM MPSPCY
 CLC
 LDA MPTMPA
 ADCIY MAPPTR
 STA MPTMPA
 INY
 LDA MPTMPA+1
 ADCIY MAPPTR
 STA MPTMPA+1
 BCC #75
 INC MPTMPA+2
75 LDA MAPTMP ;DECREMENT CYLINDER COUNT
 BNE #77
 DEC MAPTMP+1
77 DEC MAPTMP
 JMP #70

80 LDA MPTMPB ;GET POINTER TO CYLINDER MAP
 STA MPCYPT
 LDA MPTMPB+1
 STA MPCYPT+1
 LDYIM 0 ;DECREMENT FREE COUNT
 SEC
 LDAIY MPCYPT
 SBCIM 1
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 SBCIM 0
 STAIY MPCYPT
 LDYIM MPCYMP
 LDAIY MAPPTR
 STA MPCYPT
 INY
 LDAIY MAPPTR
 STA MPCYPT+1
 LDA MPscor ;**23/1/87**
 STA CBSTA
 LDA MPscor+1
 STA CBSTA+1
 JSR MBMWT ;MARK BIT MAP WRITTEN
 LDA MPTMPA
 ORA MPTMPA+1
 ORA MPTMPA+2
 BNE #90
 LDAIM &FC
 JSR INTERR
90 RTS

; ALLOCATE A SERIES OF BLOCKS
;
; ON ENTRY
;   MPCYPT POINTS TO POSITION IN CYLINDER MAP
;   DIVTMP HOLDS NUMBER OF SECTORS REQUIRED
;   MPSCPT POINTS TO BIT MAP
;   MAPPTR POINTS TO MAP TABLE
;   MAPTMP POINTS TO MAP BLOCK
;   MPTMPC HOLDS CYLINDER NUMBER
;
; ON EXIT
;   DIVTMP HOLDS NUMBER OF BLOCKS LEFT
;   C SET IF FAILED
;
; USES : MAPGEN
;
ABLKS ROUT
 LDYIM MPCYMP
 LDAIY MAPPTR ;GET POINTER TO START OF CYLINDER MAP
 STA MAPGEN
 INY
 LDAIY MAPPTR
 STA MAPGEN+1
 JSR SIZE ;GET SIZE OF THIS BLOCK
 LDA MPTMPD ;MPTMPD HAS SIZE
 TAX ;**1/7/88**
 CMP DIVTMP ;SEE IF WE NEED THEM ALL
 LDA MPTMPD+1
 TAY
 SBC DIVTMP+1
 BCC #10
 LDA DIVTMP+2
 BNE #10 ;ABSALL ALLOCATES ALL BLOCKS
 LDX DIVTMP
 LDY DIVTMP+1
10 STX MKENVA ;MAKE ENTRY IN MAP BLOCK
 STY MKENVA+1
 JSR MKEN
 BCS #30 ;ALL DONE SO FINISH
 LDA ERRTYP
 BNE #30
 LDYIM 0
 SEC
 LDAIY MPCYPT
 SBC MKENVA
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 SBC MKENVA+1
 STAIY MPCYPT
 CMPIM &FF
 BNE #20
 DEY
 LDAIY MPCYPT
 CMPIM &FF
 BNE #20
 LDAIM &FA
 JSR INTERR
20 CLC
 RTS

30 JSR DAGRP ;NOT ABLE TO MAKE ENTRY
 LDYIM 0
 CLC
 LDAIY MAPGEN ;INCREASE FREE COUNT
 ADC MKENVA
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADC MKENVA+1
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADCIM 0
 STAIY MAPGEN
 SEC ;TO INDICATE FAILURE
 RTS


; DEALLOCATE MAP BLOCK
;
;   DEALLOCATES THE SPECIFIED MAP BLOCK. OVERWRITES THE SEQUENCE NUBERS
;   SO THAT IT WILL NO LONGER APPEAR AS A MAP BLOCK
;
; ON ENTRY
;   MPTMPA HOLDS THE SIN OF THE MAP BLOCK
;   MPCYPT POINTS TO THE CYLINDER MAP
;
; USES : MPTMPA,MPTMPD,MPTMPC,MPSCPT
;
DAMPBK ROUT
 LDYIM MPSPCY
 LDAIY MAPPTR
 STA TMPSPC
 INY
 LDAIY MAPPTR
 STA TMPSPC+1
 LDA MPTMPA ;DEALLOCATE MAP BLOCK
 STA CBSIN
 LDA MPTMPA+1
 STA CBSIN+1
 LDA MPTMPA+2
 STA CBSIN+2
 JSR FNDMB ; GNCBPT POINTS TO CURRENT ENTRY
 LDYIM CBSA
 LDAIY GNCBPT
 STA MPSCPT ;SAVE POINTER TO MAP BLOCK
 STA CBSTA
 INY
 LDAIY GNCBPT
 STA MPSCPT+1
 STA CBSTA+1
 LDYIM MBSQNO
 LDAIM &FF
 STAIY MPSCPT ;SAVE INVALID SQ.NO.
 CLC
 LDA MPSCPT
 ADCIM :LSB:LSTSQ
 STA MPSCPT
 LDA MPSCPT+1
 ADCIM :MSB:LSTSQ
 STA MPSCPT+1
 LDAIM 0
 TAY
 STAIY MPSCPT
 JSR MMBWT
 LDAIM 0
 STA MPTMPC ; ZERO VARIABLES
 STA MPTMPC+1
10 SEC
 LDA MPTMPA
 SBC TMPSPC ; FIND CYLINDER NUMBER
 STA MPTMPA
 LDA MPTMPA+1
 SBC TMPSPC+1
 STA MPTMPA+1
 LDA MPTMPA+2
 SBCIM 0
 STA MPTMPA+2
 BCC #20 ; CYLINDER FOUND
 INC MPTMPC ;INCREMENT CYLINDER COUNT
 BNE #10
 INC MPTMPC+1
 JMP #10

20 JSR RDBTMP ; GET THE RELEVANT BIT MAP TO STORE
 CLC
 LDA MPTMPA ; GET WHICH BLOCK OF THIS CYLINDER
 ADC TMPSPC
 STA MPTMPA
 LDA MPTMPA+1
 ADC TMPSPC+1
 STA MPTMPA+1
 BCC #25
 INC MPTMPA+2
25 LDYIM 0
30 SEC ;GET POSITION IN BIT MAP
 LDA MPTMPA
 SBCIM 8
 STA MPTMPA
 LDA MPTMPA+1
 SBCIM 0
 STA MPTMPA+1
 BCC #40 ; POSITION FOUND IF BRANCH
 INY
 JMP #30

40 CLC
 LDA MPTMPA ; GET OLD POSITION BACK
 ADCIM 8
 STA MPTMPA
 BCC #45
 INC MPTMPA+1
45 LDX MPTMPA
 INX
 LDAIY MPSCPT ; X HOLDS POSITION IN BYTE A HOLDS THE BYTE
50 RORA ;MOVE TO CORRECT POSITION
 DEX
 BNE #50
 SEC
 LDX MPTMPA ;BLOCK IS FLAGGED FREE AND X HOLDS NUMBER OF SHIFTS
 INX
60 ROLA ; UNTIL BACK TO CORRECT POSITION
 DEX
 BNE #60
 STAIY MPSCPT ; SAVE FLAGS
 CLC
 LDA MPCYPT ;NOW MAKE COUNTS CORRECT
 ADCIM 3
 STA MAPGEN
 LDA MPCYPT+1
 ADCIM 0
 STA MAPGEN+1
 LDA MPTMPC
 STA MPTMPE
 LDA MPTMPC+1
 STA MPTMPE+1
70 LDA MPTMPE
 ORA MPTMPE+1
 BEQ #80
 CLC
 LDA MAPGEN
 ADCIM 2
 STA MAPGEN
 BCC #75
 INC MAPGEN+1
75 LDA MPTMPE
 BNE #77
 DEC MPTMPE+1
77 DEC MPTMPE
 JMP #70

80 LDYIM 0
 CLC
 LDAIY MAPGEN ;INCREMENT FREE BLOCK COUNT
 ADCIM 1
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADCIM 0
 STAIY MAPGEN
 LDYIM 0
 CLC
 LDAIY MPCYPT
 ADCIM 1
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 ADCIM 0
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 ADCIM 0
 STAIY MPCYPT
 LDA MPscor ;**23/1/87**
 STA CBSTA
 LDA MPscor+1
 STA CBSTA+1
 JMP MBMWT ; NOW FINISHED
;
; DALLOCATE A GROUP OF BLOCKS
; MARKS THE ENTRIES IN THE SPECIFIED BIT MAP FREE AND INCREASES THE FREE BLOCK COUNT
;
; ON ENTRY
;     MPSCPT POINTS TO RELEVANT ENTRY IN MAP BLOCK
;     MPCYPT POINTS TO CYLINDER MAP
;     MAPTMP POINTS TO MAP BLOCK
;
; USES MPTMPC,MAPGEN,MPTMPD,MAPTMP
;
DAGRP ROUT
 LDA MAPTMP
 PHA
 LDA MAPTMP+1
 PHA
 LDAIM 0
 STA MPTMPC ; ZERO VALUES
 STA MPTMPC+1
 LDYIM 0
 LDAIY MPSCPT ; GET SIN
 STA MPTMPD
 INY
 LDAIY MPSCPT
 STA MPTMPD+1
 INY
 LDAIY MPSCPT
 STA MPTMPD+2
 LDA MPSCPT ; SAVE MAP BLOCK POINTER
 STA MAPGEN
 LDA MPSCPT+1
 STA MAPGEN+1

05 LDYIM MPSPCY
 SEC ; NOW FIND CYLINDER
 LDA MPTMPD
 SBCIY MAPPTR
 STA MPTMPD
 INY
 LDA MPTMPD+1
 SBCIY MAPPTR
 STA MPTMPD+1
 LDA MPTMPD+2
 SBCIM 0
 STA MPTMPD+2
 BCC #10 ; END FOUND
 INC MPTMPC ; COUNT TO NEXT CYLINDER
 BNE #05
 INC MPTMPC+1
 JMP #05

10 LDYIM MPSPCY
 CLC
 LDA MPTMPD ; RESTORE BLOCK COUNT
 ADCIY MAPPTR
 STA MPTMPD
 INY
 LDA MPTMPD+1
 ADCIY MAPPTR
 STA MPTMPD+1
 BCC #12
 INC MPTMPD+2
12 LDA MPTMPC ; SAVE CYLINDER NUMBER
 STA MAPTMP
 LDA MPTMPC+1
 STA MAPTMP+1
 JSR RDBTMP
 LDYIM 0
15 SEC ; GET POSITION IN BIT MAP
 LDA MPTMPD
 SBCIM 8
 STA MPTMPD
 LDA MPTMPD+1
 SBCIM 0
 STA MPTMPD+1
 LDA MPTMPD+2
 SBCIM 0
 STA MPTMPD+2
 BCC #20 ; WHEN POSITION FOUND
 INY
 JMP #15

20 CLC ; GET BIT POSITION BACK
 LDA MPTMPD
 ADCIM 8
 STA MPTMPD
 BCC #22
 INC MPTMPD+1
 BNE #22
 INC MPTMPD+2
22 LDA MPTMPD
 STA MPTMPC ; SAVE BIT COUNT
 INC MPTMPC 
 LDAIY MPSCPT ; GET CORRECT BYTE
 LDXIM 9
25 RORA ; ROTATE TO GET CORRECT POSITION
 DEX
 DEC MPTMPC
 BNE #25
 PHA ;SAVE VALUE
 TYA
 PHA ;SAVE POSITION
 LDYIM 3
 LDAIY MAPGEN ; GET NUMBER OF BLOCKS TO BE DEALLOCATED
 STA MPTMPC
 INY
 LDAIY MAPGEN
 STA MPTMPC+1
 PLA ; GET POSITION BACK
 TAY
 PLA
30 SEC ;MARK BLOCK FREE
 RORA
 DEX
 BEQ #40
 PHP
 PHA ; SAVE VALUE
35 LDA MPTMPC ; DECREMENT COUNT
 BNE #37
 DEC MPTMPC+1
37 DEC MPTMPC
 LDA MPTMPC+1
 ORA MPTMPC ; CHECK FOR END
 BEQ #45
 PLA ; GET VALUE BACK
 PLP
 JMP #30 ; DEALLOCATE NEXT BLOCK

40 STAIY MPSCPT ; SAVE NEW VALUE
 INY
 LDAIY MPSCPT ; GET NEXT VALUE
 RORA ; POSITION CORRECTLY
 PHP
 PHA
 LDXIM 8 ;GIVE X CORRECT VALUE
 BNE #35

45 CPXIM 0
 BEQ #55 ; BRANCH IF POSITION CORRECT
 PLA ;BLOCKS HAVE BEEN DEALLOCATED SO CORRECT POSITION
 PLP
50 RORA
 DEX
 BNE #50 ; KEEP GOING UNTIL BACK RIGHT
 BEQ #60

55 PLA
 PLP
60 STAIY MPSCPT ;SAVE VALUE
 LDA MPscor ;**23/1/87**
 STA CBSTA
 LDA MPscor+1
 STA CBSTA+1
 JSR MBMWT
 LDYIM 3 ; NOW CORRECT FREE BLOCK COUNT
 LDAIY MAPGEN
 STA MPTMPC
 INY
 LDAIY MAPGEN
 STA MPTMPC+1
 LDYIM 0
 CLC ; NOW ADD TO FREE BLOCK COUNT
 LDA MPTMPC
 ADCIY MPCYPT
 STAIY MPCYPT
 INY
 LDA MPTMPC+1
 ADCIY MPCYPT
 STAIY MPCYPT
 INY
 LDAIM 0
 ADCIY MPCYPT
 STAIY MPCYPT
 CLC ;NOW GET POSITION IN CYLINDER MAP
 LDAIM 3
 ADC MPCYPT
 STA MPSCPT
 LDAIM 0
 ADC MPCYPT+1
 STA MPSCPT+1
65 LDA MAPTMP
 ORA MAPTMP+1 ; HAVE WE GOT THERE ?
 BEQ #70
 CLC ; MOVE TO NEXT ENTRY
 LDA MPSCPT
 ADCIM 2
 STA MPSCPT
 BCC #67
 INC MPSCPT+1
67 LDA MAPTMP ; DECREMENT CYLINDER COUNT
 BNE #68
 DEC MAPTMP+1
68 DEC MAPTMP
 JMP #65

70 CLC ; NOW DO THE ADD
 LDYIM 0
 LDAIY MPSCPT
 ADC MPTMPC
 STAIY MPSCPT
 INY
 LDAIY MPSCPT
 ADC MPTMPC+1
 STAIY MPSCPT
 LDA MAPGEN ; RESTORE SOME VALUES
 STA MPSCPT
 LDA MAPGEN+1
 STA MPSCPT+1
 LDYIM 0
 TYA
 LDXIM 5
75 STAIY MPSCPT
 INY
 DEX
 BNE #75
 PLA
 STA MAPTMP+1
 STA CBSTA+1
 PLA
 STA MAPTMP
 STA CBSTA
 JMP MMBWT

;CLRBLK
;   DEALLOCATES ALL BLOCKS FROM A GIVEN ENTRY.
;   THE ORIGINAL MAP BLOCK WILL BE DELETED IF A FLAG IS SET.
;
; ON ENTRY
;   MPTMPA HOLDS THE SIN OF THE MAP BLOCK
;   MPSCPT HOLDS THE OFFSET IN THE MAP BLOCK
;   MPTMPE IF NON-ZERO IMPLIES MAP BLOCK TO BE DELETED
;

CLRBLK ROUT
 LDYIM MPCYMP
 LDAIY MAPPTR
 STA MPCYPT
 INY
 LDAIY MAPPTR
 STA MPCYPT+1
 CLC
 JSR RDMPBK ; MAKE SURE MAP BLOCK IS IN STORE
 BNE #20
 CLC
 LDA MAPTMP ; GET POINTER TO MAP BLOCK
 STA MPMBPT
 ADC MPSCPT ; GET CURRENT POSITION
 STA MPSCPT
 LDA MAPTMP+1
 STA MPMBPT+1
 ADC MPSCPT+1
 STA MPSCPT+1
10 LDYIM 0 ; CHECK IF END OF BLOCK
 LDAIY MPSCPT
 INY
 ORAIY MPSCPT
 INY
 ORAIY MPSCPT
 BNE #30 ; END OF MAP BLOCK REACHED
15 LDA MPTMPE
 BEQ #20
 LDA DNDLTE
 BNE #20
 JSR DAMPBK
20 RTS

30 CLC
 LDA MPMBPT
 ADCIM :LSB:LSTENT
 TAX
 LDA MPMBPT+1
 ADCIM :MSB:LSTENT
 CPX MPSCPT ; CHECK FOR LAST ENTRY
 BNE #60
 CMP MPSCPT+1
 BNE #60
 LDYIM 0 ; GET NEW SIN
 LDAIY MPSCPT
 STA MPTMPB
 INY
 LDAIY MPSCPT
 STA MPTMPB+1
 INY
 LDAIY MPSCPT
 STA MPTMPB+2

 LDYIM 4
 LDAIM 0
40 STAIY MPSCPT ;clear out this pointer
 DEY
 BPL #40 ;**14/9/84**
 JSR MMBWT ;**8/5/87** mark block written to

 JSR #15 ; CHECK IF THIS BLOCK TO BE DELETED
 LDAIM 0
 STA DNDLTE
 LDAIM 1
 STA MPTMPE
 LDA MPTMPB
 STA MPTMPA
 LDA MPTMPB+1
 STA MPTMPA+1
 LDA MPTMPB+2
 STA MPTMPA+2
 CLC
 JSR RDMPBK ; READ IN NEW MAP BLOCK
 CLC
 LDA MAPTMP ;TRANSFER POINTER
 STA MPMBPT
 ADCIM :LSB:MBENTS ; GET TO POINT TO START OF ENTRIES
 STA MPSCPT
 LDA MAPTMP+1
 STA MPMBPT+1
 ADCIM :MSB:MBENTS
 STA MPSCPT+1
60 JSR DAGRP
 LDA SAVSC
 BNE #70
 INC SAVSC
 JSR ENSMB
 JSR ULBM
70 CLC ; MOVE TO NEXT ENTRY
 LDA MPSCPT
 ADCIM :LSB:ENSZ
 STA MPSCPT
 LDA MPSCPT+1
 ADCIM :MSB:ENSZ
 STA MPSCPT+1
 JMP #10

 LNK UADE13
