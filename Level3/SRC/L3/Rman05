 OPT RMAN05 ;RNDMAN > Rman05
 TTL File server file RMAN05


;** RNDMAN UTILS **

;*** GETRND ***

;Get free slot in RANDTB.

;Exit: A = RC
;RTEPTR = Ptr to free RANDTB entry

GETRND LDA RANDTB ;RTEPTR := RANDTB
 STA RTEPTR
 LDA RANDTB + 1
 STA RTEPTR + 1

 LDX RTNENT ;X := no. of entries in RANDTB
 LDYIM RTINUS ;Y := offset of "in use" byte in entry

GETRNB LDAIY RTEPTR ;Get an "in use" byte
 BEQ GETRNA ;Free entry found

 CLC  ;RTEPTR +:= entry size
 LDAIM RTENSZ
 ADC RTEPTR ;LS byte
 STA RTEPTR
 LDAIM  0
 ADC RTEPTR + 1
 STA RTEPTR + 1 ;MS byte

 DEX  ;Any entries left?
 BNE GETRNB ;Jump if yes

;No entries left

 LDAIM RDERRG ;"RANDTB full"
 RTS

;Free entry found.
;Y contains offset of its "in use" byte in RANDTB

GETRNA
 [ 1=0 ; A USELESS BIT OF CODE *** LH 15/12/85 ***
 TYA
 SEC
 SBCIM RTINUS ;Y := offset of ENTRY in RANDTB
 TAY

 CLC  ;RTEPTR := address of entry
 ADC RTEPTR
 STA RTEPTR
 LDA RTEPTR + 1
 ADCIM  0
 STA RTEPTR + 1
 LDAIM 0
 RTS
 |
 LDAIM  0 ;Set RC THIS IS ALL IT DOES LH
 TAY
 RTS
 ]


;*** RDCKAC ***

;Check that the requested access to a file is allowed.
;Check first that the access is allowed in
;the directory entry, and secondly that it can
;be granted within a multiple reader / single
;writer regime (by scanning HANDTB).

;Entry: ARGD (on ARGPTR) = requested access
;ARGE = allowed access (from directory entry)
;RNDPTR points to object details

;Exit:  A = RC
;HNDPTR is corrupted

RDCKAC LDYIM ARGD
 LDAIY ARGPTR ;Get requested access
 ANDIM RDWRAC ;Mask out type bit
 STA RNDTMP ;Keep masked copy
 INY
 ANDIY ARGPTR ;AND with allowed access
 CMP RNDTMP ;Should equal requested access
 BEQ RDCKAD ;Access allowed

 LDAIM RDERRK ;"Access not allowed"
 RTS

RDCKAD JSR INITHD ;HNDPTR := HANDTB; X := no. of entries

RDCKAB LDYIM HTHAND
 LDAIY HNDPTR ;Is this an empty entry?
 BEQ RDCKAA ;Skip if empty

;A used HANDTB entry: check disc no. and SIN
;against those of file we want to open.

 LDYIM INFDIS ;Compare disc numbers
 LDAIY RNDPTR
 LDYIM HTDISC
 CMPIY HNDPTR
 BNE RDCKAA ;LS bytes differ
 LDYIM INFDIS + 1
 LDAIY RNDPTR
 LDYIM HTDISC + 1
 CMPIY HNDPTR
 BNE RDCKAA ;MS bytes differ

 LDYIM INFSIN ;Compare SINs
 LDAIY RNDPTR ;A := LS byte of SIN for OPEN
 LDYIM HTSIN
 CMPIY HNDPTR
 BNE RDCKAA ;LS bytes differ
 LDYIM INFSIN + 1
 LDAIY RNDPTR
 LDYIM HTSIN + 1
 CMPIY HNDPTR
 BNE RDCKAA ;CS bytes differ
 LDYIM INFSIN + 2
 LDAIY RNDPTR
 LDYIM HTSIN + 2
 CMPIY HNDPTR
 BNE RDCKAA ;MS bytes differ

;Have found an existing HANDTB entry for the SIN
;we want to open.
;Open can be permitted only if it is for reading,
;and the file is not already open for writing.

 LDYIM HTMODE
 LDAIY HNDPTR ;A := mode in which already open
 LDYIM ARGD
 ORAIY ARGPTR ;OR requested access with that already granted
 ANDIM WRITAC ;Look at write access bit
 BEQ RDCKAA ;Both for reading - proceed with search

;The file is already open, and:
;either the request includes write access, or the
;file is already open with write access.

 LDAIM RDERRH ;"File in use"
 RTS

;Have not yet found a reason to disallow the
;OPEN. Keep looking!

RDCKAA JSR INCHND ;Point HNDPTR at next entry; X -:= 1
 BNE RDCKAB ;back to start of loop

;Have searched all of HANDTB - open may proceed

 LDAIM  0 ;set RC
 RTS



;*** CLRRTE ***

;Clear entry in RANDTB pointed to by HANDTB entry
;whose address is in HNDPTR.

CLRRTE JSR SETRPT ;RTEPTR := address of RANDTB entry

 LDXIM RTENSZ ;X := size of RANDTB entry
 LDAIM  0
 TAY  ;Set up for clearing loop

CLRRTA STAIY RTEPTR ;Clear whole entry to zero
 INY
 DEX
 BNE CLRRTA ;Loop if more to do

 RTS  ;No result



;*** RDFLSH ***

;Flush all blocks of an object from cache.
;Called from CLRHTE when closing a file.

;Entry: HNDPTR contains address of HANDTB entry

RDFALL LDAIM  5 ;STRMAN.remove all blocks
 BNE RDFLLA ;always taken
;** 5/8/83 **
RDFLSH LDAIM  9 ;STRMAN.FLUSH ALLDIRTYWONDOWS
RDFLLA JSR SETRTN
 JSR RDDSIN ;Put disc and SIN on stack

 JMP STRMAN ;*** Call STRMAN **


;*** RDSHWM ***

;IF seq file ptr > high water mark
;THEN high water mark := seq file ptr

;Entry: RTEPTR points to RANDTB entry

RDSHWM JSR CMPHWP
 BCS RDSHWX ;SFP <= HWM, return

 LDYIM RTCSFP ;SFP > HWM, so copy
 LDAIY RTEPTR ;SFP to HWM field
 LDYIM RTHWM
 STAIY RTEPTR ;LS byte
 LDYIM RTCSFP + 1
 LDAIY RTEPTR
 LDYIM RTHWM + 1
 STAIY RTEPTR ;CS byte
 LDYIM RTCSFP + 2
 LDAIY RTEPTR
 LDYIM RTHWM + 2
 STAIY RTEPTR ;MS byte
RDSHWX RTS


CMPHWP

;Compare High Water Mark with Seq. file
;ptr. and return CC if SFP>HWM, CS if
;SFP<=HWM.
;Also returns Z flag indicating EQ or not.

;NOTE - corrupts RNDTMP

 SEC
 LDYIM RTHWM ;Subtract SFP from HWM
 LDAIY RTEPTR ;LS byte of HWM
 LDYIM RTCSFP
 SBCIY RTEPTR ;Subtract LS bytes
 STA RNDTMP
 LDYIM RTHWM + 1
 LDAIY RTEPTR
 LDYIM RTCSFP + 1
 SBCIY RTEPTR ;Subtract CS bytes
 STA RNDTMP + 1
 LDYIM RTHWM + 2
 LDAIY RTEPTR
 LDYIM RTCSFP + 2
 SBCIY RTEPTR ;Sets carry if SFP <= HWM
 ORA RNDTMP
 ORA RNDTMP + 1 ;Return Z flag indicating EQ or not
 RTS
 LNK UADE0A
