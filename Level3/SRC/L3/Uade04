 OPT UADE04 ; FILE > Uade04
 TTL File server file UADE04


;*********************************
;*   FILE SERVER INITIALISATION  *
;*********************************


INIT LDAIM  7
 LDYIM ARGA
 STAIY NEWARG

 JSR MAPMAN ;MAPMAN.RESTART
 BNE INITY

 LDAIM  4
 LDYIM ARGA
 STAIY NEWARG
 JSR USRMAN ;USRMAN.RESTART
 BNE INITY

 LDAIM  4
 LDYIM ARGA
 STAIY NEWARG

 JSR RNDMAN ;RNDMAN.RESTART
 BNE INITY

 LDXIM &1F
 LDYIM  2
 JSR SETTAB ;Table of qualifiers/directory handles
 STY CDIRTB ;for DOS conversion.
 STX CDIRTB + 1

 LDAIM  6
 LDYIM ARGA
 STAIY NEWARG
 JSR STRMAN ;STRMAN.RESTART
 BNE INITY

 JMP INITZ
INITY PHA
 JSR USRERR
 PLA

INITZ RTS


RSTAUT LDYIM ARGA ;RESART AUTMAN
 LDAIM  6
 STAIY NEWARG
 JSR AUTMAN ;AUTMAN.RESTART
 BNE INITY
 RTS

STRTFS CLD

 JSR MEMTST ;Test memory.
 BEQ ASKDAT ;OK

 JSR VSTRIN
 = "Memory fault found",CR
 = "File Server unable to start",CR
 = "Ended",CR
 NOP

 RTS  ;STOP !!


ASKDAT 
 [ DONGLE=0
 JSR RTC
 BEQ ASKDA
 JSR VSTRIN
 = CR,"Clock Failure",CR
 NOP 
 JMP TSTART ; .. that's all folks ..

 |

 JSR STDATE ;FIND OUT THE DATE if no RTC

 ]
ASKDA JSR RDTIME
 JSR RDDRVS ;HOW MANY DRIVES?



INITCO   ;INITCO

;Main start point of any FS command.
;Resets ENDPTR, FREPTR and re-allocates all tables.
;NOTE !! It is therefore assumed that maps etc.
;have been ensured to disc !!

 LDAIM DYNSTA
 STA FREPTR
 LDAIM /(DYNSTA )
 STA FREPTR + 1 ;FREPTR := DYNSTA

 LDA MEMEND
 STA ENDPTR
 LDA MEMEND + 1
 STA ENDPTR + 1

;GET SOME SPACE FOR THE ARGUMENT STACK AND SETUP ARGPTR

 LDYIM STKSZE
 LDXIM /(STKSZE )
 JSR GETVEC
 STY ARGPTR
 STX ARGPTR + 1

;NOW CLEAR THE ARGUMENT STACK TO ZERO

 STY CLRPTR
 STX CLRPTR + 1 ;CLRPTR:=ADDR OF ARGUMENT STACK
 LDYIM STKSZE
 LDXIM /(STKSZE )
 JSR CLRSTR

 JSR VSTRIN
 = CR,"Command :"
 NOP
 JSR CURSON
 JSR OSECHO
 PHA
 JSR CURSOF
 PLA
 LDXIM  4
INITLA CMPAX FSCTBA
 BEQ INITLB
 DEX
 BPL INITLA

 JSR VSTRIN
 = CR,"S, A, * ONLY"
 NOP
 JMP INITCO

INITLB TXA
 ASLA
 TAX
 LDAAX FSCTBB
 STA TEMPA
 LDAAX FSCTBB + 1
 STA TEMPA + 1
 JMI TEMPA

FSCTBA = "SA*sa"

FSCTBB & STRTUP
 & ASKDAT
 & OSCMD
 & STRTUP
 & ASKDAT

OSCMD JSR RDLINE
 LDXIM 0
 LDYIM 1
 JSR OSCLI
 JMP INITCO

;NORMAL FILE SERVER STARTUP
STRTUP
 JSR RDUSRS
 LDAIM  1
 JSR SETFS
 JSR INIT
 BEQ STRTLA
 JMP INITCO ;Error => do again
STRTLA
 LDXIM DOBRK
 LDYIM /DOBRK
 JSR SETBRK
 JSR RSTAUT ;RESTART AUTMAN
 JMP CMND ;JUMP TO FILE SERVER COMMAND PROCESSOR



RDDRVS JSR VSTRIN ;FINDOUT HOW MANY DRIVES THERE ARE
 = CR,"Number of drives:"
 NOP
 JSR RDLINE
 JSR GETINT ;INTEGR:=NUMBER OF DISCS
 BNE RDDRVS
 LDA INTEGR + 1
 BNE RDDRVS
 LDA INTEGR
 BEQ RDDRVS
 STA DRIVES ;DRIVES:=NUMBER OF DRIVES ATTACHED TO FS
 RTS



STDATE

 [ DONGLE=1 ;ie dongle absent

;If here, no time chip, so prompt for date

NOCHIP JSR VSTRIN ;SETUP THE DATE
 = CR,"Date (DD/MM/YY) = "
 NOP

 JSR RDLINE ;READ A COMPLETE LINE
 JSR GETINT ;GET DAY
STDATC BNE NOCHIP
 LDA INTEGR + 1
 BNE NOCHIP
 LDA INTEGR
 STA DATE ;LS(DATE) := DAY
 LDAIY COMPTR
 CMPIM "/"
STDATB BNE STDATC
 JSR INCCOM ;COMPTR +:=1
 JSR GETINT ;GET MONTH
 BNE STDATB
 LDA INTEGR + 1
 BNE STDATB
 LDA INTEGR
 ANDIM &F0
 BNE NOCHIP
 LDA INTEGR
 ANDIM &F
 STA DATE + 1 ;LS(DATE+01) := MONTH
 LDAIY COMPTR
 CMPIM "/"
 BNE STDATB
 JSR INCCOM ;COMPTR +:=1
 JSR GETINT ;GET YEAR
 BNE STDATB
 LDA INTEGR + 1
STDATH BNE STDATB
 LDA INTEGR

 [ Y2KPAT=1
;Allow entry of years 1997+ 
 CMPIM BASEYR
 BCS STDATD
 ADCIM 100
STDATD
 SEC
 SBCIM BASEYR
 JSR CHKDTF ; Check Year
 |
STDATF BEQ STDATB
 CMPIM THISYR ;current < current year ?
STDATD BCC STDATB
 SEC
 SBCIM BASEYR ;SUBTRACT 81
 JSR SETYR ;Set year nybble
 ]

 LDAIM  0
 STA DATE + 2 ;With no time chip, day = 0
 JSR CHKDTE
 BNE STDATH
 JSR PRDTE
 ]
 RTS

 [ Y2KPAT=1
CHKDTE 
 JMP DTOK ; Abandon date validation
CHKDTF     ; CheckYear
 PHA 
 ASLA 
 ANDIM &E0
 ORA DATE
 STA DATE
 PLA 
 JMP SETYR ;Set year nybble
Y2KP05     ; Out Date
 PHA 
 JSR PRNTDG
 PLA
 RTS
OUTY2K     ; Out Year
 ANDIM &E0
 LSRA 
 ORA Y2KTMP
 ADCIM BASEYR 
 CMPIM 100
 BCC Y2KP20 
 SBCIM 100
Y2KP20 RTS
PUTDAT ANDIM &1F ; Put Date
 JMP OUTDEC
Y2KP25 PHA       ; Put Year
 LDA TDATE
 ANDIM &E0 
 LSRA
 STA Y2KTMP
 PLA
 ADC Y2KTMP
 CMPIM 100 
 BCC Y2KP30
 SBCIM 100
Y2KP30 JMP OUTDEC
 = &00, &00, &00, &00, &00, &00, &00, &00, &00, &00 
 = &00, &00, &00, &00, &00, &00, &00, &00, &00, &00 
 = &00, &00, &00, &00, &00, &00, &00, &00, &00, &00
Y2KTMP = &00
 |
CHKDTE LDA DATE
 STA DAYS
 BEQ CHKDNG
 CMPIM 32
 BCS CHKDNG
 LDA DATE +1
 STA MUNTHS
 ANDIM &F
 BEQ CHKDNG
 CMPIM 13
 BCS CHKDNG
 LDA DATE +1
 LSRA
 LSRA
 LSRA
 LSRA
 CMPIM 29
 BCS CHKDNG
 LDA DATE
 CMPIM 29
 BCC DTOK
 LDA DATE +1
 ANDIM &F
 CMPIM 2
 BEQ CHLPYR
 LDA DATE
 CMPIM 31
 BCC DTOK
 LDXIM 4
 LDA DATE +1
 ANDIM &F
CHDTLP CMPAX MW30D - 1
 BEQ CHKDNG
 DEX
 BNE CHDTLP
 BEQ DTOK
CHLPYR LDA DATE
 CMPIM 30
 BCS CHKDNG
 LDA DATE +1
 LSRA
 LSRA
 LSRA
 LSRA
 ADCIM BASEYR
 ANDIM 3
 BNE CHKDNG
 ]

DTOK LDAIM 0
 RTS
CHKDNG LDAIM 1
 RTS

;PRNTDG: PRINT A DECIMAL NUMBER < 100
;ENTRY A:= NUMBER

PRNTDG LDXIM &FF
 SEC
PRNTGA INX
 SBCIM &0A
 BCS PRNTGA
 ADCIM &0A
 PHA
 TXA  ;OUTPUT TOP DIGIT
 BEQ PRSPC
 JSR OUTDGT
 JMP NXDG
PRSPC LDAIM " "
 JSR OSWRCH
NXDG PLA
OUTDGT CLC
 ADCIM "0" ;CONVERT TO CHAR
 JMP OSWRCH


RDUSRS JSR VSTRIN
 = CR,"Stations:"
 NOP

 JSR RDLINE
 JSR GETINT
 BNE RDUSRS
 LDA INTEGR + 1
 BNE RDUSRS
 LDA INTEGR
 BEQ RDUSRS
 STA USERS

 CMPIM MAXUSE + 1 ; USRLIM
 BCS RDUSRS
 RTS

 [ DONGLE=1

RDTIME JSR VSTRIN
 = CR,"Time (HH:MM:SS) = "
 NOP

 JSR RDLINE ;INPUT TIME
 JSR GETINT ;GET HOURS
 BNE RDTIME
 LDA INTEGR +1
 BNE RDTIME
 LDA INTEGR
 CMPIM 24 ;CHECK LESS THAN 24 HOURS
 BCS RDTIME
 STA HRS
 LDAIY COMPTR
 CMPIM ":" ;CHECK CORRECT SEPARATOR
 BNE RDTIME
 JSR INCCOM ;NEXT INTEGER
 JSR GETINT
 BNE RDTIME
 LDA INTEGR +1
BTRTM BNE RDTIME
 LDA INTEGR
 CMPIM 60
BTRTM2 BCS RDTIME
 STA MINS
 LDAIY COMPTR
 CMPIM ":" ;CHECK FOR SEPARATOR
 BNE BTRTM
 JSR INCCOM
 JSR GETINT ;GET SECONDS
 BNE BTRTM
 LDA INTEGR +1
 BNE BTRTM
 LDA INTEGR
 CMPIM 60 ;CHECK LESS THAN 60
 BCS BTRTM2
 STA SECS

SETTME LDAIM 0
 [ 1=1
 LDXIM 4
SETJL1 STAAX TIME
 DEX
 BPL SETJL1
 |
 STA TIME
 STA TIME +1
 STA TIME +2
 STA TIME +3
 STA TIME +4
 ]
 JSR ZEROTM
 LDA HRS
 STA OTIME ;PREPARE TO CALCULATE CENTISECONDS
 JSR M60 ;MULTIPLY BY 60
 JSR M60 ;DITTO
 JSR M100 ;TO GET CENTISECONDS
 JSR TIMADD ;KEEP TRACK OF TIME
 JSR ZEROTM
 LDA MINS

 STA OTIME
 JSR M60
 JSR M100 ;TO GET CENTISECONDS
 JSR TIMADD ;KEEP TOTAL
 JSR ZEROTM

 LDA SECS
 STA OTIME
 JSR M100 ;FOR CENTISECONDS
 JSR TIMADD ;KEEP TOTAL
 JSR TMTOT
 LDXIM TIME
 LDYIM /(TIME)
 LDAIM 2
 JMP OSWORD
 
TMTOT
 [ 1=0
 LDA TIME
 STA OTIME
 LDA TIME +1
 STA OTIME +1
 LDA TIME +2
 STA OTIME +2
 LDA TIME +3
 STA OTIME +3
 LDA TIME +4
 STA OTIME +4
 |
 LDXIM 4
TMJL1 LDAAX TIME
 STAAX OTIME
 DEX
 BPL TMJL1
 ]
 RTS

ZEROTM LDAIM 0
 [ 1=0
 STA OTIME
 STA OTIME +1
 STA OTIME +2
 STA OTIME +3
 STA OTIME +4
 |
 LDXIM 4
ZERJL1 STAAX OTIME
 DEX
 BPL ZERJL1
 ]
 RTS

TIMADD CLC
 [ 1=0
 LDA TIME
 ADC OTIME
 STA TIME
 LDA TIME +1
 ADC OTIME +1
 STA TIME +1
 LDA TIME +2
 ADC OTIME +2
 STA TIME +2
 LDA TIME +3
 ADC OTIME +3
 STA TIME +3
 LDA TIME +4
 ADC OTIME +4
 STA TIME +4
 |
 LDYIM 4
 LDXIM 0
TIMJL2 LDAAX TIME
 ADCAX OTIME
 STAAX TIME
 INX
 DEY
 BPL TIMJL2
 ]
 RTS

M60 JSR TXOTN
 LDXIM 6
 JSR SHNTBX
 LDXIM 2
 JSR SHOTBX
 SEC
 [ 1=0
 LDA NTIME
 SBC OTIME
 STA OTIME
 LDA NTIME +1
 SBC OTIME +1
 STA OTIME +1
 LDA NTIME +2
 SBC OTIME +2
 STA OTIME +2
 LDA NTIME +3
 SBC OTIME +3
 STA OTIME +3
 LDA NTIME +4
 SBC OTIME +4
 STA OTIME +4
 |
 LDXIM 0
 LDYIM 4
M60JL1 LDAAX NTIME
 SBCAX OTIME
 STAAX OTIME
 INX
 DEY
 BPL M60JL1
 ]
 RTS

M100 JSR TXOTN
 LDXIM 6
 JSR SHNTBX
 LDXIM 2
 JSR SHOTBX
 CLC
 [ 1=0
 LDA NTIME
 ADC OTIME
 STA NTIME
 LDA NTIME +1
 ADC OTIME +1
 STA NTIME +1
 LDA NTIME +2
 ADC OTIME +2
 STA NTIME +2
 LDA NTIME +3
 ADC OTIME +3
 STA NTIME +3
 LDA NTIME +4
 ADC OTIME +4
 STA NTIME +4
 |
 LDXIM 0
 LDYIM 4
XL5 LDAAX NTIME
 ADCAX OTIME
 STAAX NTIME
 INX
 DEY
 BPL XL5
 ]
 LDXIM 3
 JSR SHOTBX
 CLC
 [ 1=0
 LDA NTIME
 ADC OTIME
 STA OTIME
 LDA NTIME +1
 ADC OTIME +1
 STA OTIME +1
 LDA NTIME +2
 ADC OTIME +2
 STA OTIME +2
 LDA NTIME +3
 ADC OTIME +3
 STA OTIME +3
 LDA NTIME +4
 ADC OTIME +4
 STA OTIME +4
 |
 LDYIM 4
 LDXIM 0
XL4 LDAAX NTIME
 ADCAX OTIME
 STAAX OTIME
 INX
 DEY
 BPL XL4
 ]
 RTS


TXOTN 
 [ 1=0
 LDA OTIME
 STA NTIME
 LDA OTIME +1
 STA NTIME +1
 LDA OTIME +2
 STA NTIME +2
 LDA OTIME +3
 STA NTIME +3
 LDA OTIME +4
 STA NTIME +4
 |
 LDXIM 4
TXOTN1 LDAAX OTIME
 STAAX NTIME
 DEX
 BPL TXOTN1
 ]
 RTS

SHNTBX
 ASL NTIME
 ROL NTIME +1
 ROL NTIME +2
 ROL NTIME +3
 ROL NTIME +4
 DEX
 BNE SHNTBX
 RTS

SHOTBX
 ASL OTIME
 ROL OTIME +1
 ROL OTIME +2
 ROL OTIME +3
 ROL OTIME +4
 DEX
 BNE SHOTBX
 RTS

PRTIM
PRTIME LDXIM TIME
 LDYIM /(TIME)
 LDAIM 1
 JSR OSWORD
 JSR DIV100
 JSR DIV60
 LDA REM
 STA SECS
 JSR DIV60
 LDA REM
 STA MINS
 JSR DIV24
 LDA REM
 STA HRS
 LDAIM &86
 JSR OSBYTE
 STX POS
 STY VPOS
 JSR DWIND ;*** setup the window
 [ 1=0
 LDAIM 31
 JSR OSWRCH
 LDAIM 30
 JSR OSWRCH
 LDAIM 1
 JSR OSWRCH
 |
 JSR VSTRIN
 = 31,30,1
 NOP
 ]
 LDA HRS
 JSR PRNTDG
 LDAIM ":"
 JSR OSWRCH
 LDA MINS
 JSR PRNTDG
 LDAIM ":"
 JSR OSWRCH
 LDA SECS
 JSR PRNTDG
 JSR MWIND ;*** reset the window
 [ 1=0
 LDA TIME
 ORA TIME +1
 ORA TIME +2
 ORA TIME +3
 ORA TIME +4
 |
 LDXIM 4
 LDAIM 0
JLO1 ORAAX TIME
 DEX
 BPL JLO1
 TAX
 ]
 BEQ PRTRT
 LDXIM TIME
 LDYIM /(TIME)
 LDAIM 1
 JSR OSWORD
 SEC
 LDA TIME +1 ;GONE PAST MIDNIGHT SO SET BACK TO APROX. ZERO
 SBCIM &D6
 STA TIME +1
 LDA TIME +2
 SBCIM &83
 STA TIME +2
 LDA TIME +3
 SBCIM 0
 STA TIME +3
 LDA TIME +4
 SBCIM 0
 STA TIME +4
 LDXIM TIME
 LDYIM /(TIME)
 LDAIM 2
 JSR OSWORD
 JSR INCDAY
PRTRT RTS

TDVD
 STA DVSOR
 LDAIM 0
 [ 1=0
 STA OTIME
 STA OTIME +1
 STA OTIME +2
 STA OTIME +3
 STA OTIME +4
 |
 LDXIM 4
XL0 STAAX OTIME
 DEX
 BPL XL0
 ]
 LDYIM &28
L1 DEY
 BEQ L10
 ASL TIME
 ROL TIME +1
 ROL TIME +2
 ROL TIME +3
 ROL TIME +4
 BPL L1
L2
 [ 1=0
 ROL TIME
 ROL TIME +1
 ROL TIME +2
 ROL TIME +3
 ROL TIME +4
 |
 LDXIM :LSB: -5
JLR1 ROLAX TIME - :LSB: -5
 INX
 BNE JLR1
 ]
 [ 1=0
 ROL OTIME
 ROL OTIME +1
 ROL OTIME +2
 ROL OTIME +3
 ROL OTIME +4
 |
 LDXIM :LSB: -5
JLR2 ROLAX OTIME - :LSB: -5
 INX
 BNE JLR2
 ]
 SEC
 LDA OTIME
 SBC DVSOR
 PHA
 LDA OTIME +1
 SBCIM 0
 PHA
 LDA OTIME +2
 SBCIM 0
 PHA
 LDA OTIME +3
 SBCIM 0
 TAX
 LDA OTIME +4
 SBCIM 0
 BCC L3
 STA OTIME +4
 STX OTIME +3
 PLA
 STA OTIME +2
 PLA
 STA OTIME +1
 PLA
 STA OTIME
 BCS L4
L3 PLA
 PLA
 PLA
L4 DEY
 BNE L2
L10 LDA OTIME
 STA REM
 RTS

DIV100 LDAIM 100
DODVD JSR TDVD
 [ 1=0
 ROL TIME
 ROL TIME +1
 ROL TIME +2
 ROL TIME +3
 ROL TIME +4
 |
 LDXIM 0
 LDYIM 4
DODVD1 ROLAX TIME
 INX
 DEY
 BPL DODVD1
 ]
 RTS

DIV60 LDAIM 60
 JMP DODVD

DIV24 LDAIM 24
 JMP DODVD
 ]

 [ DONGLE=0
RDTIME
 ]
PRDTE
 [ DONGLE=0
 JSR RDDONG
 ]
                                 
SCDATE
 JSR DWIND ;set window

 JSR VSTRIN
 = 12,31,0,1
 NOP
 JSR DATE1
 JSR MONTH
 JSR YR

 ;reset the window

MWIND ;set window for monitor
 JSR VSTRIN
 = 28,0,21,39,4,31
POS = 0
VPOS = 0
 NOP
 RTS

DWIND ;set window for printing the date in

 LDAIM &86
 JSR OSBYTE ;read cursor position
 STX POS
 STY VPOS
 JSR VSTRIN
 = 28, 0, 24, 39, 22
 NOP
 RTS

YR LDA DATE + 1
 LSRA
 LSRA
 LSRA
 LSRA
 
 [ Y2KPAT=1
 STA Y2KTMP
 LDA DATE
 JSR OUTY2K
 PHA
 LDAIM &13
 ADCIM 0
 |
 CLC
 ADCIM BASEYR
 PHA
 CMPIM 100
 BCC YR19
 LDAIM 20
 BCS YR20
YR19 LDAIM 19
 ]

YR20 JSR PRNTDG
 PLA
 JMP PRNTDG


MONTH LDA DATE +1
 ANDIM &F
 TAX
 LDYAX MTAB1 - 1
LOOP LDAAY MONTHS
 BEQ MONOUT
 JSR OSWRCH
 INY
 BNE LOOP
MONOUT LDAIM &20
 JMP OSWRCH


MONTHS
JAN = "January", 0
FEB = "February", 0
MAR = "March", 0
APR = "April", 0
MAY = "May", 0
JUN = "June", 0
JUL = "July", 0
AUG = "August", 0
SEP = "September", 0
OCT = "October", 0
NOV = "November", 0
DEC = "December", 0

MTAB1 = JAN -MONTHS
 = FEB -MONTHS
 = MAR -MONTHS
 = APR -MONTHS
 = MAY -MONTHS
 = JUN -MONTHS
 = JUL -MONTHS
 = AUG -MONTHS
 = SEP -MONTHS
MTAB2
 = OCT -MONTHS
 = NOV -MONTHS
 = DEC -MONTHS



DATE1 LDA DATE

 [ Y2KPAT=1
 ANDIM &1F
 JSR Y2KP05
 NOP
 |
 JSR PRNTDG
 LDA DATE
 ]
 
 CMPIM 10
 BCC ND1
 SBCIM 10
 CMPIM 10
 BCC TH1
GTLP SBCIM 10
 CMPIM 10
 BCS GTLP
ND1 TAY
 CPYIM  1
 BEQ XX
 CPYIM  2
 BEQ XX
 CPYIM  3
 BEQ XX
TH1 LDYIM  4
XX DEY
 LDXAY SUFFIX
LOOP2 LDAAX WORD
 BEQ DONE
 JSR OSWRCH
 INX
 BNE LOOP2
DONE LDAIM &20
 JMP OSWRCH


WORD
ST = "st", 0
ND = "nd", 0
RD = "rd", 0
TH = "th", 0


SUFFIX = ST -WORD
 = ND -WORD
 = RD -WORD
 = TH -WORD



SETYR ASLA
 ASLA
 ASLA
 ASLA
 ORA DATE + 1
 STA DATE + 1 ;Year is top nibble of DATE +01
 RTS

 [ DONGLE=0
 ; Dongle has 4 time set registers :- MINS,HOURS,DATE,MONTH               
 ; Also has 4 alarm registers which are treated as RAM
 ; to store YEAR and OLDMONTH to try to deal with year changes
 ; Because cursed chip can not handle years.
 ; All number are BCD coded in the chip                                         

 ; DESIGNATION AS FOLLOWS :-
 
 ; TIME SET REGISTERS, 
 ;     0=MONTH      2=DATE    4=HOURS     6=MINS
                              
 ; RAM REGISTERS,         
 ;  1=YEAR in lower 4 bits                        (Was Months)
 ;  3=OLDMONTH and bit &10 to indicate LEAP pending (Was date)
 ;     
 ;  5=Not Used
 ;  7=User to determine presence of chip            (Was Mins)
                                                      

SETTME ROUT

 LDA MUNTHS
 LSRA
 LSRA
 LSRA
 LSRA
 LDXIM 1
 JSR #95 ;set Year

SETTM1 LDA MUNTHS
 ANDIM &F
 LDXIM 0
 JSR #95 ;set month                                          

 LDA MUNTHS
 JSR SETMFX
 LDXIM 3
 JSR #95 ; Set oldmonth to month and flag

 LDA MINS
 LDXIM 6
 JSR #95

 LDA HRS
 LDXIM 4
 JSR #95

 LDA DAYS
 LDXIM 2
 JSR #95
 
 JMP SCDATE ; SHOW DATE ON SCREEN

SETMFX  ; FIX MONTH AND FLAG ON SET TIME
 PHA    ; stack month and year
 ANDIM &0F ; Mask MONTH
 CMPIM 2
 BCC SETJAN ; Branch if Jan
 BNE LHNOF  ; >JAN so no flag pending
 LDA DAYS
 CMPIM 29
 BCS LHNOF  ; >= 29 so no flag pending
          
SETJAN      ; befor Feb 29 so check for leap
 PLA        ; Retreive year
 PHA       
 LSRA
 LSRA
 LSRA
 LSRA
 JSR CHLPY2  ; Check if leap year
 BNE LHNOF   ; Not leap so flag clear
 PLA 
 ANDIM &0F   ; Otherwise
 ORAIM &10   ; set flag on month
 RTS          

LHNOF PLA                           
 ANDIM &0F
 RTS

CHLPY2       ; Leap Year check
 CLC
 ADCIM BASEYR
 ANDIM 3
 RTS     

PRTIM INC OTIME ;** avoid tube failure 25/1/85 **
 BNE RTCX ;exit 
 INC OTIME+1
 BMI RTCX
 SEC
 ROR OTIME+1
PRTIME JSR RDDONG
 LDA HRS
 ORA MINS
 BNE PRTIM1 ;midnight
 ORA SECS ;check not already done
 BNE PRTIM2

 INC SECS
 JSR PRDTE ;reprint the date
 JMP PRTIM2

PRTIM1 LDAIM 0
 STA SECS
PRTIM2 JSR DWIND ;set up window
 JSR VSTRIN
 = 31,30,1
 NOP
 LDA HRS
 JSR PRNTDG
 LDAIM ":"
 JSR OSWRCH
 LDA MINS
 JSR PRNTDG
 JMP MWIND ;reset window and return
 
RTC ;check that the read time clock is present

 LDXIM 7
 LDAIM &71
 JSR #95 ;write the minutes alarm register

 LDXIM 7 ;read the same register
 JSR #00
 JSR #70
 EORIM &0D ;devious eh 
 BNE RTCX ;fail

 LDXIM 7
 JSR #95 ;write zero as well

 LDXIM 7
 JSR #00 ;read result
 CMPIM 0
RTCX RTS ;returns EQ if dongle present

RDDONG

 LDXIM 6 ;read minutes
 JSR #00
 JSR #70
 STA MINS

 LDXIM 4 ;hours
 JSR #00
 JSR #70
 STA HRS

 LDXIM 2 ;days
 JSR #00
 JSR #70
 STA DATE

 LDXIM 0 ;months
 JSR #00
 JSR #70
 STA DATE+1
     
 LDXIM 3 ;oldmonth
 JSR #00
 JSR #70
 STA OTIME+2 ;  somewhere but where


 LDXIM 1 ;year (in alarm resister)
 JSR #00
 JSR #70
 JSR SETYR
                          

REDFIX  ; FIX year changes    
 ; Fix date on reading dongle
 ; ENTRY DATE+1  has perceived month and year
 ;       OTIME+2 has OLDMONTH and Flag
 ;       OTIME+3 used

 LDA OTIME+2
 ANDIM &0F
 STA OTIME+3
 LDA DATE+1
 ANDIM &0F     ; A has month
 CMP OTIME+3
 BCS LHLYCK    ; Months are ok so leap year checks
               ; Here month has decreased so reset year
 LDA DATE+1
 CLC
 ADCIM &10     ; Increment year will loop sometime
               ; but who cares as product should
               ; be dead by then
 STA DATE+1
 BNE RFIXX2    ; Branch always (month <>0)     
               ; REWRITE DONGLE
LHLYCK LDA OTIME+2
 ANDIM &10
 BEQ RTCX    ; No flag so exit
 
LHFXNX
 LDA DATE+1    ; Load new Month
 ANDIM &0F
 CMPIM 3
 BCC RTCX      ; Not MAR yet so exit
               ; Here it is March (or Later) in a leap year 
               ; So fix dates
 DEC DATE      ; DEC DAYS
 BNE RFIXX2    ; RE WRITE DONGLE
        
               ; DAYS Became ZERO !                    
 DEC DATE+1    ; Decrement month is ok
 LDA DATE+1
 ANDIM &0F     ; Get new month saves confusion
 CMPIM 2 
 BNE LHNFEB    ; IS NOT FEB SO CHECK OTHERS
 LDAIM 29      ; Must be 29th
 BNE RFIXEX    ; Re Write DONGLE (ALWAYS)

LHNFEB
 LDXIM 4
LHCHKL CMPAX MW30D - 1
 BEQ LHCKLX    ; FOUND SO EXIT
 DEX
 BNE LHCHKL
 LDAIM 31
 BNE RFIXEX
      
LHCKLX LDAIM 30
RFIXEX

 STA DATE
RFIXX2
 JSR CHKDTE
 JMP SETTME

 
00 PHP ;same as POKE
 TXA
 JSR #05
 LDAIM &06 ;bits 7,5 are POWERFAIL and ALARM
 STA DDRB
 JSR #55 ;write DDRB
 JSR #10
 LDXIM 2
 CLC
 JSR #20
 NOP
 NOP
 JSR #50
 LDA IRB ;read IRB
 ANDIM 1
 CLC
 RORA
 RORA
 LDYIM 6
25 PHA
 TXA
 ORAIM 1
 TAX
 CLC
 JSR #40
 NOP
 NOP
 JSR #50
 LDA IRB
 LSRA
 PHP
 TXA
 ANDIM &FE
 TAX
 CLC
 JSR #40
 PLP
 PLA
 RORA
 DEY
 BNE #25
 CLC
 RORA
 PHA
 JSR #15
 JSR #50
 LDX IRB
 PLA
 PLP
 RTS ;all done

05 LDXIM &A7
 STX DDRB
 JSR #55 ;write DDRB
 LDYIM 4
 ASLA
 LDXIM 2 ;fall thru'

30 RORA
 JSR #35
 DEY
 BNE #30
 RTS ;write bits one at a time

10 JSR #15
 NOP
 NOP
 CLC
 JSR #35
 NOP
 NOP
 RTS

35 PHA
 PHP
 TXA
 ORAIM 1
 TAX
 JSR #40
 TXA
 ANDIM &FE
 TAX
 PLP
 JSR #40
 PLA
 RTS

15 LDXIM 0
 STX ORB
 BEQ #45

40 NOP
 NOP
 NOP
 NOP
20 TXA
 ROLA
 STA ORB

45 PHP
 PHA
 TXA
 PHA
 TYA
 PHA
 LDAIM 151
 LDXIM &60
 LDY ORB
 JSR OSBYTE
 JMP #60

50 PHP
 PHA
 TXA
 PHA
 TYA
 PHA
 LDAIM 150
 LDXIM &60
 JSR OSBYTE
 STY IRB
 JMP #60

55 PHP
 PHA
 TXA
 PHA
 TYA
 PHA
 LDAIM 151
 LDXIM &62
 LDY DDRB
 JSR OSBYTE
60 PLA
 TAY
 PLA
 TAX
 PLA
 PLP
 RTS

95 PHP ;Set routine
 JSR #85 ;convert to BCD (without corrupting X)
 CPXIM 0 ;detect writing munths
 BNE #99
 ORAIM &40
99 PHA
 TXA
 JSR #05
 PLA
 LDYIM 7
 JSR #30
 JSR #10
 JSR #15
 PLP
 RTS

70 LDYIM 0
 TAX
 BEQ #75
80 CLD
 INY
 SED
 SEC
 SBCIM 1
 BNE #80
 CLD
75 TYA
 RTS

85 TAY ;make BIN to BCD
 BEQ #94
 LDAIM 0
 SED
90 CLC
 ADCIM 1
 DEY
 BNE #90 
94 CLD
 RTS
 ]
 LNK UADE05
