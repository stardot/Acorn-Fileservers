 OPT UADE0D ;FILE > Uade0D
 TTL File server file UADE0D

;********************************
;*       DIRMAN UTILITIES       *
;********************************

;******** GETDIR ROUTINE *********

;GETDIR: LOADS THE DIRECTORY SPECIFIED BY A FILE TITLE.

;EXIT: A = RC
;DIRSTA = ADDR OF DIR IN MEMORY

;IF TITLE = <root><terminator> OR
;TITLE = <terminator>
;THEN load 'current dir' #set by INITDV#
;ELSE call RETENT #retrieve entry#
;check that entry is for a directory
;DIRSIN := SIN of current entry
;load new current directory
;FI

;NOTE that GETDIR in cases where an error occurs
;will UNLOCK anything that it loaded.

 [ 1=0
GETDIR
 LDAIM  0
 STA DIRFLG
 ]
GETDRD JSR TSTROT ;<root>$<terminator>?
 BEQ GETDRB
 JSR TSTERM ;<terminator>$?
 BNE GETDRF
GETDRB JSR LOADDR ;LOAD CURRENT DIR
 BEQ GETDRZ
 JSR UNLOCK
 JMP GETDRZ
GETDRF BIT DIRFLG
 BMI GETDRE
 JSR RETENT
 JMP GETDRC
GETDRE JSR RETEND
GETDRC BNE GETDRZ
 JSR TSTDIR ;SEE IF ITS A DIR-TSTDIR WILL UNLOCK IF REQD.
 BNE GETDRZ
 JSR SETSIN
 JSR UNLOCK
 JSR LOADDR
 BEQ GETDRZ
 JSR UNLOCK
GETDRZ RTS

;CHKTIT: CHECKS THE SYNTAX OF A FILE TITLE.
;ENTRY: NAMPTR => PTR TO FILE TITLE,
;TO BE RECOGNISED.

;EXIT : A = RC (0=>SUCCESS)
;LASTNM => ADDRESS OF THE LAST
;TEXT NAME IN THE FILE TITLE.

;<file title>::=$<title component>|<file name>
;<file name)::= <text name><title component>
;<title component>::=<terminator>|<separator><file name>

CHKTIT LDA DIRWC
 ANDIM &C0
 STA DIRWC ;top bits only
 LDYIM  0 ;Y:=PTR TO CHAR
 STY DIRTMP ;counter for loop here
 JSR SETLST ;SETUP LASTNM
 LDAIY NAMPTR
 CMPIM ROOT
 BNE CHKTTH ;SEE IF ITS A <file name>
 INY
 LDAIY NAMPTR
 CMPIM SEPART ;IS IT A <separator>
 BEQ CHKTTG
 CMPIM TERMIN ;IS IT A <terminator>
 BEQ CHKTTA
 LDAIM DRERRA ;RC:=INVALID SEPARATOR
 BNE CHKTTZ

;TRY TO RECOGNISE <file name>

CHKTTG INY
CHKTTH STY DIRTMP + 1 ;save offset
 JSR SETLST ;SETUP LASTNM
CHKTTJ JSR CHKTEX ;RECOGNISE <text name>
 BNE CHKTTZ
 LDAIY NAMPTR
 CMPIM TERMIN
 BNE CHKTTM

 LDX DIRTMP
 INX
 STX DIRTMP
 CPXIM  2
 BEQ CHKTTA ;match here

 ASL DIRWC ;last level here
 LDY DIRTMP + 1 ;restore Y
 JMP CHKTTJ ;do loop again

CHKTTA LDAIM  0 ;RC := 0
 BEQ CHKTTZ
CHKTTM CMPIM SEPART
 BEQ CHKTTG
 LDAIM DRERRA
CHKTTZ RTS

;CHKTEX: RTN TO RECOGNISE <text name>

CHKTEX LDXIM NAMLNT ;X:=MAX NO. OF CHARS IN <text name>
CHKTXA LDAIY NAMPTR
 CMPIM &21
 BCC CHKTXX
 CMPIM &7F
 BCS CHKTXX ;Nope => error

 BIT DIRWC
 BPL CHKTLA
 CMPIM "*"
 BEQ CHKTXV
 CMPIM "#"
 BEQ CHKTXV

CHKTLA CMPIM """" ;** 21/9/83 **
 BEQ CHKTXX
 CMPIM ":"
 BEQ CHKTXX
 CMPIM "*"
 BEQ CHKTXX
 CMPIM "."
 BEQ CHKTXX
 CMPIM ":"
 BEQ CHKTXX
 CMPIM "#"
 BEQ CHKTXX ;Nope => error
 CMPIM "$"
 BEQ CHKTXX ;** 18/9/84 **

CHKTXV INY
 DEX
 BNE CHKTXA
CHKTXX LDAIM  0
 CPXIM NAMLNT ;TEST LENGTH OF <text name>
 BNE CHKTXZ
 LDAIM DRERRA ;INVALID TEXT NAME
CHKTXZ TAX  ;SET FLAGS
 RTS

SETLST TYA  ;RTN TO SETUP LASTNM
 CLC
 ADC NAMPTR
 STA LASTNM
 LDA NAMPTR + 1
 ADCIM  0
 STA LASTNM + 1
 RTS

;FNDTEX: SEARCH CUR DIR FOR NAME IN TXTNAM.
;N.B. DIR ENTRIES ARE SORTED,
;KEY=<file title>.

;ENTRY: DIRSTA=STORE ADDR OF DIR TO BE SEARCHED.

;EXIT : A=0 => NAME FOUND
;PREVEN => PTR TO PREVIOUS ENTRY
;CRNTEN => PTR TO CURRENT ENTRY

FNDTEX JSR INTPRE ;PREVEN := addr of 1st entry
 LDAIM  0
 STA WILD1 ;flag for wild cards
FNDTXA JSR SETCRN
 BEQ FNDTXB ;end of dir ?
 LDYIM DRTITL
 LDXIM  0
 
 JSR FNDM1 ;look up name with wild cards
 BCS FNDTXE
 PHP
 LDA WILD1
 BNE FNDTXP
 PLP
 BMI FNDTXB
 PHP
FNDTXP PLP
FNDTEZ JSR MOVCRN
 JMP FNDTXA ;repeat until end

FNDTXB LDAIM DRERRC
 RTS
FNDTXE LDAIM  0
 RTS ;exit ok

FNDM1 LDAAX TXTNAM
 CMPIM "*"
 BNE FNDM4
 INC WILD1
 INX
FNDM6 TXA
 PHA
 TYA
 PHA
 JSR FNDM1
 PLA
 TAY
 PLA
 TAX
 BCS FNDMR
 INY
 CPYIM  12
 BCC FNDM6

FNDMT LDAAX TXTNAM
 CMPIM &20
 BEQ FNDMR
 CMPIM &0D
 BEQ FNDMR
 CPXIM  10 ;returns C=1 at end-of-name
 RTS

FNDM4 CPYIM  12
 BCS FNDMT
 JSR CPCHAR
 BNE FNDMF
 INX
 INY
 BNE FNDM1

FNDMF CLC
FNDMR RTS

CPCHAR CMPIM "#"
 BEQ CPRET
 JSR CAPS
 PHA
 LDAIY CRNTEN
 JSR CAPS
 STA WILD2
 PLA
 CMP WILD2
 RTS

CPRET INC WILD1 ;set flag
 LDAIY CRNTEN ;must NOT match a space
 CMPIM SPACE
 PHP
 PLA
 EORIM 2 ;flip Z flag
 PHA
 PLP ;return Z=1 if not a space
 RTS

CAPS STA WILD2
 CMPIM "A"
 BCC CAPSL1
 CMPIM "z" + 1
 BCS CAPSL1
 CMPIM "Z" + 1
 BCC CAPSL3
 CMPIM "a"
 BCS CAPSL2
CAPSL1 SEC
 BCS CAPSL3
CAPSL2 CLC
CAPSL3 LDAIM &F9
 RORA
 RORA
 RORA
 AND WILD2
 RTS

INTPRE LDA DIRSTA ;PREVEN := DIRSTA
 STA PREVEN
 LDA DIRSTA + 1
 STA PREVEN + 1
 RTS

MOVCRN LDA CRNTEN ;PREVEN := CRNTEN
 STA PREVEN
 LDA CRNTEN + 1
 STA PREVEN + 1
 RTS

SETCRN CLC  ;RTN TO SETUP CRNTEN (CURRENT ENTRY) PTR
 LDYIM DRLINK
 LDAIY PREVEN
 ADC DIRSTA
 STA CRNTEN
 INY
 LDAIY PREVEN
 ADC DIRSTA + 1
 STA CRNTEN + 1
 LDYIM  0
 LDAIY PREVEN
 INY
 ORAIY PREVEN ;IF [PREVEN] = 0 THEN A:=0
 RTS

;INITDV: INITIALISES SEVERAL DIRMAN VARIABLES.

;ENTRY: ARGB = LS
;ARGC = MS(PTR TO USERINFO)
;ARGD = LS
;ARGE = MS(PTR TO FILE TITLE)

;FUNCTION:-

;DRUSIN => PTR TO USERINFO
;MCNUMB => MACHINE NO OF CALLER
;NAMPTR => PTR TO FILE TITLE
;DRDISC => SELECTED DISC NUMBER
;DIRACC => IF CHAR[0] OF FILE TITLE = ROOT
;THEN IF SYST PRIVILEGED
;THEN OWNER ACCESS
;ELSE ANYBODY ACCESS
;FI
;ELSE ACCESS TO CURRENTLY SELECTED DIR
;FI ! TYPDIR

;DIRSIN => IF DISC NAME PRESENT
;THEN SIN OF ROOT DIRECTORY ON NAMED DISC
;ELIF CHAR[0] OF FILE TITLE = ROOT
;THEN SIN OF ROOT DIRECTORY
;ELSE SIN OF CURRENTLY SELECTED DIR
;FI
;TDATE  => IF ROOT DIR IMPLIED
;THEN DATE ROOT DIR CREATED (SEE MAPTB)
;FI
;DIRSTT := 0 START BLK NO

;EXIT: A = RC

INITDV LDYIM ARGB
 LDAIY ARGPTR
 STA DRUSIN
 INY
 LDAIY ARGPTR
 STA DRUSIN + 1 ;DRUSIN:=PTR TO USER INFO

 INY
 LDAIY ARGPTR
 STA NAMPTR
 INY
 LDAIY ARGPTR
 STA NAMPTR + 1 ;NAMPTR := PTR TO FILE TITLE

 LDYIM UTMCNO
 LDAIY DRUSIN
 STA MCNUMB
 INY
 LDAIY DRUSIN
 STA MCNUMB + 1 ;MCNUMB := MACHINE NO OF CALLER

;PRECEEDED BY A DISC NAME?

 LDYIM  0
 LDAIY NAMPTR
 CMPIM DISCIN ;DISC NAME PRESENT??
 BEQ INTSTR
 JMP INTDVC

INTSTR LDXIM DNAMLN ;X:=MAX LENGTH OF DISC NAME
 LDAIM DRDSNM
 STA MOVTO
 LDAIM /(DRDSNM )
 STA MOVTO + 1 ;MOVTO:=PTR TO DRDSNM BUFFER

 CLC
 LDAIM  1
 ADC NAMPTR
 STA NAMPTR
 LDAIM  0
 ADC NAMPTR + 1
 STA NAMPTR + 1 ;NAMPTR+:=1

 LDAIY NAMPTR
INTDVA STAIY MOVTO ;COPY DISC NAME INTO DRDSNM
 CMPIM TERMIN ;TERMINATOR?
 BEQ INTDBA
 CMPIM SEPART ;SEPARATOR?
 BNE INTDVB
 LDAIM TERMIN
 STAIY MOVTO ;TERMINATE DISC NAME
 INY
 JMP INTDBA
INTDVB INY
 LDAIY NAMPTR
 DEX
 BNE INTDVA
 LDAIM TERMIN
 STAIY MOVTO ;TERMINATE DISC NAME
 LDAIY NAMPTR
 CMPIM TERMIN
 BEQ INTDBA
 CMPIM SEPART
 BEQ INTDBC
 LDAIM DRERRA ;BAD FILE TITLE
 JMP INTDVZ
INTDBC INY
INTDBA CLC
 TYA
 ADC NAMPTR
 STA NAMPTR
 LDAIM  0
 ADC NAMPTR + 1
 STA NAMPTR + 1 ;NAMPTR:=PTR TO FILE TITLE
 JMP INTDBD
 DEY
 JMP INTDBA

;GET DISC NUMBER OF NAMED DISC

INTDBD LDYIM ARGA
 LDAIM &A
 STAIY NEWARG
 INY
 LDAIM DRDSNM
 STAIY NEWARG
 INY
 LDAIM /(DRDSNM )
 STAIY NEWARG ;PTR TO DISC NAME
 JSR MAPMAN ;MAPMAN.DISCNAME->DISCNUMB
 BEQ INTA
 JMP INTDVZ
INTA LDYIM ARGB
 LDAIY NEWARG
 STA DRDISC
 INY
 LDAIY NEWARG
 STA DRDISC + 1
 JMP INTDVD

;WAS ROOT DIR SPECIFIED

INTDVC JSR TSROOT ;IS ROOT DIR SPECIFIED?
 BNE INTDVH
 LDYIM UTDISC
 LDAIY DRUSIN
 STA DRDISC
 INY
 LDAIY DRUSIN
 STA DRDISC + 1 ;DRDISC:=SELECTED DISC NUMBER
INTDVD LDAIM ANYBDY
 ORAIM TYPDIR
 STA DIRACC ;DIRACC:=ANYBDY!TYPDIR
 LDYIM UTPRIV
 LDAIY DRUSIN
 ANDIM SYSTPV
 BEQ INTDVE
 LDAIM OWNER
 ORAIM TYPDIR
 STA DIRACC ;DIRACC:=OWNER!TYPDIR

;GET SIN OF ROOT ON SELECTED DISC

INTDVE LDYIM ARGA
 LDAIM  4 ;(SIN OF ROOT)
 STAIY NEWARG
 JSR SETDSN ;PLACE DISC NO ON NEWARG STACK
 JSR MAPMAN ;CALL MAPMAN.SINOFROOT
 BNE INTDVZ
 LDYIM ARGB
 LDAIY NEWARG
 STA DIRSIN
 INY
 LDAIY NEWARG
 STA DIRSIN + 1
 INY
 LDAIY NEWARG
 STA DIRSIN + 2 ;DIRSIN:=SIN OF ROOT
 INY
 LDAIY NEWARG
 STA TDATE ;TDATE:=DATE OF ROOT
 INY
 LDAIY NEWARG
 STA TDATE + 1
 JMP INTDVT

;LOOK UP ACCESS, DISC NUMBER, & SIN OF SELECTED DIR

INTDVH LDYIM UTHSLD ;OFFSET OF HANDLE FOR SELECTED DIR
 LDAIY DRUSIN ;A:=HANDLE FOR SELECTED DIR
 JSR FNDHND ;FIND HANDLE IN HANDTB
 BNE INTDVZ

;CHECK THAT ITS A DIR

 LDYIM HTACC
 LDAIY HNDPTR
 ANDIM TYPDIR
 BNE INTDVJ
 LDAIM DRERRD ;OBJECT NOT A DIR
 BNE INTDVZ

INTDVJ CLC
 LDA HNDPTR ;HNDPTR SETUP BY FNDHND
 ADCIM HTACC
 STA MOVFRM
 LDA HNDPTR + 1
 ADCIM  0
 STA MOVFRM + 1
 LDAIM DIRACC
 STA MOVTO
 LDAIM /(DIRACC )
 STA MOVTO + 1
 LDXIM  6 ;DIRACC,DRDISC,DIRSIN
 JSR MOVE ;COPY INFO FROM HANDTB INTO DIRMAN VARIABLES

INTDVT LDAIM  0
 STA DIRSTT
 STA DIRSTT + 1 ;DIRSTT:=0
INTDVZ RTS

LDDR LDYIM ARGA
 LDAIM  5
 STAIY NEWARG
 JSR SETDIR
 JSR MAPMAN ;MAPMAN.SIZEINFO
 BNE LDDRZ
 LDYIM ARGB
 LDAIY NEWARG
 STA DIRSZE
 INY
 LDAIY NEWARG
 STA DIRSZE + 1 ;DIRSZE:=SIZE OF DIR IN BYTE
 INY
 LDAIY NEWARG
 STA DIRSZE + 2
 LDYIM ARGE
 LDAIY NEWARG
 STA DIRBKS
 INY
 LDAIY NEWARG
 STA DIRBKS + 1 ;DIRBKS:=NO OF BLOCKS USED BY DIR
 LDAIM  0
 STA DIRSTT
 STA DIRSTT + 1 ;DIRSTT:=0(START ADDR IN DIR)
 JSR SETDIR
 LDYIM ARGA
 LDAIM  1
 STAIY NEWARG ;STRMAN.DISC ADDR TO STORE ADDR
 JSR STRMAN
 BNE LDDRZ
 LDYIM ARGB
 LDAIY NEWARG
 STA DIRSTA
 STA DPTRLD
 INY
 LDAIY NEWARG
 STA DIRSTA + 1
 STA DPTRLD + 1 ;DPTRLD:=PTR TO 1ST BYTE OF DIR
 LDAIM  0 ;RC:=0
LDDRZ RTS

LOADDR JSR LDDR ;TRY AND LOAD THE DIR
 BNE LOADRZ

;SEE IF LEADING AND TRAILING SEQUENCE NUMBERS MATCH
;IN THE PROCESS SETUP DPTRTR (PTR TO LAST BYTE OF DIR)

 LDYIM DRSQNO
 LDAIY DPTRLD
 TAX  ;X:=LEADING SQ. NO.
 SEC
 LDA DPTRLD
 SBCIM  1
 STA DPTRTR
 LDA DPTRLD + 1
 SBCIM  0
 STA DPTRTR + 1 ;DPTRTR:=DPTRLD-1
 CLC
 LDA DPTRTR
 ADC DIRSZE
 STA DPTRTR
 LDA DPTRTR + 1
 ADC DIRSZE + 1
 STA DPTRTR + 1 ;DPTRTR:=PTR TO LAST BYTE OF DIR
 TXA
 LDYIM  0
 CMPIY DPTRTR ;A:=TRAILING SQ. NO.
 BEQ LOADRY
 LDAIM DRERRB ;BROKEN DIR
 BNE LOADRZ
LOADRY LDYIM ARGA
 LDAIY NEWARG ;RC
LOADRZ RTS

SETDIR LDAIM DRDISC ;MOVE DISC NO->DIRBKS ONTO NEWARG STACK
 STA MOVFRM
 LDAIM /(DRDISC )
 STA MOVFRM + 1
 CLC
 LDA NEWARG
 ADCIM ARGB
 STA MOVTO
 LDA NEWARG + 1
 ADCIM  0
 STA MOVTO + 1
 LDXIM  9
 JMP MOVE

STAARG LDA DIRSTA ;MOVE DIRSTA ONTO ARG STACK FOR STRMAN
 LDYIM ARGB
 STAIY NEWARG
 STA GENPTR ;SETUP GENPTR FOR MRKDRT RTN
 LDA DIRSTA + 1
 INY
 STAIY NEWARG
 STA GENPTR + 1
 RTS

UNLOCK PHA
 LDYIM ARGA ;CALL STRMAN.UNLOCK
 LDAIM  3
 STAIY NEWARG
 JSR STAARG
 JSR STRMAN
 BEQ UNLKZ
 JSR INTERR
UNLKZ PLA
 RTS

ENSRIT LDYIM ARGA ;CALL STRMAN.ENSURE FOR DIR
 LDAIM  2
 STAIY NEWARG
 JSR STAARG
 JSR MRKDRT
 LDYIM ARGD
 LDAIM UNLKIT
 STAIY NEWARG ;ENSURE AND UNLOCK THE OBJECT

;NOW INC SEQ. NOS.

 LDYIM DRSQNO
 LDAIY DPTRLD
 TAX
 INX
 TXA  ;A:=NEW SQ NO
 STAIY DPTRLD ;1ST SQ NO
 LDYIM  0
 STAIY DPTRTR ;LST SQ NO

 JMP STRMAN

;RETDIR: RETRIEVE DIR BEFORE LAST COMPONENT OF FILE TITLE.

;EXIT: A = RC
;NAMPTR = PTR TO LAST TEXT NAME.
;DIRSTA = ADDR OF DIR IN MEMORY

;FUNCTION: IF SYNTAX OF FILE TITLE OK
;THEN RETRIEVE PENULTIMATE DIR
;FI

RETDIR JSR CHKTIT ;CHECK SYNTAX OF FILE TITLE
 BNE RETDRZ

;** 11/4/84 **
;attempts to delete "$" fail in eyecatching manner

 LDA NAMPTR
 CMP LASTNM
 BNE RETDRA
 LDA NAMPTR+1
 CMP LASTNM+1
 BNE RETDRA ;ok if not EQ
 JSR TSTROT ;look for ROOT here
 BNE RETDRA
 


 LDAIM DRERRC ;'not found', well it cant be can it !
 BNE RETDRZ ;exit with error

RETDRA JSR LOADDR ;LOAD CURRENT DIR
 BEQ RETCNT
 JSR UNLOCK
 JMP RETDRZ

RETCNT
;IF THE FIRST NAME=ROOT THEN WE HAVE TO ADJUST NAMPTR

 JSR TSROOT ;SEE IF FIRST NAME COMPONENT=ROOT
 BNE RETDRB

 CLC
 LDA NAMPTR
 ADCIM  2
 STA NAMPTR
 LDA NAMPTR + 1
 ADCIM  0
 STA NAMPTR + 1 ;NAMPTR+:=2

RETDRB LDA NAMPTR
 CMP LASTNM
 BNE RETDRC
 LDA NAMPTR + 1
 CMP LASTNM + 1
 BEQ RETDRY ;BRANCH IF ARRIVED AT LAST TEXT NAME

;COPY NEXT TEXT NAME COMPONENT INTO TXTNAM
;& MOVE NAMPTR TO NEXT COMPONENT

RETDRC JSR LOADTX

;CHECK DIR EXISTS

 JSR FNDTEX ;SEARCH DIR FOR TEXT NAME
 BEQ RETDRH
 JSR UNLOCK ;STRMAN.UNLOCK DIR FROM STORE
 JMP RETDRZ

;FIRST CHECK THAT ITS A DIR

RETDRH JSR ISDIR
 BEQ RETDRJ 
 JSR FNDTEZ ;try on next match
 BEQ RETDRH
 JSR UNLOCK ;unlock the entry
 BNE RETDRZ ;exit with error

;NOW PREPARE FOR NEXT DIR TO BE LOADED, AND
;UNLOCK THE CURRENT ONE

RETDRJ JSR SETSIN ;DIRSIN := SIN OF NEXT DIR TO BE LOADED
 JSR UNLOCK ;UNLOCK CURRENT DIR
 JMP RETDRA
RETDRY LDAIM  0
RETDRZ RTS

ISDIR LDYIM DRACCS
 LDAIY CRNTEN ;check type found
 ANDIM TYPDIR
 CMPIM TYPDIR
 RTS

RETENT JSR RETDIR ;FIND APPROPRIATE DIR
 BNE RETETZ
 JSR LOADTX ;COPY LAST TEXTNAME INTO TXTNAM
 JSR FNDTEX ;SEARCH FOR LAST TEXT NAME
 BEQ RETETZ
RETUNL JSR UNLOCK
RETETZ RTS

RETEND JSR RETDIR
 BNE RETETZ
 JSR LOADTX
 JSR FNDTEX
 BNE RETUNL
RETEN1 JSR ISDIR
 BEQ RETETZ
 JSR FNDTEZ
 BEQ RETEN1
 BNE RETUNL

TSTDIR LDYIM DRACCS
 LDAIY CRNTEN ;CRNTEN
 ANDIM TYPDIR
 CMPIM TYPDIR
 BEQ TSTDRZ
 JSR UNLOCK ;UNLOCK CURRENT DIR IF ENTRY NOT FOR A DIR
 LDAIM DRERRD ;RC := OBJECT NOT A DIR
TSTDRZ RTS

SETSIN LDYIM DRSIN ;DIRSIN := SIN OF CRNTEN
 LDAIY CRNTEN
 STA DIRSIN
 INY
 LDAIY CRNTEN
 STA DIRSIN + 1
 INY
 LDAIY CRNTEN
 STA DIRSIN + 2
 RTS

;MAXACC: CALC ACCESS TO A PARTICULAR DIR ENTRY
;EXIT: A:=OBJACC:= TYPE & MAX ACCESS TO OBJECT

MAXACC LDYIM DRACCS
 LDAIY CRNTEN
 ANDIM TLAMSK
 STA OBJACC ;OBJACC:=TYPE & ACCESS SPECIFIED IN DIR ENTRY
 ANDIM TYPDIR
 BEQ MAXACF

;ITS A DIR SO OBJACC := TYPDIR!DIRACC

 LDA DIRACC
 ANDIM OWNER ;** 30/9/84 **
 ORA OBJACC
 JMP MAXACZ

;ITS A FILE SO
;IF (DIRACC & OWNER) = OWNER
;THEN TYPFIL!((OBJACC SHR 2)&RDWRACC)!(OBJACC&RDWRAC)
;ELSE TYPFIL ! (OBJACC & RDWRAC)
;FI

MAXACF LDA DIRACC
 ANDIM OWNER
 BEQ MAXACG ;BRANCH IF ANYBODY

;OWNER ACCESS

 LDA OBJACC
 LSRA
 LSRA
 ANDIM RDWRAC
 TAX  ;X:= A & RDWRAC
 LDA OBJACC
 [ 1=0
 ANDIM RWLACC ;Preserve LWR bits
 |
 ANDIM LOCKED ;** 28/3/85 **
 ]
 STA OBJACC
 TXA
 ORA OBJACC
 JMP MAXACZ

;ANYBODY ACCESS

MAXACG LDA OBJACC
 ANDIM RWLACC ;ANYBODY ACCESS
MAXACZ STA OBJACC
 LDA DIRACC
 ANDIM OWNER
 ORA OBJACC ;Include owner bit in result
 STA OBJACC
 RTS

LOADTX LDAIM TXTNAM ;MOVE TEXT NAME INTO TXTNAM
 STA TXTPTR
 LDAIM /(TXTNAM )
 STA TXTPTR + 1
 LDYIM  0
LDTXA LDAIY NAMPTR
 CMPIM TERMIN
 BEQ LDTXC
 CMPIM SEPART
 BEQ LDTXC
 STAIY TXTPTR ;MOVE CHAR INTO TXTNAM
 INY
 JMP LDTXA

;MAKE NAMPTR PT TO 1ST CHAR AFTER <terminator>|<separator>

LDTXC TYA
 SEC ;ADD 1
 ADC NAMPTR
 STA NAMPTR
 LDA NAMPTR + 1
 ADCIM  0
 STA NAMPTR + 1

;FILL REMAINDER OF TXTNAM WITH SPACES

LDTXF CPYIM NAMLNT+1 ;** 5/9/84 **
 BEQ LDTXZ
 LDAIM SPACE
 STAIY TXTPTR
 INY
 BNE LDTXF
LDTXZ RTS

SETFRE CLC  ;SETUP DIRFRE (ADDR OF FREE CHAINPTR IN DIR)
 LDA DIRSTA
 ADCIM DRFREE
 STA DIRFRE
 LDA DIRSTA + 1
 ADCIM  0
 STA DIRFRE + 1
 LDYIM  0 ;TEST FOR [DIRFRE]=0
 LDAIY DIRFRE
 INY
 ORAIY DIRFRE ;A=0 IF NO FREE ENTRIES
 RTS

;DELCHK: RTN TO CHECK WHETHER A DIR ENTRY MAY BE DELETED

;EXIT: A = RC

;FUNCTION: IF ENTRY 'LOCKED'
;THEN ERROR (I.E. A>0)
;ELIF OBJECT OPEN
;THEN ERROR
;ELIF TYPE = TYPDIR ANDF NOT EMPTY
;THEN ERROR
;ELSE OBJECT MAY BE DELETED (I.E. A = 0)
;FI

DELCHK LDYIM DRACCS
 LDAIY CRNTEN
 ANDIM LOCKED
 BEQ DELCKD
 LDAIM DRERRG
 BNE DELCKZ

;SAVE SIN OF OBJECT TO BE DELETED

DELCKD JSR CRNSIN ;OBJSIN := SIN OF OBJECT

;SEE IF THE OBJECT TO BE DELETED IS OPEN

 JSR SETDSN ;SETUP DISC NO AND SIN ON NEWARG STACK
 LDYIM ARGA
 LDAIM  2
 STAIY NEWARG
 JSR RNDMAN ;RNDMAN.INFO
 BNE DELCKG
 LDAIM DRERRI ;CANNOT DELETE OPENED OBJECT
 BNE DELCKZ

;IF IT IS DIR MAKE SURE THAT IT IS EMPTY

DELCKG LDYIM DRACCS
 LDAIY CRNTEN
 ANDIM TYPDIR
 BNE DELCKJ
 LDAIM  0
 BEQ DELCKZ

;LOAD FIRST BLOCK OF THE DIR
;TO SEE IF IT IS EMPTY

DELCKJ JSR SETDSN ;PLACE DISC NO AND SIN ON NEWARG STACK
 LDYIM ARGA
 LDAIM  1
 STAIY NEWARG
 LDYIM ARGG
 LDAIM  0
 STAIY NEWARG ;LS
 INY
 STAIY NEWARG ;MS(BLK NO) START BLOCK NO := 0
 INY  ;Y:=ARGI
 LDAIM  1
 STAIY NEWARG
 INY
 LDAIM  0
 STAIY NEWARG ;NO OF BLOCKS TO BE LOADED := 1
 JSR STRMAN
 BNE DELCKZ
 LDYIM ARGB
 LDAIY NEWARG
 STA GENPTR
 INY
 LDAIY NEWARG
 STA GENPTR + 1 ;GENPTR:=STORE ADDRESS OF LOADED DIR
 LDYIM DRFRST ;PTR TO FIRST DIR ENTRY IN USE
 LDAIY GENPTR
 INY
 ORAIY GENPTR
 PHA  ;PUSH A
 LDYIM ARGA
 LDAIM  4
 STAIY NEWARG
 JSR STRMAN ;STRMAN.FLUSH WINDOW
 BEQ DELCKQ
 TAX
 PLA
 TXA
 BNE DELCKZ
DELCKQ PLA
 BEQ DELCKZ
 LDAIM DRERRJ
DELCKZ RTS

FREECH JSR SETFRE
 LDYIM  0 ;RTN TO PLACE ENTRY ON FREE CHAIN
 LDAIY DIRFRE
 STAIY CRNTEN
 INY
 LDAIY DIRFRE
 STAIY CRNTEN ;[CRNTEN] := [FREE ENTRY PTR]

 SEC  ;CALC RELATIVE ADDRESS OF CRNTEN
 LDA CRNTEN
 SBC DIRSTA
 LDYIM  0
 STAIY DIRFRE
 LDA CRNTEN + 1
 SBC DIRSTA + 1
 INY
 STAIY DIRFRE ;[DIRFRE] := DIR ENTRY
 RTS

SETDSN LDYIM ARGB ;PUT DISC NO & OBJSIN ON NEWARG STACK
 LDA DRDISC
 STAIY NEWARG
 INY
 LDA DRDISC + 1
 STAIY NEWARG
 INY
 LDA OBJSIN
 STAIY NEWARG
 INY
 LDA OBJSIN + 1
 STAIY NEWARG
 INY
 LDA OBJSIN + 2
 STAIY NEWARG
 RTS

ARGDSN LDYIM ARGB ;PLACE DISC NO & OBJSIN ON ARGPTR STACK
 LDA DRDISC
 STAIY ARGPTR
 INY
 LDA DRDISC + 1
 STAIY ARGPTR
 INY
 LDA OBJSIN
 STAIY ARGPTR
 INY
 LDA OBJSIN + 1
 STAIY ARGPTR
 INY
 LDA OBJSIN + 2
 STAIY ARGPTR
 RTS

CRNSIN LDYIM DRSIN ;OBJSIN := SIN OF CRNTEN
 LDAIY CRNTEN
 STA OBJSIN
 INY
 LDAIY CRNTEN
 STA OBJSIN + 1
 INY
 LDAIY CRNTEN
 STA OBJSIN + 2
 RTS

SINSZE LDYIM ARGA ;CALL MAPMAN.SIZE FOR OBJSIN
 LDAIM  5 ;MAPMAN.SIZEINF
 STAIY NEWARG
 JSR SETDSN
 JMP MAPMAN

RETDSZ LDYIM INFDIS ;MOVE DISC NO & SIZE INTO INFPTR
 LDA DRDISC
 STAIY INFPTR
 INY
 LDA DRDISC + 1
 STAIY INFPTR
 JSR SINSZE
 PHA ;Record MAPMAN return code
 LDYIM ARGB ;MOVE SIZE ON NEWARG STACK TO INFPTR
 LDAIY NEWARG
 LDYIM INFSZE
 STAIY INFPTR
 LDYIM ARGC
 LDAIY NEWARG
 LDYIM INFSZE + 1
 STAIY INFPTR
 LDYIM ARGD
 LDAIY NEWARG
 LDYIM INFSZE + 2
 STAIY INFPTR ;MS(SIZE)
 PLA ;Restore MAPMAN return code
 RTS

TSROOT LDYIM  0 ;TEST FOR <root>
 LDAIY NAMPTR
 CMPIM ROOT
 RTS


TSTROT JSR TSROOT ;TEST FOR <root><terminator>
 BNE TSTRTZ
 INY
 LDAIY NAMPTR
 CMPIM TERMIN
TSTRTZ RTS

TSTOWN LDA DIRACC ;TEST FOR OWNER ACCESS
 ANDIM OWNER
 CMPIM OWNER
 BEQ TSTONZ
 LDAIM DRERRE ;INSUFFICIENT ACCESS
TSTONZ RTS

SETGEN LDA DIRSTA ;GENPTR := [DIRSTA]
 STA GENPTR
 LDA DIRSTA + 1
 STA GENPTR + 1
 RTS

;OUTPUT LOAD AND EXECUTE ADDRESSES
;FOR THE CURRENT ENTRY.

OUTLEX LDYIM DRLOAD
 JSR OUTHEX
 JSR OUTSP
 LDYIM DREXEC
 JSR OUTHEX
 LDXIM  3
 JMP OUTSPS ;SPACE AND EXIT

 LNK UADE0E
