 OPT UADE0D ;FILE > Uade0D
 TTL File server file UADE0D

;********************************
;*       DIRMAN UTILITIES       *
;********************************

;******** GETDIR ROUTINE *********

;GETDIR: LOADS THE DIRECTORY SPECIFIED BY A FILE TITLE.

;EXIT: A = RC
;DIRSTA = ADDR OF DIR IN MEMORY

;IF TITLE = <root><terminator> OR
;TITLE = <terminator>
;THEN load 'current dir' #set by INITDV#
;ELSE call RETENT #retrieve entry#
;check that entry is for a directory
;DIRSIN := SIN of current entry
;load new current directory
;FI

;NOTE that GETDIR in cases where an error occurs
;will UNLOCK anything that it loaded.

 [ 1=0
GETDIR
 LDAIM 0
 STA DIRFLG
 ]
GETDRD ROUT
 JSR TSTROT ;<root>$<terminator>?
 BEQ #50
 JSR TSTERM ;<terminator>$?
 BEQ #50

 INY ;**20/5/87** test pseudo-directory
 LDAIY NAMPTR
 DEY
 CMPIM TERMIN ;**20/5/87** single char only
 BNE #20
 LDAIY NAMPTR
 JSR Testpd
 BEQ #50

20 BIT DIRFLG
 BMI #30
 JSR RETENT
 JMP #40

30 JSR RETEND
40 BNE #60
 JSR Tsparn ;See if it is parent
 BEQ #45
 JSR TSTDIR ;SEE IF ITS A DIR-TSTDIR WILL UNLOCK IF REQD.
 BNE #60
 JSR SETSIN
45 JSR UNLOCK
50 JSR LOADDR ;Unlocked if any error
60 RTS

;CHKTIT: CHECKS THE SYNTAX OF A FILE TITLE.
;ENTRY: NAMPTR => PTR TO FILE TITLE,
;TO BE RECOGNISED.

;EXIT : A = RC (0=>SUCCESS)
;LASTNM => ADDRESS OF THE LAST
;TEXT NAME IN THE FILE TITLE.

;<file title>::=$<title component>|<file name>
;<file name)::= <text name><title component>
;<title component>::=<terminator>|<separator><file name>

CHKTIT ROUT
 LDA DIRWC
 ANDIM &C3
 STA DIRWC ;top bits only
 LDYIM 0 ;Y:=PTR TO CHAR
 STY DIRTMP ;counter for loop here
 JSR SETLST ;SETUP LASTNM
 LDAIY NAMPTR
 CMPIM ROOT
 BEQ #00 ;**20/5/87** check pseudo-directories also
 JSR Testpd
 BNE #20 ;SEE IF ITS A <file name>
00 INY
 LDAIY NAMPTR
 CMPIM SEPART ;IS IT A <separator>
 BEQ #10
 CMPIM TERMIN ;IS IT A <terminator>
 BEQ #40
 BNE #55 ;RC:=INVALID SEPARATOR

;TRY TO RECOGNISE <file name>

10 INY
20 STY DIRTMP+1 ;save offset
 JSR SETLST ;SETUP LASTNM
30 JSR CHKTEX ;RECOGNISE <text name>
 BNE #60
 LDAIY NAMPTR
 CMPIM TERMIN
 BNE #50

 INC DIRTMP
 LDX DIRTMP
 CPXIM 2
 BEQ #40 ;match here

 LDA DIRWC ;last level here
 ANDIM &3F
 BIT DIRWC
 BVC #35
 ORAIM &80
35 STA DIRWC
 LDY DIRTMP+1 ;restore Y
 JMP #30 ;do loop again

40 LDAIM 0 ;RC := 0
 RTS

50 CMPIM SEPART
 BEQ #10
55 LDAIM DRERRA
60 RTS

;CHKTEX: RTN TO RECOGNISE <text name>

CHKTEX ROUT
 LDXIM NAMLNT ;X:=MAX NO. OF CHARS IN <text name>
10 LDAIY NAMPTR
 CMPIM &21
 BCC #40
 CMPIM &7F
 BCS #40 ;Nope => error

 BIT DIRWC
 BPL #20
 CMPIM "*"
 BEQ #30
 CMPIM "#"
 BEQ #30

20 CMPIM """" ;** 21/9/83 **
 BEQ #40
 CMPIM ":"
 BEQ #40
 CMPIM "*"
 BEQ #40
 CMPIM "."
 BEQ #40
 CMPIM ":"
 BEQ #40
 CMPIM "#"
 BEQ #40 ;Nope => error
 CMPIM "$"
 BEQ #40 ;** 18/9/84 **

30 INY
 DEX
 BNE #10
40 LDAIM 0
 CPXIM NAMLNT ;TEST LENGTH OF <text name>
 BNE #50
 LDAIM DRERRA ;INVALID TEXT NAME
50 TAX  ;SET FLAGS
 RTS

SETLST ROUT
 TYA  ;RTN TO SETUP LASTNM
 CLC
 ADC NAMPTR
 STA LASTNM
 LDA NAMPTR+1
 ADCIM 0
 STA LASTNM+1
 RTS

;FNDTEX: SEARCH CUR DIR FOR NAME IN TXTNAM.
;N.B. DIR ENTRIES ARE SORTED,
;KEY=<file title>.

;ENTRY: DIRSTA=STORE ADDR OF DIR TO BE SEARCHED.

;EXIT : A=0 => NAME FOUND
;PREVEN => PTR TO PREVIOUS ENTRY
;CRNTEN => PTR TO CURRENT ENTRY

FNDTEX ROUT
 JSR INTPRE ;PREVEN := addr of 1st entry
 LDAIM 0
 STA WILD1 ;flag for wild cards
10 JSR SETCRN
 BEQ #30 ;end of dir ?
 LDYIM DRTITL
 LDXIM 0
 
 JSR #50 ;look up name with wild cards
 BCS #40
 PHP
 LDA WILD1
 BNE #15
 PLP
 BMI #30
 PHP
15 PLP
FNDTEZ JSR MOVCRN
 JMP #10 ;repeat until end

30 LDAIM DRERRC
 RTS

40 LDAIM 0
 RTS ;exit ok

50 LDAAX TXTNAM
 CMPIM "*"
 BNE #80
 INC WILD1
 INX
60 TXA
 PHA
 TYA
 PHA
 JSR #50
 PLA
 TAY
 PLA
 TAX
 BCS #95
 INY
 CPYIM 12
 BCC #60

70 LDAAX TXTNAM
 CMPIM &20
 BEQ #95
 CMPIM &0D
 BEQ #95
 CPXIM 10 ;returns C=1 at end-of-name
 RTS

80 CPYIM 12
 BCS #70
 JSR CPCHAR
 BNE #90
 INX
 INY
 BNE #50

90 CLC
95 RTS

CPCHAR ROUT
 CMPIM "#"
 BEQ #10
 JSR CAPS
 PHA
 LDAIY CRNTEN
 JSR CAPS
 STA WILD2
 PLA
 CMP WILD2
 RTS

10 INC WILD1 ;set flag
 LDAIY CRNTEN ;must NOT match a space
 CMPIM SPACE
 PHP
 PLA
 EORIM 2 ;flip Z flag
 PHA
 PLP ;return Z=1 if not a space
 RTS

CAPS ROUT
 STA WILD2
 CMPIM "A"
 BCC #10
 CMPIM "z"+1
 BCS #10
 CMPIM "Z"+1
 BCC #30
 CMPIM "a"
 BCS #20
10 SEC
 BCS #30

20 CLC
30 LDAIM &F9
 RORA
 RORA
 RORA
 AND WILD2
 RTS

INTPRE LDA DIRSTA ;PREVEN := DIRSTA
 STA PREVEN
 LDA DIRSTA+1
 STA PREVEN+1
 RTS

MOVCRN LDA CRNTEN ;PREVEN := CRNTEN
 STA PREVEN
 LDA CRNTEN+1
 STA PREVEN+1
 RTS

SETCRN CLC  ;RTN TO SETUP CRNTEN (CURRENT ENTRY) PTR
 LDYIM DRLINK
 LDAIY PREVEN
 ADC DIRSTA
 STA CRNTEN
 INY
 LDAIY PREVEN
 ADC DIRSTA+1
 STA CRNTEN+1
 LDYIM 0
 LDAIY PREVEN
 INY
 ORAIY PREVEN ;IF [PREVEN] = 0 THEN A:=0
 RTS

;INITDV: INITIALISES SEVERAL DIRMAN VARIABLES.

;ENTRY:
;ARGB-C PTR TO USERINFO
;ARGD-E PTR TO FILE TITLE

;FUNCTION:-

;DRUSIN => PTR TO USERINFO
;MCNUMB => MACHINE NO OF CALLER
;NAMPTR => PTR TO FILE TITLE
;DRDISC => SELECTED DISC NUMBER
;DIRACC => IF CHAR[0] OF FILE TITLE = ROOT
; THEN IF SYST PRIVILEGED
; THEN OWNER ACCESS
; ELSE ANYBODY ACCESS
; FI
; ELIF CHAR[0] OF FILE TITLE = "^"
; THEN ACCESS OF PARENT DIRECTORY
; ELIF CHAR[0] OF FILE TITLE = "&"
; THEN OWNDER ACCESS
; ELIF CHAR[0] OF FILE TITLE = "%"
; THEN CURRENT ACCESS TO LIBRARY DIRECTORY
; ELSE ACCESS TO CURRENTLY SELECTED DIR
; FI ! TYPDIR

;DIRSIN => IF DISC NAME PRESENT
; THEN SIN OF ROOT DIRECTORY ON NAMED DISC
; ELIF CHAR[0] OF FILE TITLE = ROOT
; THEN SIN OF ROOT DIRECTORY
; ELIF CHAR[0] OF FILE TITLE = "^"
; THEN SIN OF PARENT DIRECTORY
; ELIF CHAR[0] OF FILE TITLE = "&"
; THEN SIN OF UFD
; ELIF CHAR[0] OF FILE TITLE = "%"
; THEN SIN OF LIBRARY
; ELSE SIN OF CURRENTLY SELECTED DIR
; FI
;TDATE  => IF ROOT DIR IMPLIED
; THEN DATE ROOT DIR CREATED (SEE MAPTB)
; FI
;DIRSTT := 0 START BLK NO

;EXIT: A = RC

INITDV ROUT
 LDYIM ARGB
 LDAIY ARGPTR
 STA DRUSIN
 INY
 LDAIY ARGPTR
 STA DRUSIN+1 ;DRUSIN:=PTR TO USER INFO

 INY
 LDAIY ARGPTR
 STA NAMPTR
 INY
 LDAIY ARGPTR
 STA NAMPTR+1 ;NAMPTR := PTR TO FILE TITLE

 LDYIM UTMCNO
 LDAIY DRUSIN
 STA MCNUMB
 INY
 LDAIY DRUSIN
 STA MCNUMB+1
 INY
 LDAIY DRUSIN ;**25/12/86**
 STA MCNUMB+2 ;MCNUMB := MACHINE NO OF CALLER

;PRECEEDED BY A DISC NAME?

 LDYIM 0
 LDAIY NAMPTR
 CMPIM DISCIN ;DISC NAME PRESENT??
 BEQ #00
 JMP #60

00 LDXIM DNAMLN ;X:=MAX LENGTH OF DISC NAME
 LDAIM :LSB:DRDSNM
 STA MOVTO
 LDAIM :MSB:DRDSNM
 STA MOVTO+1 ;MOVTO:=PTR TO DRDSNM BUFFER

 INC NAMPTR
 BNE #05
 INC NAMPTR+1 ;NAMPTR+:=1

05 LDAIY NAMPTR
10 STAIY MOVTO ;COPY DISC NAME INTO DRDSNM
 CMPIM TERMIN ;TERMINATOR?
 BEQ #40
 CMPIM SEPART ;SEPARATOR?
 BNE #20
 LDAIM TERMIN
 STAIY MOVTO ;TERMINATE DISC NAME
 INY
 LDAIY NAMPTR ;**20/5/87** disc name, must prohibit "^","&", "%"
 CMPIM "^" ;**20/5/87** as these have a disc name implied
 [ Pseudods = Yes
 BEQ #15
 CMPIM "&"
 BEQ #15
 CMPIM "%"
 ]
 BNE #40
15 INY
 LDAIY NAMPTR ;**20/5/87** check single char names only
 DEY
 CMPIM TERMIN
 BEQ #22
 CMPIM SEPART
 BEQ #22
 BNE #40

20 INY
 LDAIY NAMPTR
 DEX
 BNE #10
 LDAIM TERMIN
 STAIY MOVTO ;TERMINATE DISC NAME
 LDAIY NAMPTR
 CMPIM TERMIN
 BEQ #40
 CMPIM SEPART
 BEQ #30
22 LDAIM DRERRA ;BAD FILE TITLE
25 RTS

30 INY
40 CLC
 TYA
 ADC NAMPTR
 STA NAMPTR
 BCC #50
 INC NAMPTR+1 ;NAMPTR:=PTR TO FILE TITLE

;GET DISC NUMBER OF NAMED DISC

50 LDAIM &A
 JSR SETRTN
 INY
 LDAIM :LSB:DRDSNM
 STAIY NEWARG
 INY
 LDAIM :MSB:DRDSNM
 STAIY NEWARG ;PTR TO DISC NAME
 JSR MAPMAN ;MAPMAN.DISCNAME->DISCNUMB
 BNE #25
 LDYIM ARGB
 LDAIY NEWARG
 STA DRDISC
 INY
 LDAIY NEWARG
 STA DRDISC+1
 JMP #65

;WAS ROOT DIR SPECIFIED

60 JSR TSROOT ;IS ROOT DIR SPECIFIED?
 BNE #75
 LDYIM UTDISC
 LDAIY DRUSIN
 STA DRDISC
 INY
 LDAIY DRUSIN
 STA DRDISC+1 ;DRDISC:=SELECTED DISC NUMBER
65 LDAIM ANYBDY+TYPDIR
 STA DIRACC ;DIRACC:=ANYBDY!TYPDIR
 LDYIM UTPRIV
 LDAIY DRUSIN
 ANDIM SYSTPV
 BEQ #70
 LDAIM OWNER+TYPDIR
 STA DIRACC ;DIRACC:=OWNER!TYPDIR

;GET SIN OF ROOT ON SELECTED DISC

70 LDAIM 4 ;(SIN OF ROOT)
 JSR SETDSA ;PLACE DISC NO ON NEWARG STACK
 JSR MAPMAN ;CALL MAPMAN.SINOFROOT
 BNE #84
 LDYIM ARGB
 LDAIY NEWARG
 STA DIRSIN
 INY
 LDAIY NEWARG
 STA DIRSIN+1
 INY
 LDAIY NEWARG
 STA DIRSIN+2 ;DIRSIN:=SIN OF ROOT
 INY
 LDAIY NEWARG
 STA TDATE ;TDATE:=DATE OF ROOT
 INY
 LDAIY NEWARG
 STA TDATE+1
 JMP #82

;LOOK UP ACCESS, DISC NUMBER, & SIN OF SELECTED DIR

 [ Pseudods = Yes
72 LDA UMHUFD ;**20/5/87** "&", get ufd
 JMP #78

74 LDA UMHLIB ;**20/5/87** "%", get lib
 JMP #78
 ]
  
75 INY ;**20/5/87** check pseudo-directory names
 LDAIY NAMPTR ;**20/5/87** single char only
 CMPIM SEPART
 BEQ #76
 CMPIM TERMIN
 BNE #77
76 DEY
 LDAIY NAMPTR
 CMPIM "^" ;**20/5/87** parent directory
 BEQ #85
 [ Pseudods = Yes
 CMPIM "&" ;**20/5/87** ufd
 BEQ #72
 CMPIM "%" ;**20/5/87** lib
 BEQ #74
 ]
77 LDYIM UTHSLD ;OFFSET OF HANDLE FOR SELECTED DIR
 LDAIY DRUSIN ;A:=HANDLE FOR SELECTED DIR
78 JSR FNDHND ;FIND HANDLE IN HANDTB
 BNE #84

 LDYIM HTACC ;check that its a dir
 LDAIY HNDPTR
 ANDIM TYPDIR
 BNE #80
 LDAIM DRERRD ;OBJECT NOT A DIR
 RTS

80 CLC
 LDA HNDPTR ;HNDPTR SETUP BY FNDHND
 ADCIM HTACC
 STA MOVFRM
 LDA HNDPTR+1
 ADCIM 0
 STA MOVFRM+1
 LDAIM :LSB:DIRACC
 STA MOVTO
 LDAIM :MSB:DIRACC
 STA MOVTO+1
 LDXIM 6 ;DIRACC,DRDISC,DIRSIN
 JSR MOVE ;COPY INFO FROM HANDTB INTO DIRMAN VARIABLES

82 LDAIM 0
 STA DIRSTT
 STA DIRSTT+1 ;DIRSTT:=0
84 RTS

85 JSR #77 ;**20/5/87** initialise to current directory
 LDYIM UTDISC
 LDAIY DRUSIN
 STA DRDISC
 INY
 LDAIY DRUSIN
 STA DRDISC+1
 JSR RETPAR ;**20/5/87** retrieve parent
 BNE #84
 JSR UNLOCK
 BEQ #82

LDDR ROUT
 LDAIM 5
 JSR SETRTN
 JSR SETDIR
 JSR MAPMAN ;MAPMAN.SIZEINFO
 BNE #10
 LDYIM ARGB
 LDAIY NEWARG
 STA DIRSZE
 INY
 LDAIY NEWARG
 STA DIRSZE+1 ;DIRSZE:=SIZE OF DIR IN BYTE
 INY
 LDAIY NEWARG
 STA DIRSZE+2
 INY
 LDAIY NEWARG
 STA DIRBKS
 INY
 LDAIY NEWARG
 STA DIRBKS+1 ;DIRBKS:=NO OF BLOCKS USED BY DIR
 LDAIM 0
 STA DIRSTT
 STA DIRSTT+1 ;DIRSTT:=0(START ADDR IN DIR)
 JSR SETDIR
 LDAIM 1
 JSR SETRTN ;STRMAN.DISC ADDR TO STORE ADDR
 JSR STRMAN
 BNE #10
 LDYIM ARGB
 LDAIY NEWARG
 STA DIRSTA
 STA DPTRLD
 INY
 LDAIY NEWARG
 STA DIRSTA+1
 STA DPTRLD+1 ;DPTRLD:=PTR TO 1ST BYTE OF DIR
 LDAIM 0 ;RC:=0
10 RTS

; Load directory.  It will be locked if return code is zero, unlocked if not.

LOADDR ROUT
 JSR LDDR ;TRY AND LOAD THE DIR
 BNE #20

;SEE IF LEADING AND TRAILING SEQUENCE NUMBERS MATCH
;IN THE PROCESS SETUP DPTRTR (PTR TO LAST BYTE OF DIR)

 LDYIM DRSQNO
 LDAIY DPTRLD
 TAX  ;X:=LEADING SQ. NO.
 SEC
 LDA DPTRLD
 SBCIM 1
 STA DPTRTR
 LDA DPTRLD+1
 SBCIM 0
 STA DPTRTR+1 ;DPTRTR:=DPTRLD-1
 CLC
 LDA DPTRTR
 ADC DIRSZE
 STA DPTRTR
 LDA DPTRTR+1
 ADC DIRSZE+1
 STA DPTRTR+1 ;DPTRTR:=PTR TO LAST BYTE OF DIR
 TXA
 LDYIM 0
 CMPIY DPTRTR ;A:=TRAILING SQ. NO.
 BEQ #10
 LDAIM DRERRB ;BROKEN DIR
 JMP UNLOCK ;Unlock and return **25/12/86**

10 LDYIM ARGA
 LDAIY NEWARG ;RC
20 RTS

SETDIR LDAIM :LSB:DRDISC ;MOVE DISC NO->DIRBKS ONTO NEWARG STACK
 STA MOVFRM
 LDAIM :MSB:DRDISC
 STA MOVFRM+1
 CLC
 LDA NEWARG
 ADCIM ARGB
 STA MOVTO
 LDA NEWARG+1
 ADCIM 0
 STA MOVTO+1
 LDXIM 9
 JMP MOVE

STAARG LDA DIRSTA ;MOVE DIRSTA ONTO ARG STACK FOR STRMAN
 LDYIM ARGB
 STAIY NEWARG
 STA GENPTR ;SETUP GENPTR FOR MRKDRT RTN
 LDA DIRSTA+1
 INY
 STAIY NEWARG
 STA GENPTR+1
 RTS

UNLOCK ROUT
 PHA
 LDAIM 3 ;CALL STRMAN.UNLOCK
 JSR SETRTN
 JSR STAARG
 JSR STRMAN
 BEQ #10
 JSR INTERR
10 PLA
 RTS

ENSRIT LDAIM 2 ;CALL STRMAN.ENSURE FOR DIR
 JSR SETRTN
 JSR STAARG
 JSR MRKDRT
 LDYIM ARGD
 LDAIM UNLKIT
 STAIY NEWARG ;ENSURE AND UNLOCK THE OBJECT

;NOW INC SEQ. NOS.

 LDYIM DRSQNO
 LDAIY DPTRLD
 TAX
 INX
 TXA ;A:=NEW SQ NO
 STAIY DPTRLD ;1ST SQ NO
 LDYIM 0
 STAIY DPTRTR ;LST SQ NO

 JMP STRMAN


;RETDIR: RETRIEVE DIR BEFORE LAST COMPONENT OF FILE TITLE.

;EXIT: A = RC
;NAMPTR = PTR TO LAST TEXT NAME.
;DIRSTA = ADDR OF DIR IN MEMORY

;FUNCTION: IF SYNTAX OF FILE TITLE OK
;THEN RETRIEVE PENULTIMATE DIR
;FI

RETDIR ROUT
 JSR CHKTIT ;CHECK SYNTAX OF FILE TITLE
 BNE #70

;attempts to delete "$" fail in eyecatching manner
;**20/5/87** and "^", "&", "%" and "@" too!

 JSR ISLAST ;**23/1/87** check if name is last
 BNE #10
 JSR TSTROT ;look for ROOT here
 BEQ #02
 JSR TESTPD ;**20/5/87** check pseudo-directories also
 BNE #10
 JSR TSTTER
 BNE #10
02 LDAIM DRERRC ;'not found', well it cant be can it !
05 RTS ;exit with error

10 JSR LOADDR ;LOAD CURRENT DIR
 BNE #05 ;Fail, return (dir not locked **25/12/86**)

;IF THE FIRST NAME=ROOT or "^" or "$" or "%" or "@"
;THEN WE HAVE TO ADJUST NAMPTR

 JSR TSROOT ;SEE IF FIRST NAME COMPONENT=ROOT
 BEQ #15
 JSR Testpd ;**20/5/87** or pseudo-directory
 BNE #20
 INY
 LDAIY NAMPTR
 CMPIM SEPART ;**20/5/87** must be single char
 BNE #20
15 CLC
 LDA NAMPTR
 ADCIM 2
 STA NAMPTR
 BCC #20
 INC NAMPTR+1 ;NAMPTR+:=2

20 JSR ISLAST ;Check if last text name
 BEQ #60

;COPY NEXT TEXT NAME COMPONENT INTO TXTNAM
;& MOVE NAMPTR TO NEXT COMPONENT

 JSR LOADTX

 JSR Tsparn ;**2/6/87** test for parent "^"
 BNE #30
 JSR Unlock
 JSR Retpar ;**2/6/87** retrieve parent
 BEQ #20
 RTS

;CHECK DIR EXISTS

30 JSR FNDTEX ;SEARCH DIR FOR TEXT NAME
 BNE #45

;FIRST CHECK THAT ITS A DIR

40 JSR ISDIR
 BEQ #50 
 JSR FNDTEZ ;try on next match
 BEQ #40
45 JMP UNLOCK ;unlock the entry

;NOW PREPARE FOR NEXT DIR TO BE LOADED, AND
;UNLOCK THE CURRENT ONE

50 JSR SETSIN ;DIRSIN := SIN OF NEXT DIR TO BE LOADED
55 JSR UNLOCK ;UNLOCK CURRENT DIR
 JSR LOADDR ;**2/6/87** load next directory
 BNE #70
 BEQ #20

60 LDAIM 0
70 RTS

ISDIR LDYIM DRACCS
 LDAIY CRNTEN ;check type found
 ANDIM TYPDIR
 CMPIM TYPDIR
 RTS

ISLAST ROUT ;Test if name is last
 LDA NAMPTR
 CMP LASTNM
 BNE #10
 LDA NAMPTR+1
 CMP LASTNM+1
10 RTS ;Exit with Z set correctly

RETENT ROUT
 JSR RETDIR ;FIND APPROPRIATE DIR
 BNE #10
 JSR LOADTX ;COPY LAST TEXTNAME INTO TXTNAM
 LDAIM &02 ;**2/6/87** is "^" allowed?
 BIT Dirwc
 BEQ #00
 JSR Tsparn ;**2/6/87** test for parent "^"
 BNE #00
 JSR Unlock
 JMP Retpar

00 JSR FNDTEX ;SEARCH FOR LAST TEXT NAME
 BEQ #10
05 JSR UNLOCK
10 RTS

RETEND JSR RETENT ;**20/5/87**
 BNE #10
 JSR Tsparn ;**8/8/87** test for parent "^"
 BEQ #10
20 JSR ISDIR
 BEQ #10
 JSR FNDTEZ
 BEQ #20
 BNE #05

Tsparn ROUT ;**1/6/87**
 LDA TXTNAM ;**1/6/87** test for parent "^"
 CMPIM "^"
 BNE Tspax
 LDA TXTNAM+1
 CMPIM &20
Tspax RTS

; Retrieve parent directory **23/1/87**

RETPAR ;ROUT
 LDYIM UTPRIV
 LDAIY DRUSIN ;A:=HANDLE FOR SELECTED DIR
 ANDIM &40
 BNE #20
 LDA UMHUFD
 JSR FNDHND ;FIND HANDLE IN HANDTB
 BNE #60 ; D0 51
 LDAIM :LSB:DRDISC ; A9 BA
 STA MOVFRM ; 85 22
 LDAIM :MSB:DRDISC ; A9 8A
 STA MOVFRM+1 ; 85 23
 CLC ; 18
 LDA HNDPTR
 ADCIM 5
 STA MOVTO
 LDA HNDPTR+1
 ADCIM 0
 STA MOVTO+1
 LDXIM 5
 JSR COMPAR
 BNE #20
 LDAIM " "
 STA DIRACC
20 JSR LOADDR ;**23/1/87** load current directory
 BNE Tspax


 LDYIM DRSTAR+DRLINK ;**23/1/87** special unchained entry?
 LDAIM &FF
 CMPIY DPTRLD
 BNE #60
 INY
 CMPIY DPTRLD
 BNE #60
 LDYIM DRSTAR+DRSIN ;**23/1/87** extract parent SIN only
 LDAIY DPTRLD
 STA DIRSIN
 INY
 LDAIY DPTRLD
 STA DIRSIN+1
 INY
 LDAIY DPTRLD
 STA DIRSIN+2
 JSR UNLOCK ;release current directory

 JSR LOADDR ;load parent directory
 BNE Tspax
 LDAIM 0
 RTS

60 LDAIM DRERRC ;parent not found
70 JMP UNLOCK ;unlock and exit


TSTDIR ROUT
 JSR ISDIR ;Test CRNTEN for directory
 BEQ #10
 JSR UNLOCK ;UNLOCK CURRENT DIR IF ENTRY NOT FOR A DIR
 LDAIM DRERRD ;RC := OBJECT NOT A DIR
10 RTS

SETSIN LDYIM DRSIN ;DIRSIN := SIN OF CRNTEN
 LDAIY CRNTEN
 STA DIRSIN
 INY
 LDAIY CRNTEN
 STA DIRSIN+1
 INY
 LDAIY CRNTEN
 STA DIRSIN+2
 RTS

;MAXACC: CALC ACCESS TO A PARTICULAR DIR ENTRY
;EXIT: A:=OBJACC:= TYPE & MAX ACCESS TO OBJECT

MAXACC ROUT
 LDYIM DRACCS
 LDAIY CRNTEN
 ANDIM TLAMSK
 STA OBJACC ;OBJACC:=TYPE & ACCESS SPECIFIED IN DIR ENTRY
 ANDIM TYPDIR
 BEQ #10

;ITS A DIR SO OBJACC := TYPDIR!DIRACC

 LDA DIRACC
 ANDIM OWNER ;** 30/9/84 **
 ORA OBJACC
 JMP #30

;ITS A FILE SO
;IF (DIRACC & OWNER) = OWNER
;THEN TYPFIL!((OBJACC SHR 2)&RDWRACC)!(OBJACC&RDWRAC)
;ELSE TYPFIL ! (OBJACC & RDWRAC)
;FI

10 LDA DIRACC
 ANDIM OWNER
 BEQ #20 ;BRANCH IF ANYBODY

;OWNER ACCESS

 LDA OBJACC
 LSRA
 LSRA
 ANDIM RDWRAC
 TAX  ;X:= A & RDWRAC
 LDA OBJACC
 ANDIM LOCKED ;** 28/3/85 **
 STA OBJACC
 TXA
 ORA OBJACC
 JMP #30

;ANYBODY ACCESS

20 LDA OBJACC
 ANDIM RWLACC ;ANYBODY ACCESS
30 STA OBJACC
 LDA DIRACC
 ANDIM OWNER
 ORA OBJACC ;Include owner bit in result
 STA OBJACC
 RTS

LOADTX ROUT
 LDAIM :LSB:TXTNAM ;MOVE TEXT NAME INTO TXTNAM
 STA TXTPTR
 LDAIM :MSB:TXTNAM
 STA TXTPTR+1
 LDYIM  0
10 LDAIY NAMPTR
 CMPIM TERMIN
 BEQ #20
 CMPIM SEPART
 BEQ #20
 STAIY TXTPTR ;MOVE CHAR INTO TXTNAM
 INY
 JMP #10

;MAKE NAMPTR PT TO 1ST CHAR AFTER <terminator>|<separator>

20 TYA
 SEC ;ADD 1
 ADC NAMPTR
 STA NAMPTR
 BCC #30
 INC NAMPTR+1

;FILL REMAINDER OF TXTNAM WITH SPACES

30 CPYIM NAMLNT+1 ;** 5/9/84 **
 BEQ #40
 LDAIM SPACE
 STAIY TXTPTR
 INY
 BNE #30
40 RTS

SETFRE ROUT
 CLC  ;SETUP DIRFRE (ADDR OF FREE CHAINPTR IN DIR)
 LDA DIRSTA
 ADCIM DRFREE
 STA DIRFRE
 LDA DIRSTA+1
 ADCIM 0
 STA DIRFRE+1
 LDYIM 0 ;TEST FOR [DIRFRE]=0
 LDAIY DIRFRE
 INY
 ORAIY DIRFRE ;A=0 IF NO FREE ENTRIES
 RTS

;DELCHK: RTN TO CHECK WHETHER A DIR ENTRY MAY BE DELETED

;EXIT: A = RC

;FUNCTION: IF ENTRY 'LOCKED'
;THEN ERROR (I.E. A>0)
;ELIF OBJECT OPEN
;THEN ERROR
;ELIF TYPE = TYPDIR ANDF NOT EMPTY
;THEN ERROR
;ELSE OBJECT MAY BE DELETED (I.E. A = 0)
;FI

DELCHK ROUT
 LDYIM DRACCS
 LDAIY CRNTEN
 ANDIM LOCKED
 BEQ #10
 LDAIM DRERRG
 RTS

;SAVE SIN OF OBJECT TO BE DELETED

10 JSR CRNSIN ;OBJSIN := SIN OF OBJECT

;SEE IF THE OBJECT TO BE DELETED IS OPEN

 LDAIM 2
 JSR SETDSA ;SETUP DISC NO AND SIN ON NEWARG STACK
 JSR RNDMAN ;RNDMAN.INFO
 BNE #20
 LDAIM DRERRI ;CANNOT DELETE OPENED OBJECT
 RTS

;IF IT IS DIR MAKE SURE THAT IT IS EMPTY

20 LDYIM DRACCS
 LDAIY CRNTEN
 ANDIM TYPDIR
 BEQ #50 ;Exit; A=0 and Z set

;LOAD FIRST BLOCK OF THE DIR
;TO SEE IF IT IS EMPTY

 LDAIM 1
 JSR SETDSA ;PLACE DISC NO AND SIN ON NEWARG STACK
 LDYIM ARGG
 LDAIM 0
 STAIY NEWARG ;LS
 INY
 STAIY NEWARG ;MS(BLK NO) START BLOCK NO := 0
 INY  ;Y:=ARGI
 LDAIM 1
 STAIY NEWARG
 INY
 LDAIM 0
 STAIY NEWARG ;NO OF BLOCKS TO BE LOADED := 1
 JSR STRMAN
 BNE #50
 LDYIM ARGB
 LDAIY NEWARG
 STA GENPTR
 INY
 LDAIY NEWARG
 STA GENPTR+1 ;GENPTR:=STORE ADDRESS OF LOADED DIR
 LDYIM DRFRST ;PTR TO FIRST DIR ENTRY IN USE
 LDAIY GENPTR
 INY
 ORAIY GENPTR
 PHA  ;PUSH A
 LDAIM 4
 JSR SETRTN
 JSR STRMAN ;STRMAN.FLUSH WINDOW
 BEQ #40
 TAX
 PLA
 TXA
 RTS

40 PLA
 BEQ #50
 LDAIM DRERRJ
50 RTS

FREECH ROUT
 JSR SETFRE
 LDYIM 0 ;RTN TO PLACE ENTRY ON FREE CHAIN
 LDAIY DIRFRE
 STAIY CRNTEN
 INY
 LDAIY DIRFRE
 STAIY CRNTEN ;[CRNTEN] := [FREE ENTRY PTR]

 SEC  ;CALC RELATIVE ADDRESS OF CRNTEN
 LDA CRNTEN
 SBC DIRSTA
 LDYIM 0
 STAIY DIRFRE
 LDA CRNTEN+1
 SBC DIRSTA+1
 INY
 STAIY DIRFRE ;[DIRFRE] := DIR ENTRY
 RTS

; SETDSA: Put arg, DRDISC & OBJSIN on NEWARG stack
; SETDSN: Put just DRDISC & OBJSIN on NEWARG stack
; Exits:  Y=ARGF

SETDSA ROUT
 JSR SETRTN ;Put arg on NEWARG stack **25/12/86**
SETDSN LDYIM ARGB ;PUT DISC NO & OBJSIN ON NEWARG STACK
 LDA DRDISC
 STAIY NEWARG
 INY
 LDA DRDISC+1
 STAIY NEWARG
 INY
 LDA OBJSIN
 STAIY NEWARG
 INY
 LDA OBJSIN+1
 STAIY NEWARG
 INY
 LDA OBJSIN+2
 STAIY NEWARG
 RTS

ARGDSN LDYIM ARGB ;PLACE DISC NO & OBJSIN ON ARGPTR STACK
 LDA DRDISC
 STAIY ARGPTR
 INY
 LDA DRDISC+1
 STAIY ARGPTR
 INY
 LDA OBJSIN
 STAIY ARGPTR
 INY
 LDA OBJSIN+1
 STAIY ARGPTR
 INY
 LDA OBJSIN+2
 STAIY ARGPTR
 RTS

CRNSIN LDYIM DRSIN ;OBJSIN := SIN OF CRNTEN
 LDAIY CRNTEN
 STA OBJSIN
 INY
 LDAIY CRNTEN
 STA OBJSIN+1
 INY
 LDAIY CRNTEN
 STA OBJSIN+2
 RTS

SINSZE LDAIM 5 ;CALL MAPMAN.SIZE FOR OBJSIN
 JSR SETDSA
 JMP MAPMAN

RETDSZ LDYIM INFDIS ;MOVE DISC NO & SIZE INTO INFPTR
 LDA DRDISC
 STAIY INFPTR
 INY
 LDA DRDISC+1
 STAIY INFPTR
 JSR SINSZE
 PHA ;Record MAPMAN return code
 LDYIM ARGB ;MOVE SIZE ON NEWARG STACK TO INFPTR
 LDAIY NEWARG
 LDYIM INFSZE
 STAIY INFPTR
 LDYIM ARGC
 LDAIY NEWARG
 LDYIM INFSZE+1
 STAIY INFPTR
 LDYIM ARGD
 LDAIY NEWARG
 LDYIM INFSZE+2
 STAIY INFPTR ;MS(SIZE)
 PLA ;Restore MAPMAN return code
 RTS

TSROOT ROUT
 LDYIM 0 ;TEST FOR <root>
 LDAIY NAMPTR
 CMPIM ROOT
 RTS

TSTROT ROUT
 JSR TSROOT ;TEST FOR <root><terminator>
00 BNE #10
TSTTER INY
05 LDAIY NAMPTR
 CMPIM TERMIN
10 RTS

TSTERM LDYIM 0 ;is file title <term> omly?
 BEQ #05
                  
TSTPAR ;**23/1/87**
 LDYIM 0
 LDAIY NAMPTR
 CMPIM "^" ;check parent directory name
 JMP #00

TESTPD ROUT ;**2/6/87** test pseudo-directory name
 CMPIM "^"
 [ Pseudods = Yes
 BEQ #10
 CMPIM "&"
 BEQ #10
 CMPIM "%"
 BEQ #10
 CMPIM "@"
 ]
10 RTS

TSTOWN ROUT
 LDA DIRACC ;TEST FOR OWNER ACCESS
 ANDIM OWNER
 CMPIM OWNER
 BEQ #10
 LDAIM DRERRE ;INSUFFICIENT ACCESS
10 RTS

SETGEN LDA DIRSTA ;GENPTR := [DIRSTA]
 STA GENPTR
 LDA DIRSTA+1
 STA GENPTR+1
 RTS

;OUTPUT LOAD AND EXECUTE ADDRESSES
;FOR THE CURRENT ENTRY.

OUTLEX LDYIM DRLOAD
 JSR OUTHEX
 JSR OUTSP
 LDYIM DREXEC
 JSR OUTHEX
 LDXIM 3
 JMP OUTSPS ;SPACE AND EXIT

 LNK UADE0E
