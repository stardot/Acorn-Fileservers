 OPT UADE05 ;> Uade05
 TTL File server file UADE05


;*********************************
;*         G L O R T N           *
;*     AND  DOS  CONVERSION      *
;*********************************


;***** R N D M A N  R O U T I N E S *****


;FNDHND: SEARCHES THE HANDLE TABLE (HANDTB)
;FOR A SPECIFIED HANDLE.

;ENTRY: A = HANDLE
;MCNUMB = MACHINE NUMBER

;EXIT : A = RC
;HNDPTR - LEFT POINTING TO PARTICULAR ENTRY
;CONTAINING SPECIFIED (HANDLE,MC/NO).
;NOTE A,X,Y,RNDTMP ARE DESTROYED.


FNDHND STA RNDTMP ;RNDTMP := HANDLE
 CMPIM  0
 BNE FNDHDB
 LDAIM RDERRB ;INVALID HANDLE
 BNE FNDHDZ
FNDHDB JSR INITHD ;HNDPTR:=HANDTB;X:=HTENTS

;FIRST SEE IF MACHINE NUMBER MATCHES

FNDHDC LDYIM HTMCNO ;LSIG BYTE FIRST
 LDAIY HNDPTR
 CMP MCNUMB
 BNE FNDHDM
 INY
 LDAIY HNDPTR
 CMP MCNUMB + 1
 BNE FNDHDM

;NOW SEE IF HANDLE MATCHES

 LDYIM HTHAND
 LDA RNDTMP
 CMPIY HNDPTR
 BNE FNDHDM

;FOUND

 LDAIM  0 ;RC := 0
 BEQ FNDHDZ

FNDHDM JSR INCHND ;MOVE HNDPTR TO NEXT ENTRY,DEX
 BNE FNDHDC
 LDAIM RDERRB
FNDHDZ RTS


INITHD LDA HANDTB ;HNDPTR := HANDTB
 STA HNDPTR
 LDA HANDTB + 1
 STA HNDPTR + 1
 LDX HTENTS ;X := HTENTS
 RTS


INCHND CLC  ;HNDPTR +:= HTENSZ
 LDA HNDPTR
 ADCIM HTENSZ
 STA HNDPTR
 LDA HNDPTR + 1
 ADCIM  0
 STA HNDPTR + 1
 DEX  ;X -:= 1
 RTS



;USRMAN ROUTINES

;FINDMC: FIND A USERTB ENTRY - SEARCH
;USERTB FOR AN ENTRY CONTAINING A
;GIVEN MACHINE NUMBER.
;NOTE THAT FINDMC MAY BE CALLED
;BY ANY MODULE.
;(THIS FUNCTION WILL PROBABLY
;NEED SPEEDING UP - POSSIBLY USING
;A HASH TABLE FOR USERTB)

;ENTRY: THE VARIABLE, MCNUMB,
;SHOULD CONTAIN THE
;NUMBER OF THE MACHINE
;TO BE LOOKED UP IN USERTB.

;EXIT:  A = RC
;IF A = 0
;THEN USTPTR (PAGE ZERO) IS
;LEFT POINTING TO THE USERTB ENTRY
;FI



FINDMC JSR INITUS ;USTPTR:=USERTB,X:=UTENTS
FINDCA LDA MCNUMB ;LS(MC/NO)
 LDYIM UTMCNO
 CMPIY USTPTR
 BNE FINDCD
 INY
 LDA MCNUMB + 1
 CMPIY USTPTR
 BNE FINDCD
 LDYIM UTPRIV
 LDAIY USTPTR
 ANDIM INUSE
 BEQ FINDCD

 LDAIM  0 ;RETURN CODE
 BEQ FINDCZ

FINDCD JSR INCUST ;USTPTR+:=UTENSZ,X-:=1
 BNE FINDCA
 LDAIM URERRA ;RC:=MACHINE NOT LOGGED ON
FINDCZ RTS


INITUS LDA USERTB ;USTPTR:=USERTB,X:=USERS
 STA USTPTR
 LDA USERTB + 1
 STA USTPTR + 1
 LDX USERS
 RTS


INCUST CLC  ;USTPTR+:=UTENSZ,X-:=1
 LDA USTPTR
 ADCIM UTENSZ
 STA USTPTR
 LDA USTPTR + 1
 ADCIM  0
 STA USTPTR + 1
 DEX
 RTS


DRVINF LDYIM ARGB ;A := DRIVE NUMBER
 STAIY NEWARG
 DEY  ;Y := ARGA
 LDAIM  8 ;MAPMAN.DRIVEINFO
 STAIY NEWARG
 JMP MAPMAN



FLUDRV   ;FLUDRV

;Flushes store and ensures map for drive
;passed in A.

 JSR DRVINF ;GET DISC NO.
 BNE FLUDAB ;ABORT IF ERROR

 LDAIM  8
 JSR SETRTN
 JSR STRMAN ;*** FLUSH STORE **
 BNE FLUDAB

 LDAIM  6
 JSR SETRTN
 JSR MAPMAN ;*** ENSURE DISC **
FLUDAB RTS


FLUSYS   ;FLUSYS

;Flushes all drives in system, so it is
;safe to start from scratch !!

 LDA DRIVES
FLUSLP SEC
 SBCIM  1
 BMI FLUSEX
 PHA
 JSR FLUDRV
 BNE FLUSAB
 PLA
 JMP FLUSLP

FLUSEX LDAIM  0
 RTS
FLUSAB JSR USRERR
 PLA
 RTS

 [ 1=0

;RDBLKS   ;RDBLKS

;Read TXBYTS bytes from drive CVTDRV
;into big buffer.

;Note a disc error in this routine returns a
;DSCMAN error DCERRF. This can occur if a BRK
;occurs from the DOS routine

 TSX
 STX TSTACK ;Keep stack pointer in case of failure

 LDA BBUF
 STA DDRSTA
 LDA BBUF + 1
 STA DDRSTA + 1 ;Set start address

 LDX BPTR ;Pointer into catalogue
 LDAAX DFSECT + 1
 CLC
 ADC CURBLK
 STA DCSECT
 LDAAX DFSECT
 ANDIM &3 ;Bottom 2 bits only
 ADC CURBLK + 1
 STA DCSECT + 1

 LDA TXBYTS
 STA DDRSZE
 LDA TXBYTS + 1
 STA DDRSZE + 1

 LDA CVTDRV
 STA DRIVNO
 JSR SETDSF ;DSCMAN routine, set CSECTR/CTRACK

 JSR BLKRD

 [ DEBUG <> 0
 LDAIM "B"
 JSR TRACE
 ]

 ;JSR USBRK ;Reset BRK vector
 LDAIM &00
 RTS  ;Successful exit
 ]

 LNK UADE06
