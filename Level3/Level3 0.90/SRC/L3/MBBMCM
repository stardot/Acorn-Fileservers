 OPT MBBMCM ;> Mbbmcm
 TTL File server file MBBMCM

;
; MAP BLOCK AND BIT MAP MANAGEMENT
;
;
; INITIALISE THE MAP BLOCKS
;
; ALLOCATES CONTROL BLOCKS FOR THE BIT MAP CACHE
; AND THE MAP BLOCK CACHE
;
; USES
;    MPTMPE,MPTMPD
;
INBKMN LDYIM SZMBCB
 LDXIM /(SZMBCB )
 JSR GETVEC ;GET SPACE FOR MAP BLOCK CHACHE DESCRIPTORS
 STY MBCBPT ;SAVE POINTER TO AREA
 STX MBCBPT + 1
 LDYIM SZBMCB
 LDXIM /(SZBMCB )
 JSR GETVEC ;GET SPACE FOR BIT MAP CACHE DESCRIPTORS
 STY BMCBPT
 STX BMCBPT + 1 ;SAVE THIS POINTER
 STY GNCBPT ;SAVE FOR INITIALISATION
 STX GNCBPT + 1
 LDAIM SZBMAR ;SIZE OF MEMORY AREA FOR THESE BLOCKS
 STA MPTMPE
 LDAIM /(SZBMAR )
 STA MPTMPE + 1
 LDAIM NOBTMP ;GET NUMBER OF ENTRIES
 STA NCBDB ; AND SAVE IT
 JSR SETCBS ;INITIALISE CONTROL BLOCKS
 LDAIM SZMBAR ;SIZE OF MAP BLOCK AREA
 STA MPTMPE
 LDAIM /(SZMBAR )
 STA MPTMPE + 1
 JSR SETMB
 JSR SETCBS
 RTS
;
; SETUP MAP BLOCK OR BIT MAP CONTROL BLOCKS
;
; ON ENTRY
;     GNCBPT POINTS TO CONTROL BLOCK
;     MPTMPE HOLDS SIZE OF DISC BLOCK CACHE
;     NCBDB HOLDS NUMBER OF DISC BLOCK ENTRIES
;
SETCBS LDY MPTMPE
 LDX MPTMPE + 1 ;GET SIZE OF CACHE
 JSR GETVEC ;GET THE SPACE
 STY MPTMPE
 STX MPTMPE + 1 ; SAVE THE AREA
 LDX NCBDB ;GET NUMBER OF ENTRIES
SCBLP LDYIM CAFLG
 LDAIM  0
 STAIY GNCBPT ;ZERO ALL FLAGS
 LDYIM CBSA
 LDA MPTMPE
 STAIY GNCBPT ;SAVE ADDRESS OF STORE
 INY
 LDA MPTMPE + 1
 STAIY GNCBPT
 DEX
 BEQ SCBND ; FINISH
 CLC
 LDA MPTMPE ;INCREMENT TO NET BLOCK OF STORE
 ADCIM BTINBK
 STA MPTMPE
 LDA MPTMPE + 1
 ADCIM /(BTINBK )
 STA MPTMPE + 1
 CLC ;POINT TO NEXT CONTROL BLOCK
 LDA GNCBPT
 ADCIM CBSZ
 STA GNCBPT
 LDA GNCBPT + 1
 ADCIM  0
 STA GNCBPT + 1
 JMP SCBLP ;TRY NEXT
SCBND RTS

;
; GET BLOCK TO STORE
;
; ON ENTRY
;      CBSIN HOLDS THE DISC ADDRESS
;      GNCBPT POINTS TO RELEVANT CACHE DESCRIPTORS
;      NCBDB HOLDS NUMBER OF CONTROL BLOCK ENTRIES
;      MPDRVE HOLDS DRIVE NUMBER
;
; ON EXIT
;      CBSTA HOLDS STORE ADDRESS OF BLOCK
;
GTBTS LDA GNCBPT ;SAVE POINTER TO CONTROL BLOCKS
 PHA
 LDA GNCBPT + 1
 PHA
 JSR FNDBLK
 BCC GTSRI
GTBGT LDYIM CBSA ;IN STORE SO JUST GET ADDRES
 LDAIY GNCBPT
 STA CBSTA
 INY
 LDAIY GNCBPT
 STA CBSTA + 1
 LDYIM CBAGE
 LDAIM  0
 STAIY GNCBPT
 PLA ;RESTORE POINTER
 STA GNCBPT + 1
 PLA
 STA GNCBPT
 JSR CAAGE ;AGE ALL ENTRIES
 LDAIM  0
 RTS
GTSRI PLA ;NEED TO START AT BEGINNING AGAIN
 TAX
 PLA
 STA GNCBPT
 PHA
 STX GNCBPT + 1
 TXA
 PHA ;KEEP POINTER IN CORRECT ORDER ON STACK
 JSR GETFR ;GET A FREE POSITION
 BNE GTBND
 LDYIM CBDA
 LDA CBSIN
 STAIY GNCBPT
 INY
 LDA CBSIN + 1
 STAIY GNCBPT
 INY
 LDA CBSIN + 2
 STAIY GNCBPT
 LDYIM CBDR
 LDA MPDRVE
 STAIY GNCBPT
 JSR RDBLK ;READ IN THE NEW BLOCK
 BEQ GTSR1
 LDAIM  2 ;READ ERROR
 ORA ERRTYP
 STA ERRTYP
GTSR1 LDYIM CAFLG
 LDAIY GNCBPT
 ORAIM  1 ;FLAG IN STORE
 STAIY GNCBPT
 JMP GTBGT
GTBND RTS
;
; FIND A SPECIFIED DISC BLOCK IN STORE
;
; CBSIN HOLDS DISC ADDRESS
; MPDRVE HOLDS DRIVE NUMBER
;
; C SET IF FOUND
FNDBLK LDA GNCBPT
 PHA
 LDA GNCBPT + 1
 PHA
 LDX NCBDB ;CHECK IF ALREADY IN STORE
FBLP LDYIM CBDA
 LDAIY GNCBPT
 CMP CBSIN
 BNE FBNX
 INY
 LDAIY GNCBPT
 CMP CBSIN + 1
 BNE FBNX
 INY
 LDAIY GNCBPT
 CMP CBSIN + 2
 BNE FBNX
 LDYIM CBDR
 LDAIY GNCBPT
 CMP MPDRVE
 BEQ FBGT
FBNX DEX
 BEQ FBRI
 JSR ADGNCB
 JMP FBLP
FBGT LDYIM CAFLG ;CHECK IF IN STORE
 LDAIY GNCBPT
 ANDIM  1
 BEQ FBNX
 PLA
 PLA
 SEC
 RTS
FBRI PLA
 STA GNCBPT + 1
 PLA
 STA GNCBPT
 CLC
 RTS
;
; READ/WRITE A BLOCK INTO STORE
;
; ON ENTRY
;      GNCBPT POINTS TO ENTRY IN CACHE DESCRIPTOR
;
 [ WINCH=0
RDBLK LDAIM &08
 JMP TRBLK
WRBLK LDAIM &0A
TRBLK STA SAVCOM
 LDYIM CBDR
 LDAIY GNCBPT
 STA DRIVNO
 LDYIM CBDA
 LDAIY GNCBPT
 STA RBDA ; SAVE DISC ADDRESS
 INY
 LDAIY GNCBPT
 STA RBDA + 1
 INY
 LDAIY GNCBPT
 STA RBDA + 2
TRCLLP LDYIM MPSECS
 LDA RBDA
 CMPIY MAPPTR
 INY
 LDA RBDA + 1
 SBCIY MAPPTR
 INY
 LDA RBDA + 2
 SBCIY MAPPTR
 BCC TRBKLP
 LDYIM MPADFT
 CLC
 LDA DRIVNO
 ADCIY MAPPTR
 STA DRIVNO
 SEC
 LDYIM MPSECS
 LDA RBDA
 SBCIY MAPPTR
 STA RBDA
 INY
 LDA RBDA + 1
 SBCIY MAPPTR
 STA RBDA + 1
 INY
 LDA RBDA + 2
 SBCIY MAPPTR
 STA RBDA + 2
 JMP TRCLLP
TRBKLP LDYIM CBSA
 LDAIY GNCBPT
 STA DCSTAD
 INY
 LDAIY GNCBPT
 STA DCSTAD + 1
 LDAIM  0
 STA DSCCB+TRADD+ 2
 STA DSCCB+TRADD+ 3
 LDYIM CAFLG ;MARK NOT WRITTEN
 LDAIY GNCBPT
 ANDIM  3
 STAIY GNCBPT
 LDA RBDA
 ORA RBDA +1
 ORA RBDA +2 ;IF SECTOR ZERO CALCULATE CHECKSUM
 BNE TRXFR
 LDA GNCBPT
 PHA
 LDA GNCBPT +1
 PHA
 LDA DCSTAD
 STA GNCBPT
 LDA DCSTAD +1
 STA GNCBPT +1
 LDYIM &FF
 TYA
 STAIY GNCBPT
 LDAIM 0
 CLC
TRCRCL ADCIY GNCBPT
 DEY
 BNE TRCRCL
 ADCIY GNCBPT
 DEY
 STAIY GNCBPT
 PLA
 STA GNCBPT +1
 PLA
 STA GNCBPT
TRXFR JSR XFER ;TRANSFER THE BLOCK
 RTS
 |
RDBLK LDAIM &53 ;VALUE FOR READ
 JMP TRBLK
WRBLK LDAIM &4B ;VALUE FOR WRITE
TRBLK STA SAVCOM ;SAVE VALUE
 LDYIM CBDR
 LDAIY GNCBPT ;GET DRIVE NUMBER
 STA DRIVNO
 LDAIM  0
 STA CTRACK ;PREPARE TO CALCULATE TRACK AND SECTOR
 STA CSECTR
 LDYIM CBDA
 LDAIY GNCBPT
 STA RBDA ; SAVE DISC ADDRESS
 INY
 LDAIY GNCBPT
 STA RBDA + 1
 INY
 LDAIY GNCBPT
 STA RBDA + 2
TRCLLP LDYIM MPSECS
 LDA RBDA
 CMPIY MAPPTR
 INY
 LDA RBDA + 1
 SBCIY MAPPTR
 INY
 LDA RBDA + 2
 SBCIY MAPPTR
 BCC TRBKLP
 LDYIM MPADFT
 CLC
 LDA DRIVNO
 ADCIY MAPPTR
 STA DRIVNO
 SEC
 LDYIM MPSECS
 LDA RBDA
 SBCIY MAPPTR
 STA RBDA
 INY
 LDA RBDA + 1
 SBCIY MAPPTR
 STA RBDA + 1
 INY
 LDA RBDA + 2
 SBCIY MAPPTR
 STA RBDA + 2
 JMP TRCLLP
TRBKLP LDYIM MPSPCY
 LDA RBDA
 CMPIY MAPPTR ; CHECK IF END REACHED
 INY
 LDA RBDA + 1
 SBCIY MAPPTR
 LDA RBDA + 2
 SBCIM  0
 BCC TRBKND ;BRANCH WHEN CORRECT PLACE
 INC CTRACK
 LDYIM MPSPCY
 SEC
 LDA RBDA
 SBCIY MAPPTR ; KEEP DECREMENTING
 STA RBDA
 INY
 LDA RBDA + 1
 SBCIY MAPPTR
 STA RBDA + 1
 LDA RBDA + 2
 SBCIM  0
 STA RBDA + 2
 JMP TRBKLP
TRBKND LDA RBDA
 STA CSECTR ; SAVE SECTOR
 LDYIM CBSA
 LDAIY GNCBPT
 STA DCSTAD
 INY
 LDAIY GNCBPT
 STA DCSTAD + 1
 LDAIM  0
 STA DSCCB+TRADD+ 2
 STA DSCCB+TRADD+ 3
 LDYIM CAFLG ;MARK NOT WRITTEN
 LDAIY GNCBPT
 ANDIM  3
 STAIY GNCBPT
 JSR XFER ;TRANSFER THE BLOCK
 RTS
 ]
;
; AGE ALL CHAIN ENTRIES
;
; ON ENTRY
;      GNCBPT POINTS TO RELEVANT CACHE DESCRIPTOR
;      NCBDB HOLDS NUMBER OF ENTRIES
;
CAAGE LDA GNCBPT
 PHA ; SAVE THE POINTER
 LDA GNCBPT + 1
 PHA
 LDX NCBDB
CBALP LDYIM CBAGE ; GET CURRENT AGE
 LDAIY GNCBPT
 ADCIM  1 ;INCREMENT
 STAIY GNCBPT
 DEX
 BEQ CBAND ;CHECK FOR END
 CLC
 LDA GNCBPT ;LOOK AT NEXT ENTRY
 ADCIM CBSZ
 STA GNCBPT
 LDA GNCBPT + 1
 ADCIM  0
 STA GNCBPT + 1
 JMP CBALP ;LOOK AT NEXT
CBAND PLA ;GET POINTER BACK
 STA GNCBPT + 1
 PLA
 STA GNCBPT
 RTS
;
; GET A FREE SPACE FOR A BLOCK
;
; ON ENTRY
;      GNCBPT POINTS TO START OF CONTROL BLOCK
;      NCBDB HOLDS NUMBER OF CONTROL BLOCK ENTRIES
;
; ON EXIT
;      GNCBPT POINTS TO VACANT ENTRY
;
; USES
;      CBSTA,CBTPPT
;
GETFR LDA GNCBPT
 PHA
 LDA GNCBPT + 1
 PHA
 LDX NCBDB
 LDAIM &FF
 STA CBSTA ;CURRENT YOUNGEST
 LDAIM  0
 STA CBTPPT ;CURRENT POINTER TO YOUNGEST
 STA CBTPPT + 1
GTYLP LDYIM CAFLG
 LDAIY GNCBPT
 ANDIM  4 ;CHECK IF WRITTEN
 BEQ GTYNX
 LDAIY GNCBPT
 ANDIM  2 ;CHECK IF LOCKED
 BNE GTYNX
 LDYIM CBAGE
 LDAIY GNCBPT
 CMP CBSTA
 BCS GTYNX
 STA CBSTA
 LDA GNCBPT
 STA CBTPPT
 LDA GNCBPT + 1
 STA CBTPPT + 1
GTYNX CLC
 LDA GNCBPT
 ADCIM CBSZ
 STA GNCBPT
 LDA GNCBPT + 1
 ADCIM  0
 STA GNCBPT + 1
 DEX
 BNE GTYLP
 LDA CBTPPT
 STA GNCBPT
 ORA CBTPPT + 1
 BEQ GTYND
 LDA CBTPPT + 1
 STA GNCBPT + 1
 JSR WRBLK
 BEQ GTYND
 LDAIM  1
 ORA ERRTYP
 STA ERRTYP
GTYND PLA
 STA GNCBPT + 1
 PLA
 STA GNCBPT
 LDX NCBDB ;NUMBER OF ENTRIES
 LDAIM  0
 STA CBSTA ;CURRENT OLDEST
 STA CBTPPT ;CURRENT POINTER TO OLDEST
 STA CBTPPT + 1
GTFLP LDYIM CAFLG
 LDAIY GNCBPT
 ANDIM  1
 BNE GTFCH
 LDXIM  1 ;FREE AREA SO FOOL INTO THINKING ITS END
 JMP GTFSP
GTFCH LDAIY GNCBPT
 ANDIM  2
 BNE GTFNX
 LDYIM CBAGE
 LDAIY GNCBPT
 CMP CBSTA
 BCC GTFNX
 STA CBSTA
GTFSP LDA GNCBPT
 STA CBTPPT
 LDA GNCBPT + 1
 STA CBTPPT + 1
GTFNX DEX
 BEQ GTFND
 CLC ;LOOK AT NEXT ENTRY
 LDA GNCBPT
 ADCIM CBSZ
 STA GNCBPT
 LDA GNCBPT + 1
 ADCIM  0
 STA GNCBPT + 1
 JMP GTFLP
GTFND LDA CBTPPT ;CHECK IF ANYTHING FOUND
 ORA CBTPPT + 1
 BEQ GTFNG
 LDA CBTPPT ;SAVE ADDRESS
 STA GNCBPT
 LDA CBTPPT + 1
 STA GNCBPT + 1
 LDYIM CAFLG ;CHECK IF ALLOCATED
 LDAIY GNCBPT 
 ANDIM  1
 BEQ GTFEND
 LDAIY GNCBPT
 ANDIM  4 ;CHECK IF IT HAS BEEN WRITTEN TO
 BEQ GTFEND
 JSR WRBLK
 BEQ GTFEND
 LDAIM  1
 ORA ERRTYP
 STA ERRTYP
GTFEND LDAIM  0
 LDYIM CAFLG
 STAIY GNCBPT
 RTS
GTFNG LDAIM MPERRM ;FLAG ERROR
 RTS
;
; SET THE WRITTEN BIT IN THE GIVEN CACHE DESCRIPTOR
; THE STORE ADDRESS IS GIVEN
;
; ON ENTRY
;     GNCBPT POINTS TO RELEVANT CACHE DESCRIPTORS
;     NCBDB  HOLDS NUMBER OF DESCRIPTORS
;     CBSTA  HOLDS STORE ADDRESS OF BLOCK
;
; ON EXIT
;     Z NON-ZERO IF FAILED
;
;
CASTWB LDX NCBDB ;GET NUMBER OF DESCRIPTORS
CSWCN LDYIM CBSA ;CHECK ADDRESS
 LDAIY GNCBPT
 CMP CBSTA
 BNE CSWSK ;GO TO CHECK NEXT
 INY
 LDAIY GNCBPT
 CMP CBSTA + 1
 BEQ CSWF
CSWSK DEX ;CHECK FOR END
 BEQ CSWNF
 JSR ADGNCB
 JMP CSWCN
CSWF LDYIM CAFLG
 LDAIY GNCBPT ;SET WRITTEN BIT
 ORAIM  4 ;WRITTEN BIT
 STAIY GNCBPT
 LDAIM  0
 LDYIM CBAGE
 STAIY GNCBPT
 LDAIM  0 ;SUCCESS
 RTS
CSWNF LDAIM  1
 RTS ;NOT FOUND
;
; ENSURE ALL CACHED BLOCKS
;
; ON ENTRY
;     GNCBPT POINTS TO CACHE DESCRIPTORS
;     NCBDB  HOLDS NUMBER OF DECRIPTORS
;
ENSBKS LDX NCBDB ;NUMBER
EBLP LDYIM CAFLG
 LDAIY GNCBPT
 ANDIM  4 ;WRITTEN FLAG
 BEQ EBSK ;DON'T WRITE OUT IF NOT WRITTEN
 TXA
 PHA
 LDYIM CBSA
 LDAIY GNCBPT
 STA GENPTR
 INY
 LDAIY GNCBPT
 STA GENPTR +1
 LDYIM 16
EBCHLP LDAIY GENPTR ;SAVE SOME OF BLOCK
 STAAY DATARA
 DEY
 BPL EBCHLP
 JSR WRBLK
 BEQ EBR1
 LDAIM  1
 ORA ERRTYP
 STA ERRTYP
EBR1 JSR CHECKB
 PLA
 TAX
EBSK DEX
 BEQ EBND ;WHEN END FOUND
 JSR ADGNCB
 JMP EBLP
EBND RTS
;
; CHECK BLOCK JUST WRITTEN FOR VALIDITY
;
CHECKB JSR RDBLK
 BNE CBRDER
 LDYIM CBSA
 LDAIY GNCBPT
 STA GENPTR
 INY
 LDAIY GNCBPT
 STA GENPTR +1
 LDYIM 16
CBCHLP LDAIY GENPTR
 CMPAY DATARA
 BNE CBCMER
 DEY
 BPL CBCHLP
 RTS
CBCMER LDAIM &F8
CBER JSR INTERR
CBRDER CLC
 RTS
;
; MAKE GNCBPT POINT TO NEXT ENTRY
;
ADGNCB CLC
 LDA GNCBPT
 ADCIM CBSZ
 STA GNCBPT
 LDA GNCBPT + 1
 ADCIM  0
 STA GNCBPT + 1
 RTS
;
; MARK WRITTEN BIT IN SPECIFIED CACHE DESCRIPTOR
;
; ON ENTRY
;     CBSTA POINTS TO ADDRESS IN MEMORY
;
MBMWT LDA BMCBPT ;GET POINTERS TO BIT MAP
 STA GNCBPT
 LDA BMCBPT + 1
 STA GNCBPT + 1
 LDAIM NOBTMP
 STA NCBDB
 JSR CASTWB
 BEQ MBMWND
 LDAIM &F5
 JSR INTERR
MBMWND RTS
;
; MARK WRITTEN BIT IN SPECIFIED MAP BLOCK
;
; ON ENTRY
;      CBSTA POINTS TO MAP BLOCK
;
;
MMBWT LDA CBSTA
 STA GNCBPT
 LDA CBSTA + 1
 STA GNCBPT + 1
 LDYIM MBSQNO
 CLC
 LDAIY GNCBPT
 ADCIM  1
 STAIY GNCBPT
 CLC
 LDA GNCBPT
 ADCIM LSTSQ
 STA GNCBPT
 LDA GNCBPT + 1
 ADCIM /(LSTSQ )
 STA GNCBPT + 1
 LDYIM  0
 CLC
 LDAIY GNCBPT
 ADCIM  1
 STAIY GNCBPT
 JSR SETMB
 JSR CASTWB
 RTS
;
; ENSURE BIT MAPS
;
ENSBM LDA BMCBPT
 STA GNCBPT
 LDA BMCBPT + 1
 STA GNCBPT + 1
 LDAIM NOBTMP
 STA NCBDB
 JSR ENSBKS
 RTS
;
; ENSURE MAP BLOCKS
;
ENSMB JSR SETMB
 JSR ENSBKS
 RTS
;
; FIND THE SPECIFIED MAP BLOCK
;
; CBSIN HOLDS THE SIN
;
; C SET IF FOUND
;
FNDMB LDA MBCBPT
 STA GNCBPT
 LDA MBCBPT + 1
 STA GNCBPT + 1
 LDAIM NOMPBK
 STA NCBDB
 JSR FNDBLK
 RTS
;
; LOCK IN STORE
;
; BLOCK WHOSE STORE ADDRESS IS IN CBSTA
; GNCBPT POINTS TO CACHE BLOCKS
; NCBDB NUMBER OF DESCRIPTORS
;
; NON-ZERO IF NOT FOUND
;
LOCKIS LDX NCBDB
LCLP LDYIM CBSA
 LDAIY GNCBPT
 CMP CBSTA
 BNE LCNX
 INY
 LDAIY GNCBPT
 CMP CBSTA + 1
 BEQ LCFND
LCNX JSR ADGNCB
 DEX
 BNE LCLP
 LDAIM  1
 RTS
LCFND LDYIM CAFLG
 LDAIY GNCBPT
 ORAIM  2 ;LOCK IN STORE
 STAIY GNCBPT
 LDAIM  0
 RTS
;
; UNLOCK ALL BLOCKS
;
; NCBDB HOLDS NUMBER OF BLOCKS
; GNCBPT POINTS TO LIST
;
UNLKBS LDX NCBDB
 LDYIM CAFLG
ULLP LDAIY GNCBPT
 ANDIM &FD ;UNLOCK BLOCK
 STAIY GNCBPT
 JSR ADGNCB
 DEX
 BNE ULLP
 RTS
;
;
; MARK MAP BLOCK LOCKED
;
; MPMBPT HOLDS STORE ADDRESS OF MAP BLOCK
; NON-ZERO IF FAILED
;
MMBLKD JSR SETMB
 LDA MPMBPT
 STA CBSTA
 LDA MPMBPT + 1
 STA CBSTA + 1
 JSR LOCKIS
 RTS
;
; MARK BIT MAP LOCKED
;
; MPSCPT POINTS TO BIT MAP
;
;
MBMLKD JSR SETBM
 LDA MPSCPT
 STA CBSTA
 LDA MPSCPT + 1
 STA CBSTA + 1
 JSR LOCKIS
 RTS
;
; UNLOCK ALL MAP BLOCKS
;
ULMB JSR SETMB
 JSR UNLKBS
 RTS
;
; UNLOCK ALL BIT MAPS
;
ULBM JSR SETBM
 JSR UNLKBS
 RTS
;
; SET VALUES FOR BIT MAP
;
SETBM LDA BMCBPT
 STA GNCBPT
 LDA BMCBPT + 1
 STA GNCBPT + 1
 LDAIM NOBTMP
 STA NCBDB
 RTS
;
; SET VALUES FOR MAP BLOCKS
;
SETMB LDA MBCBPT
 STA GNCBPT
 LDA MBCBPT + 1
 STA GNCBPT + 1
 LDAIM NOMPBK
 STA NCBDB
 RTS


 LNK UADE14
