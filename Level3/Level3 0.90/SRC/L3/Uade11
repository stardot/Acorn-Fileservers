 OPT UADE11 ;> Uade11
 TTL File server file UADE11

;************************
;*  Restart one drive   *
;*  Disc number -> name *
;*  Disc name -> number *
;*                      *
;*  U T I L I T I E S   *
;************************



MPENSR
 LDAIM  0
 JMP MPEXIT

;MPFRSP: FREE SPACE

;ENTRY: ARGB = LS(DISC NUMBER)
;ARGC = MS(DISC NUMBER)
;ARGD = LS(SIN)
;ARGE = CS(SIN)
;ARGF = MS(SIN)
;ARGG = LS ptr to user info
;ARGH = MS ptr to user info

;EXIT:  ARGA = RC

;FUNCTION: MAPTB IS SEARCHED TO FIND THE RELEVANT ENTRY. IF THE SECTOR
;MAP IS NOT IN STORE IT IS READ IN. THE SIN IS CHECKED TO ENSURE THAT IT
;POINTS TO THE FIRST BLOCK OF THE CHAIN. ALL THE SECTORS ON THE CHAIN ARE
;THEN ADDED TO THE FREE CHAIN. THE FREE SECTOR COUNT IS THEN ADJUSTED. THE
;DIRTY FLAG FOR THE SECTOR MAP IS SET.

MPFRSP JSR FNDMAP ;GET CURRENT MAP TABLE POSITION
 BNE MPFSND

 LDAIM  0
 STA ERRTYP
 STA DNDLTE

 LDYIM ARGG
 JSR MPFRAD
 BNE MPFSND

 JSR MPDLTE
 BNE MPFSND
 JSR ENSMB
 JSR ENSBM
 LDAIM  0 ; REPLY ZERO
MPFSND LDYIM ARGG
 JSR MPSETF
 JMP MPEXIT

MPREDR   ;MPREDR

;*** RESTART ONE DRIVE **

;ENTRY: ARGB = DRIVE NO.

;EXIT:  ARGA = RC

 LDAIM  0
 STA ERRTYP
 LDA BBUF
 STA DSCCB+TRADD ;SET UP AREA TO READ IN SECTOR TWO
 STA MPSCPT
 LDA BBUF + 1
 STA DSCCB+TRADD + 1
 STA MPSCPT + 1

 LDYIM ARGB
 LDAIY ARGPTR
 STA CURDRV ;SET CURRENT DRIVE
 STA MPDRVE

 JSR RDSTWO ;GET SECTOR ZERO TO BIG BUFFER

 JSR CHKDSC ;CHECK DISC IS FS DISC
 BNE MPDREX
 JSR SMPPTR ;SET POINTER TO RELEVANT MAPTAB ENTRY

;Store old MAPTB entry, so that if an error
;occurs, MAPTB can be replaced.
; Having stored old MAPTB entry, replace with stuff
;from sector zero.

 LDYIM MPDCNO
MPDRL1 LDAIY MAPPTR
 STAAY MAPTBF -MPDCNO
 INY
 CPYIM MPTBSZ
 BNE MPDRL1

 JSR SMAPEN ;Move sector zero info. from BBUF

 JSR MPMPSZ ;Get size of disc

 JSR DIVSEC ; GET NO. OF TRACKS
 LDYIM MPNOCY
 CLC
 LDA MPTMPB ;CALCULATE SIZE OF CY.MAP
 STAIY MAPPTR ; SAVE NO. OF TRACKS
 INY
 ROLA
 STA MPTMPB ; MULTIPLY TRACKS BY TWO
 LDA MPTMPB+ 1
 STAIY MAPPTR
 ROLA
 STA MPTMPB+ 1
 JSR CHMPSZ ;CHECK MAP WILL FIT IN AVAILABLE SPACE
 BNE MPDRAB

 JSR MPSTCY ;SET CORRECT MAP (MOST RECENT)

 JSR AGENTB ;AGE NAME TABLE

 LDA BBUF
 STA MPSCPT
 LDA BBUF + 1
 STA MPSCPT + 1 ;CHMAPS destroys MPSCPT

 LDA MAPTBF
 STA CURDSC ;Set disc no. for FNDDNO
 LDA MAPTBF + 1
 STA CURDSC + 1
 JSR FNDDNO ;Find name table entry of old disc
 LDAIM UNUSED
 LDYIM NTUSED
 STAIY DNMPTR ;Mark old disc unused

 JSR CHDNAM ;CHECK DISC NAME AND PUT IN NAME TABLE
 BNE MPDRAB ;POSSIBLY NOT UNIQUE DISC

 LDAIM  0 ;=> Success
MPDREX JMP MPEXIT ;*** EXIT **

MPDRAB PHA ;Error exit !!

 LDYIM MPTBSZ - 1
MPDNL2 LDAAY MAPTBF
 STAIY MAPPTR ;Restore MAPTB information,
 DEY ;so that state is as before
 BPL MPDNL2

 PLA
 JMP MPDREX

;MPDSNB:

;ENTRY: ARGB = DRIVE NUMBER

;EXIT:  ARGA = RC
;ARGB = LS(DISC NUMBER)
;ARGC = MS(DISC NUMBER)

;FUNCTION: FINDS THE RELEVANT ENTRY
;IN MAPTB AND RETURNS THE DISC NUMBER CURRENTLY
;ON THAT DRIVE.

MPDSNB LDYIM ARGB ;TO FIND DRIVE NUMBER
 LDAIY ARGPTR
 CMP DRIVES
 BCS MPDSER ;BRANCH IF LEG PULL
 STA CURDRV
 JSR SMPPTR

;ENTRY FOUND SO LOOK AT IT
 LDYIM MPDCNO ;FOR DISC NUMBER
 LDAIY MAPPTR
 LDYIM ARGB ;TO SAVE IT FOR RETURN
 STAIY ARGPTR
 LDYIM MPDCNO + 1
 LDAIY MAPPTR
 LDYIM ARGC
 STAIY ARGPTR
 LDAIM  0 ;RC
 JMP MPDSND
MPDSER LDAIM MPERRF
MPDSND JMP MPEXIT

MPDNNA ;MPDNNA

;ENTRY: ARGB = PTR TO DISC NAME (LO)
;ARGC = PTR TO DISC NAME (HI)

;EXIT : ARGB = DISC NO. (LO)
;ARGC = DISC NO. (HI)


 LDYIM ARGB
 LDAIY ARGPTR
 STA GENPTR
 INY
 LDAIY ARGPTR
 STA GENPTR + 1
 LDYIM  0

 LDAIY GENPTR
 CMPIM CR
 BNE MPDNLA
 LDAIM MPERRK
 BNE MPDNEX ;null disc name

MPDNLA LDAIY GENPTR
 CMPIM CR
 BEQ MPDNLB ;ARG. IS TERMINATED CR, SO NEEDS PADDING
 STAAY DNMBUF
 INY
 JMP MPDNLA

MPDNLB LDAIM SPACE
MPDNLC CPYIM DNAMLN ;CONTINUE PADDING ?
 BCS MPDNLD ;NOPE, Y>=DNAMLN
 STAAY DNMBUF ;YEP, CONTINUE
 INY
 JMP MPDNLC

MPDNLD JSR FNDNAM ;LOOK UP NAME IN NAME TABLE
 BNE MPDNEX ;NOT FOUND ...

 LDYIM NTDNO
 LDAIY DNMPTR
 PHA
 INY
 LDAIY DNMPTR
 LDYIM ARGC

 STAIY ARGPTR
 PLA
 DEY
 STAIY ARGPTR
 LDAIM  0

MPDNEX JMP MPEXIT


MPNADN   ;MPNADN

;**  DISC NO. -> DISC NAME **

;ENTRY: ARGB = DISC NO. (LO)
;ARGC = DISC NO. (HI)

;EXIT   ARGB = PTR. TO NAME (LO)
;ARGC = PTR. TO NAME (HI)

;RETURN CODE INDICATES FOUND

 LDYIM ARGB
 LDAIY ARGPTR
 STA CURDSC
 INY
 LDAIY ARGPTR
 STA CURDSC + 1

 JSR FNDDNO
 BEQ MPNDON

 LDAIM MPERRA ;DISC NO. NOT FOUND
 BNE MPNDEX

MPNDON LDYIM ARGB
 CLC
 LDA DNMPTR
 ADCIM NTNAME
 STAIY ARGPTR
 INY
 LDA DNMPTR + 1
 ADCIM  0
 STAIY ARGPTR
 LDAIM  0 ;OK EXIT ...

MPNDEX JMP MPEXIT

MPFREE
; RETURN SIZE OF FREE CHAIN
;
; ON ENTRY
;    ARGB LS(DISC NO)
;    ARGC MS " "
;
; ON EXIT
;    ARGB LS (SIZE)
;    ARGC CS (")
;    ARGD MS (")
;    ARGE LS (TOTAL SPACE)
;    ARGF CS (")
;    ARGG MS (")
;
 JSR FNDMAP ;GET MAP TO STORE
 BNE MPFREX
 LDYIM MPCYMP
 LDAIY MAPPTR
 STA MPCYPT
 INY
 LDAIY MAPPTR
 STA MPCYPT + 1
 LDYIM  0
 LDAIY MPCYPT ;GET FREE SPACE
 STA MPTMPA
 INY
 LDAIY MPCYPT
 STA MPTMPA + 1
 INY
 LDAIY MPCYPT
 STA MPTMPA + 2
 LDYIM ARGB
 LDA MPTMPA
 STAIY ARGPTR
 INY
 LDA MPTMPA + 1
 STAIY ARGPTR
 INY
 LDA MPTMPA + 2
 STAIY ARGPTR
 LDYIM MPSCTT
 LDAIY MAPPTR
 STA MPTMPA
 INY
 LDAIY MAPPTR
 STA MPTMPA +1
 INY
 LDAIY MAPPTR
 LDYIM ARGG
 STAIY ARGPTR
 DEY
 LDA MPTMPA +1
 STAIY ARGPTR
 DEY
 LDA MPTMPA
 STAIY ARGPTR
 LDAIM  0
MPFREX JMP MPEXIT

;MPZDSK: ZERO AREA OF DISC
;
;ENTRY: ARGB LS(DISC NUMBER)
;ARGC MS(DISC NUMBER)
;ARGD LS(SIN)
;ARGE CS(SIN)
;ARGF MS(SIN)
;ARGG LS(OLD SIZE)
;ARGH CS(OLD SIZE)
;ARGI MS(OLD SIZE)
;
;EXIT: ARGA = RC
;
MPZDSK
 LDYIM ARGD
 LDAIY ARGPTR
 STA MPTMPA
 INY
 LDAIY ARGPTR
 STA MPTMPA + 1
 INY
 LDAIY ARGPTR
 STA MPTMPA + 2
 INY
 LDAIY ARGPTR
 STA OLDSZE
 INY
 LDAIY ARGPTR
 STA OLDSZE + 1
 INY
 LDAIY ARGPTR
 STA OLDSZE + 2
 LDAIM  0
 STA OLDSZE + 3
 JSR ZERDSK
 JMP MPEXIT

;**********************************
;*           M A P M A N          *
;*        U T I L I T I E S       *
;**********************************



; READS THE SPECIFIED BIT MAP INTO STORE
;
; ON ENTRY
;     MPTMPC IS CYLINDER NUMBER OF BIT MAP
;
; ON EXIT
;     MPSCPT POINTS TO BIT MAP
RDBTMP ;READ BIT MAP
SKP LDA MPTMPC ; GET CYLINDER NUMBER
 STA CBTPPT ;SAVE FOR DECREMENTING
 LDA MPTMPC + 1
 STA CBTPPT + 1
 LDAIM  0 ;ZERO OUT SIN
 STA CBSIN
 STA CBSIN + 1
 STA CBSIN + 2
RBMLP LDA CBTPPT ;CHECK IF CYLINDER FOUND
 ORA CBTPPT + 1
 BEQ RBMBMP ; FOUND SO GO AND READ IN
 LDYIM MPSPCY
 CLC
 LDA CBSIN
 ADCIY MAPPTR
 STA CBSIN
 INY
 LDA CBSIN + 1 ;GET TO NEXT BIT MAP
 ADCIY MAPPTR
 STA CBSIN + 1
 LDA CBSIN + 2
 ADCIM  0
 STA CBSIN + 2
 SEC ; DECREMENT CYLINDER COUNTER
 LDA CBTPPT
 SBCIM  1
 STA CBTPPT
 LDA CBTPPT + 1
 SBCIM  0
 STA CBTPPT + 1
 JMP RBMLP
RBMBMP LDAIM NOBTMP ;FOUND SO SET SIZE OF BIT MAP CHAIN
 STA NCBDB
 LDA BMCBPT ; GET RIGHT POINTER
 STA GNCBPT
 LDA BMCBPT + 1
 STA GNCBPT + 1
 JSR GTBTS ;READ IN BLOCK IF NECESSARY
 BNE RBMND ;NON-ZERO IF FAILED
 LDA CBSTA ;GET STORE ADDRESS
 STA MPSCPT ; AND SAVE FOR RETURN
 LDA CBSTA + 1
 STA MPSCPT + 1
 LDA ERRTYP
 BEQ RBMR1
 LDA RSTFLG
 BNE RBMR2
 LDAIM IERRAJ
 JSR INTERR
RBMR2 LDA CBSTA
 STA CLRPTR
 LDA CBSTA + 1
 STA CLRPTR + 1
 LDYIM  0
 LDXIM  1
 JSR CLRSTR
RBMR1 LDAIM  0
RBMND RTS
;
; READ THE SPECIFIED MAP BLOCK INTO STORE
;
; ON ENTRY
;     MPTMPA HOLDS SIN
;     CARRY SET IF BLOCK NOT TO BE READ IN
;
; ON EXIT
;     MAPTMP HOLDS POINTER
;
RDMPBK ;READ IN MAP BLOCK
 PHP ;SAVE STATE OF CARRY FLAG
 LDA MPTMPA ;GET SIN TO RIGHT PLACE
 STA CBSIN
 LDA MPTMPA + 1
 STA CBSIN + 1
 LDA MPTMPA + 2
 STA CBSIN + 2
 LDA MBCBPT ; GET CORRECT POINTER
 STA GNCBPT
 LDA MBCBPT + 1
 STA GNCBPT + 1
 LDAIM NOMPBK ;NUMBER OF MAP BLOCK ENTRIES
 STA NCBDB
 PLP ;GET CARRY FLAG BACK
 BCS RMBNR ;BRANCH IF NOT TO BE READ IN
 JSR GTBTS ; GET THE MAP BLOCK TO STORE
 BNE RMBND ; NON-ZERO IF FAILED
 LDA CBSTA ;SAVE ADDRESS IN CORRECT PLACE
 STA MAPTMP
 STA GNCBPT
 LDA CBSTA + 1
 STA MAPTMP + 1
 STA GNCBPT + 1
 LDYIM MBSQNO ;POINT TO FIRST SEQUNCE NUMBER
 LDAIY GNCBPT
 TAX
 CLC
 LDA GNCBPT
 ADCIM LSTSQ
 STA GNCBPT
 LDA GNCBPT + 1
 ADCIM /(LSTSQ )
 STA GNCBPT + 1
 LDYIM  0
 TXA
 CMPIY GNCBPT ;COMPARE WITH LAST NUMBER
 BEQ RDMBND
 LDAIM MPERRC
 JMP RMBND
RDMBND LDAIM  0
RMBND RTS
RMBNR JSR FNDMB
 BCC RMBSK1
 LDYIM CBSA
 JMP RMBSK2
RMBSK1 JSR GETFR ;JUST FIND A FREE SPACE
 BNE RMBND
 LDYIM CBDR
 LDA MPDRVE
 STAIY GNCBPT
 LDYIM CAFLG
 LDAIY GNCBPT
 ORAIM  1 ;FLAG ALLOCATED
 STAIY GNCBPT
 INY
 LDA MPTMPA
 STAIY GNCBPT
 INY
 LDA MPTMPA + 1
 STAIY GNCBPT
 INY
 LDA MPTMPA + 2
 STAIY GNCBPT
 INY
RMBSK2 LDAIY GNCBPT ;GET ADDRESS OF FREE STORE
 STA MAPTMP
 STA CLRPTR
 INY
 LDAIY GNCBPT
 STA MAPTMP + 1
 STA CLRPTR + 1
 LDYIM BTINBK
 LDXIM /(BTINBK )
 JSR CLRSTR ;CLEAR MAP BLOCK TO ZEROES SINCE NOT READ IN
 JMP RDMBND
 
; CALCULATE THE NUMBER OF SECTORS REQUIRED FROM
; THE NUMBER OF BYTES REQUIRED. 
;
;   ON ENTRY
;           DIVPAR HOLDS THE NUMBER OF BYTES
;
;   ON EXIT
;           DIVPAR HOLDS ODD BYTES
;           DIVTMP HOLDS THE NUMBER OF BLOCKS
;           Carry Set if Overflow
;
DVDE LDAIM  0
 STA DIVTMP
 STA DIVTMP+ 1
 STA DIVTMP+ 2
 LDA DIVPAR
 ORA DIVPAR+ 1
 ORA DIVPAR+ 2
 BEQ DIVONE
DIVLP SEC ;NOW LOOP DO DIVIDE BY BLOCK SIZE
 LDA DIVPAR
 SBCIM BTINBK
 STA DIVPAR
 LDA DIVPAR+ 1
 SBCIM /(BTINBK )
 STA DIVPAR+ 1
 LDA DIVPAR+ 2
 SBCIM  0
 STA DIVPAR+ 2
 BCC DIVNO ;CARRY CLEAR AT END OF DIVISION
 LDA DIVPAR
 ORA DIVPAR + 1
 ORA DIVPAR + 2
 BEQ DIVS1
 INC DIVTMP
 BNE DIVLP
 INC DIVTMP+ 1
 JMP DIVLP
DIVNO LDA DIVPAR ;REPLACE LOWER BYTE
 ADCIM BTINBK
 STA DIVPAR
 LDA DIVPAR+ 1
 ADCIM /(BTINBK )
 STA DIVPAR+ 1
 LDA DIVPAR+ 2
 ADCIM  0
 STA DIVPAR+ 2
DIVS1 CLC
 LDA DIVTMP
 ADCIM  2 ;AT LEAST TWO BLOCKS LONG
 STA DIVTMP
 LDA DIVTMP + 1
 ADCIM  0
 STA DIVTMP + 1
 LDA DIVTMP + 2
 ADCIM  0
 STA DIVTMP + 2
 RTS
DIVONE LDAIM  1
 STA DIVTMP                      
 CLC
 RTS
;GETPOS
;   FINDS NEXT FREE POSITION IN MAP BLOCK
; SETS CARRY FLAG IF MAP BLOCK FULL
;
; ON ENTRY
;      MAPGEN POINTS TO START OF MAP BLOCK
;
; ON EXIT
;      MAPGEN POINTS TO NEXT FREE POSITION
;
; USES
;      MPTMPE
;
GETPOS CLC
 LDA MAPGEN
 ADCIM MBENTS ;GET MAPGEN TO START OF ENTRIES
 STA MAPGEN
 LDA MAPGEN+ 1
 ADCIM /(MBENTS )
 STA MAPGEN+ 1
 LDAIM  0
 STA MPTMPE
 STA MPTMPE+ 1 ;CLEAR VARIABLES
GPLP LDA MPTMPE
 CMPIM MXENTS- 1 ;CHECK FOR END OF LIST
 LDA MPTMPE+ 1
 SBCIM /(MXENTS- 1 )
 BCC NFND
 RTS ;RETURNS WITH CARRY SET IF END OF LIST
NFND LDYIM  0;Y POINTS AT SIN
 LDAIY MAPGEN
 BNE GPSK ; ZERO IS END OF LIST
 INY
 LDAIY MAPGEN
 BNE GPSK
 INY
 LDAIY MAPGEN 
 BEQ GPFND
GPSK CLC ;LOOK AT NEXT ENTRY
 LDA MAPGEN
 ADCIM ENSZ
 STA MAPGEN
 LDA MAPGEN+ 1
 ADCIM  0
 STA MAPGEN+ 1
 INC MPTMPE ;MPTMPE HOLDS NUMBER OF ENTRIES WE'VE LOOKED AT
 BNE GPLP
 INC MPTMPE+ 1
 JMP GPLP
GPFND CLC
 RTS ;RETURNS HERE WITH CARRY CLEAR, ALL OK.
; GET CYLINDER MAP POSITION
;
; STARTS A SEARCH FROM MPTMPC FOR THE NEXT
; CYLINDER WITH A FREE SECTOR
;
; ON ENTRY
;     MPTMPC HOLDS THE CURRENT CYLINDER
;     MAPGEN POINTS TO START OF CYLINDER MAP
;     MAPPTR POINTS TO MABTB ENTRY
;
; ON EXIT
;     MAPGEN POINTS TO CYLINDER WITH FREE ENTRY
;
; USES
;     MPTMPE
;
GTCYPS LDA MPTMPC
 STA MPTMPE ;SAVE CURRENT POSITION
 LDA MPTMPC+ 1
 STA MPTMPE+ 1
 CLC
 LDA MAPGEN ;POINT TO START OF MAP
 ADCIM  3
 STA MAPGEN
 LDA MAPGEN+ 1
 ADCIM  0
 STA MAPGEN+ 1
MELP2 LDA MPTMPE ;CHECK IF POSITION FOUND
 ORA MPTMPE+ 1
 BEQ GCPS1
 CLC
 LDA MAPGEN
 ADCIM  2 ;FOR NEXT ENTRY
 STA MAPGEN
 LDA MAPGEN + 1
 ADCIM  0
 STA MAPGEN+ 1
 SEC
 LDA MPTMPE
 SBCIM  1
 STA MPTMPE
 LDA MPTMPE+ 1
 SBCIM  0
 STA MPTMPE+ 1
 JMP MELP2
GCPS1 LDA MPTMPC
 STA MPTMPE
 LDA MPTMPC + 1
 STA MPTMPE + 1
MEFD1 LDYIM  0 ;NOW LOOK FOR POSITION WITH FREE BLOCK
 LDAIY MAPGEN
 INY
 ORAIY MAPGEN
 BNE GTND ;FOUND IF NON ZERO
 CLC
 LDA MPTMPE
 ADCIM  1
 STA MPTMPE
 LDA MPTMPE+ 1
 ADCIM  0
 STA MPTMPE+ 1
 LDA MPTMPE
 LDYIM MPNOCY ;CHECK FOR END OF CYCLINDER MAP
 CMPIY MAPPTR
 INY
 LDA MPTMPE+ 1
 SBCIY MAPPTR
 BCS MEFBKG
 CLC ;NOT END SO LOOK AT NEXT ENTRY
 LDA MAPGEN
 ADCIM  2
 STA MAPGEN
 LDA MAPGEN + 1
 ADCIM  0
 STA MAPGEN+ 1
 JMP MEFD1
MEFBKG LDAIM  0 ;END SO BACK TO BEGINNING
 STA MPTMPE
 STA MPTMPE+ 1
 LDYIM MPCYMP
 LDAIY MAPPTR ;GET START OF CYLINDER MAP
 STA MAPGEN
 INY
 LDAIY MAPPTR
 STA MAPGEN + 1
 CLC
 LDA MAPGEN ;GET POINTER TO START OF ENTRIES
 ADCIM  3
 STA MAPGEN
 LDA MAPGEN + 1
 ADCIM  0
 STA MAPGEN+ 1
 JMP MEFD1
GTND RTS
; FIND CYLINDER
;
; FINDS THE CYCLINDER WITH THE LARGEST AMOUNT
; OF FREE SPACE
;
; ON ENTRY
;     MPCYPT POINTS TO START OF CYLINDER MAP
;
; ON EXIT
;     MPCYPT POINTS TO CYLINDER FOUND
;
; USES
;     MAPTMP
;     MPTMPA
;     MPTMPB
;
FNDCY LDYIM  0
 STY MAPTMP ;ZERO VALUES
 STY MAPTMP+ 1
 STY MPTMPA
 STY MPTMPA + 1
 STY MPTMPC
 STY MPTMPC + 1
 CLC
 LDA MPCYPT ;GET TO START OF ENTRIES
 ADCIM  3
 STA MPCYPT
 STA MPTMPB
 LDA MPCYPT+ 1
 ADCIM  0
 STA MPCYPT+ 1
 STA MPTMPB+ 1
FNDLP LDYIM  0 ;NOW SCAN ENTRIES FOR LARGEST
 LDA MAPTMP
 CMPIY MPCYPT
 INY
 LDA MAPTMP + 1
 SBCIY MPCYPT ; MAPTMP HOLDS LARGEST SO FAR
 BCS FNDSK ;BRANCH IF NOT LARGER
 LDAIY MPCYPT
 STA MAPTMP+ 1
 DEY
 LDAIY MPCYPT
 STA MAPTMP
 LDA MPCYPT ;SAVE POSITION
 STA MPTMPB
 LDA MPCYPT+ 1
 STA MPTMPB+ 1
 LDA MPTMPA
 STA MPTMPC ;SAVE CYLINDER NUMBER
 LDA MPTMPA + 1
 STA MPTMPC + 1
FNDSK CLC
 LDA MPCYPT
 ADCIM  2 ;MOVE TO NEXT ENTRY
 STA MPCYPT
 LDA MPCYPT+ 1
 ADCIM  0
 STA MPCYPT+ 1
 INC MPTMPA
 BNE FNDSK2
 INC MPTMPA + 1
FNDSK2 LDYIM MPNOCY ;CHECK FOR END OF MAP
 LDAIY MAPPTR
 CMP MPTMPA
 BNE FNDLP
 INY
 LDAIY MAPPTR
 CMP MPTMPA+ 1
 BNE FNDLP
 LDA MPTMPB ;END SO RETURN POINTER
 STA MPCYPT
 LDA MPTMPB+ 1
 STA MPCYPT+ 1
 RTS
; RETURNS THE SIZE OF A BLOCK OF STORE
;
; ON ENTRY
;    MPSCPT POINTS TO BIT MAP
;
; ON EXIT
;    MPTMPD HOLDS THE SIZE
;
; USES
;    MPTMPE
;
SIZE LDYIM MPSPCY
 LDAIY MAPPTR
 STA TMPSPC
 INY
 LDAIY MAPPTR
 STA TMPSPC + 1
 LDAIM  0
 STA MPTMPD ;CLEAR VARIABLES
 STA MPTMPD+ 1
 STA MPTMPE
 STA MPTMPE+ 1
 LDYIM  0
SZLP2 LDAIY MPSCPT
 BEQ SZNX ;NO FREE BITS IN THIS PART
 LDXIM  8 ;LOOK AT ALL EIGHT BITS
SZLP RORA ;GET BIT INTO CARRY
 PHA
 BCC SZCHND ;CLEAR SO CHECK FOR END
 INC MPTMPD
 BNE SZSK ;KEEP A COUNT OF SECTORS
 INC MPTMPD+ 1
SZSK INC MPTMPE
 BNE SZSK2
 INC MPTMPE + 1 ;AND CHECK HOW MANY BITS WE'VE LOOKED AT
SZSK2 LDA MPTMPE
 CMP TMPSPC ;CEHCK FOR END OF MAP
 LDA MPTMPE+ 1
 SBC TMPSPC + 1
 BCC SZCNT
 LDA MPTMPD
 ORA MPTMPD +1
 BNE SZNERR
 LDAIM &F6
 JSR INTERR
SZNERR PLA ;GET BIT MAP VALUE BACK
 JMP SZGOT2
SZCNT PLA
 DEX
 BNE SZLP
 INY
 JMP SZLP2
SZCHND LDA MPTMPD
 ORA MPTMPD+ 1
 BNE SZGOT ;END IF ALREADY SOME COUNT
 JMP SZSK
SZNX LDA MPTMPD
 ORA MPTMPD + 1
 BNE SZGOT2
 CLC
 LDA MPTMPE
 ADCIM  8 ;LOOK AT NEXT BYTE OF MAP
 STA MPTMPE
 LDA MPTMPE+ 1
 ADCIM  0
 STA MPTMPE+ 1
 INY ;INCREMENT POINTER
 LDA MPTMPE
 CMP TMPSPC ;CHECK FOR END OF MAP
 LDA MPTMPE+ 1
 SBC TMPSPC + 1
 BCC SZLP2

 [ 1=1     ; Old code first contains 8 bytes of NOP
           ; Replaced in Midwitch code by 8 bytes of marker


 LDA MPTMPD
 ORA MPTMPD +1
 BNE SZGOT

 LDAIM &F6
 JSR INTERR
 |
 LDAIM &F6
 JSR INTERR ; Never returns JSR used to stack PC                                                
 = "midWmark"
 ]

SZGOT PLA
SZGOT2 RTS
;
; FILL BLOCKS
;    ALLOCATES REST OF BLOCKS THAT ARE REQUIRED
;
; ON ENTRY
;      DIVTMP HOLDS SIZE
;      MPSCPT POINTS TO CURRENT BIT MAP
;      MPTMPC HOLDS CYLINDER NUMBER
;      MAPTMP POINTS TO MAP BLOCK
;      MAPPTR POINTS TO MAP TABLE
;      MPCYPT POINTS TO POSITION IN CYLINDER MAP
;
; ON EXIT
;      C SET IF FAILED
;

FLBLKS LDA DIVTMP ;CHECK IF ALL BLOCKS ALLOCATED
 ORA DIVTMP + 1
 ORA DIVTMP + 2
 BEQ FBND
 JSR GETBIT ;FIND FIRST FREE BLOCK
 BCS FBTNXT ;NONE LEFT SO GET NEXT TRACK
 JSR ABLKS ;ALLOCATE THESE BLOCKS
 BCC FLBLKS ;KEEP ALLOCATING BLOCKS UNTIL NONE LEFT
 LDA ERRTYP
 BEQ FBTNXT
 SEC
 JMP FBND2
FBTNXT INC MPTMPC
 BNE FBSK1
 INC MPTMPC + 1
FBSK1 LDA MPTMPC ;GET NEXT BIT MAP
 LDYIM MPNOCY ; CHECK FOR END
 CMPIY MAPPTR
 INY
 LDA MPTMPC + 1
 SBCIY MAPPTR
 BCS FBTB
 CLC
 LDA MPCYPT ;KEEP CYLINDER MAP POINTER UP TO DATE
 ADCIM  2
 STA MPCYPT
 LDA MPCYPT + 1
 ADCIM  0
 STA MPCYPT + 1
 LDYIM  0
 LDAIY MPCYPT
 INY
 ORAIY MPCYPT
 BEQ FBTNXT
 JSR RDBTMP ; GET THE BIT MAP
 JMP FLBLKS ; KEEP TRYING TO ALLOCATE
FBTB LDAIM  0 ;GO BACK TO THE BEGINNING
 STA MPTMPC
 STA MPTMPC + 1
 LDYIM MPCYMP ;RETURN CYLINDER MAP TO BEGINNING
 CLC
 LDAIY MAPPTR
 ADCIM  1
 STA MPCYPT
 INY
 LDAIY MAPPTR
 ADCIM  0
 STA MPCYPT + 1
 JMP FBSK1
FBND CLC ;INDICATE OK
FBND2 RTS
;
; GET BIT
;   FINDS THE FIRST FREE BIT IN THE BIT MAP
;
; ON ENTRY
;     MPSCPT POINTS TO BIT MAP
;
; ON EXIT
;     MPTMPE HOLDS BIT NUMBER
;     C SET IF NOT BITS FOUND
;
GETBIT LDYIM MPSPCY
 LDAIY MAPPTR
 STA TMPSPC
 INY
 LDAIY MAPPTR
 STA TMPSPC + 1
 LDYIM  0
 STY MPTMPE
 STY MPTMPE + 1
GTBTBL LDAIY MPSCPT ; GET BYTE OF BIT MAP
 BEQ GTBTNB ; IF NONE FREE GET NEXT BYTE
GTBTLP RORA ; ROTATE UNTIL BIT FOUND
 BCS GTBTFD ; BRANCH WHEN FOUND
 INC MPTMPE ;KEEP TRACK OF WHERE WE ARE
 BNE GTBTSK
 INC MPTMPE + 1
GTBTSK PHA
 JSR TESTME ;CHECK FOR END OF ENTRY
 PLA
 BCC GTBTLP
GTBTNB CLC
 LDA MPTMPE ;ADD 8 FOR THIS BYTE
 ADCIM  8
 STA MPTMPE
 LDA MPTMPE + 1
 ADCIM  0
 STA MPTMPE + 1
 INY
 JSR TESTME ; CHECK FOR END OF BIT MAP
 BCC GTBTBL
 SEC ;WHEN NONE FOUND
 RTS
GTBTFD CLC
 RTS
;
; CHECK FOR END OF BIT MAP
;
TESTME LDA MPTMPE
 CMP TMPSPC
 LDA MPTMPE + 1
 SBC TMPSPC + 1
 RTS
;
; CORRECT THE CURRENT FREE BLOCK COUNT
;
; ON ENTRY
;     MPTMPB HOLDS NUMBER OF BLOCKS
;     MPTMPC HOLDS CYLINDER NUMBER
;     MAPPTR POINTS TO MAP TABLE ENTRY
;
; USES MAPGEN
;
ADDFR LDYIM MPCYMP
 LDAIY MAPPTR
 STA MAPGEN
 INY
 LDAIY MAPPTR
 STA MAPGEN + 1 ;GET POINTER TO CYLINDER MAP
 LDYIM  0
 CLC
 LDAIY MAPGEN ;ADD TO FREE COUNT AT START
 ADC MPTMPB
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADC MPTMPB + 1
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADC MPTMPB + 2
 STAIY MAPGEN
 CLC ; NOW FOUND CYLINDER POSITION
 LDA MAPGEN
 ADCIM  3 ;START OF ENTRIES
 STA MAPGEN
 LDA MAPGEN + 1
 ADCIM  0
 STA MAPGEN + 1
 LDA MPTMPC
 ORA MPTMPC + 1
 BEQ GTPSCY
 LDX MPTMPC
 LDY MPTMPC + 1
 JMP TRYX
ADLP CLC
 LDA MAPGEN
 ADCIM  2
 STA MAPGEN
 LDA MAPGEN + 1
 ADCIM  0
 STA MAPGEN + 1
TRYX CPXIM  0
 BEQ TRYY
 DEX
 JMP ADLP
TRYY CPYIM  0
 BEQ GTPSCY
 DEX
 DEY
 JMP ADLP
GTPSCY LDYIM  0
 CLC ;NOW ADD THE NEW VALUES
 LDAIY MAPGEN
 ADC MPTMPB
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADC MPTMPB + 1
 STAIY MAPGEN
 RTS

MPMKFR LDAIY ARGPTR ;form zero page pointer from supplied info
 STA GENPTR
 INY
 LDAIY ARGPTR
 STA GENPTR+1
MPSETB RTS

MPSETF TAX
 BNE MPSETB ;non-zero => dont update the free store
 JSR MPMKFR
 CLC
 TAX
 LDA GENPTR
 ADCIM UTUSID
 LDYIM ARGB
 STAIY NEWARG
 INY
 BCC MPSETG
 INX
MPSETG TXA
 STAIY NEWARG

 LDXIM -4
MPSETA INY
 LDAAX MPNWFR - :LSB: -4 ;write calculated new free space
 STAIY NEWARG
 INX
 BNE MPSETA
 LDAIM 9
 JSR SETRTN
 JMP USRMAN

MPBLTX = "paMseJ" ;Mapblocktext

MPFRAD JSR MPMKFR ;setup pointer
 LDXIM 2
 LDYIM ARGF
MPFRAA LDAIY ARGPTR
 STAAX MPTMPA
 DEY
 DEX
 BPL MPFRAA

 CLC
 JSR RDMPBK ;get the map block
 BNE MPFRAC ;exit

 LDA MAPTMP
 STA MPMBPT
 LDA MAPTMP+1
 STA MPMBPT+1
 JSR MPGTSZ

 LDXIM -3
 LDYIM UTFREE
 CLC

MPFRAB LDAIY GENPTR
 ADCAX MPTMPA - :LSB: -3
 STAAX MPNWFR - :LSB: -3 ;save it away
 INY
 INX
 BNE MPFRAB

;deal with extra length byte

 LDAIY GENPTR
 ADCIM 0 ;'cos size only three bytes
 STAAX MPNWFR + 3

 TXA ;return ok
MPFRAC RTS



 [ FS=0
 <  1
 ]
 LNK UADE12

