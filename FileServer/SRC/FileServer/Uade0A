 OPT UADE0A ; > <FileServerSource>.Uade0A
 TTL File server file UADE0A

;**********************************
;*         S T R M A N            *
;**********************************


;STRMAN: THE STORE MANAGER IS RESPONSIBLE
;FOR MAINTAINING A CACHE OF
;VARIABLE LENGTH (BUT AN INTEGRAL NUMBER
;OF DISC BLOCKS) OBJECT WINDOWS.

;THE CONTENTS OF THE CACHE IS DESCRIBED BY
;A ONE WAY CHAIN OF DESCRIPTORS.
;THESE DESCRIPTORS ARE KEPT IN AN ORDER WHICH
;DESCRIBES THE POSITION OF THE WINDOWS IN MEMORY.
;NOTE THAT EACH OBJECT IN THE CACHE
;IS PRECEEDED BY A ONE BYTE DIRTY MARKER.


;********* MAIN ROUTINE *********

STRMAN ROUT
 LDXIM 9 ;STRMAN HAS 9 ENTRY POINTS
 LDAIM MODSTR ;A:=NAME OF THIS MODULE
 JSR ENTRY
 [ $Level3
 LDAAX STRTNS
 STA STJUMP+1
 LDAAX STRTNS+1
 STA STJUMP+2
 LDAIM &F
 JSR SETFS ;SET FRAME SIZE
STJUMP JMP STJUMP
 |
 LDAIM &F
 JSR SETFS ;SET FRAME SIZE
 JMIX STRTNS
 ]
STRTNS
 & STDTSA ;1 => DISC ADDRESS TO STORE ADDRESS
 & STENWD ;2 => ENSURE WINDOW
 & STULWD ;3 => UNLOCK CACHED WINDOW
 & STFLWD ;4 => FLUSH WINDOW
 & STRALL ;5 => REMOVE ALL BLOCKS OF AN OBJECT FROM CACHE
 & STREST ;6 => RESTART
 & STGBB ;7 => GET BIG BUFFER
 & STEMPT ;8 => EMPTY THE CACHE OF ALL OBJECTS FROM A DISC
 & STRDRT ;9 => REMOVE ALL DIRTY BLOCKS OF AN OBJECT
STEXIT JMP PREXIT


;************ STDTSA ************


;STDTSA:   DISC ADDRESS TO STORE ADDRESS

;ENTRY: ARGB = LS(DISC NUMBER)
;ARGC = MS(DISC NUMBER)
;ARGD = LS(SIN)
;ARGE = CS(SIN)
;ARGF = MS(SIN)
;ARGG = LS(LOGICAL BLOCK NUMBER)
;ARGH = MS(LOGICAL BLOCK NUMBER)
;ARGI = LS(NO OF BLOCKS)
;ARGJ = MS(NO OF BLOCKS)

;EXIT:  ARGA = RC
;ARGB = LS(STORE ADDRESS)
;ARGC = MS(STORE ADDRESS)
;ARGD = LS(STORE ADDR OF CACHE DESCR)
;ARGE = MS(STORE ADDR OF CACHE DESCR)


;FUNCTION: THE CACHE IS SEARCHED TO SEE IF
;THE SPECIFIED WINDOW IS IN MEMORY.
;IF IT IS NOT IN THE CACHE THEN IT
;HAS TO BE READ FROM DISC.
;WHEN THE WINDOW IS IN THE CACHE
;THE ENTRY'S REFERNCE COUNT IS INCREMENTED
;AND ITS AGE SET TO MRU.
;NOTE IF THE WINDOW IS NOT FOUND
;IN THE CACHE IT IS NECESSARY TO
;FIND A STORE BUFFER INTO WHICH
;IT MAY BE READ FROM DISC-THIS CAN
;INVOLVE ONE, OR MORE, OLD WINDOWS
;BEING WRITTEN OUT TO CREATE SPACE.

;IF WINDOW IN CACHE
;THEN AGE OF BLOCK := MRU;
;REFERENCE COUNT OF WINDOW +:= 1
;ELSE GET A FREE STORE BUFFER; #THIS IS A LITTLE INVOLVED#
;READ OBJECT FROM DISC;
;AGE OF OBJECT := MRU;
;REFERENCE COUNT OF WINDOW := 1
;FI



STDTSA ROUT
 JSR TSTSIN
 BNE #20
 JSR INSRCH ;INIT PREV,CRNT,CMPPTR
10 LDXIM 9
 JSR COMP ;COMPARE DISC NO,SIN,BLK NO,NO OF BLOCKS
 BNE #30

;ITS IN THE CACHE

 JSR INCCNT ;REF COUNT +:= 1
 LDYIM CEAGE
 LDAIM MRU ;MARK IT MRU
 STAIY CRNT
 JSR RETSTA ;RETURN STORE ADDR & ADDR OF CRNT DESCR
 LDAIM 0
20
 [ $CMOS
 BRA #60
 |
 JMP #60
 ]

30 JSR NXTCRN ;CRNT:=NEXT OF CRNT
 BNE #10

;ITS NOT IN THE CACHE SO GET SOME FREE SPACE
;AND HAVE THE OBJECT READIN.

 LDYIM ARGI
 LDAIY ARGPTR
 STA BREGA
 INY
 LDAIY ARGPTR
 STA BREGA+1
 [ $CMOS
 STZ BREGA+2
 |
 LDAIM 0
 STA BREGA + 2
 ]
 JSR MULTBS ;BREGA *:=BLKSZE
 LDA BREGA+2
 BEQ #40
 LDAIM STERRE ;SIZE TO BIG
 [ $CMOS
 BRA #60
 |
 BNE #60
 ]

40 LDA BREGA
 STA AMTNED
 LDA BREGA+1
 STA AMTNED+1 ;AMTNED := BREGA
 JSR FREEST ;GET AMTNED WORTH OF FREE STORE
 BNE #60

;AT THIS POINT CRNT PTS TO A CACHE ENTRY
;DESCRIPTOR. NOW COPY DISC NO, SIN,
;BLKNO, NO OF BLOCKS INTO CRNT.

 CLC
 LDA ARGPTR
 ADCIM ARGB
 STA MOVFRM
 LDA ARGPTR+1
 ADCIM 0
 STA MOVFRM+1 ;MOVFRM := ARGPTR + ARGB
 LDA CRNT
 STA MOVTO
 LDA CRNT+1
 STA MOVTO+1
 LDXIM 9
 JSR MOVE

;READ OBJECT FROM DISC & INITIALISE REF COUNT & AGE

 JSR RETSTA ;PUT STORE ADDR ON ARGPTR STACK
 JSR READ ;READ OBJECT FROM DISC
 BEQ #50
 PHA ;Store return code
 LDYIM CERCNT
 LDAIM 0
 STAIY CRNT ;Make sure ref. count = 0
 PLA ;return code stored over REMVIT
 JSR REMVIT
 [ $CMOS
 BRA #60
 |
 BNE #60
 ]

50 LDYIM CERCNT
 LDAIM 1
 STAIY CRNT ;REF COUNT := 1
 LDYIM CEAGE
 LDAIM MRU
 STAIY CRNT ;AGE := MRU
 LDAIM 0 ;RC := 0
60 JMP STEXIT



;************ STENWD ************


;STENWD: ENSURE WINDOW. THIS ENSURES THAT A GIVEN
;WINDOW IS UPTO DATE ON DISC.

;ENTRY: ARGB = LS(WINDOW STORE ADDRESS)
;ARGC = MS(WINDOW STORE ADDRESS)
;ARGD = 0 => DON'T DECREMENT REF COUNT
;<> 0 => DECREMENT REF COUNT

;EXIT : ARGA = RC

;FUNCTION: 1) SEARCH CACHTB FOR ENTRY
;2) IF DIRTY WRITE TO DISC & MARK IT CLEAN
;3) DECREMENT ITS REFERENCE COUNT IF NEED BE



STENWD ROUT
 JSR FNDSTA
 BEQ #10
 JSR INTERR
10 JSR ENSURE ;ENSURE WINDOW UPTO DATE ON DISC
 PHA
 LDYIM ARGD
 LDAIY ARGPTR ;IS USE COUNT TO BE DECREMENTED
 BEQ #20
 JSR DECCNT
20 PLA
 BEQ #30 ;skip if all ok
 JSR REMVIT ;else remove the object from the cache
30 JMP STEXIT ;RC preserved




;************ STULWD ************


;STULWD: UNLOCK BUFFER. THIS FUNCTION DECREMENTS
;A STORE BUFFER'S REFERENCE COUNT.

;ENTRY: ARGB = LS(BUFFER STORE ADDRESS)
;ARGC = MS(BUFFER STORE ADDRESS)

;EXIT : ARGA = RC

;FUNCTION: 1) SEARCH THE CACHE FOR SPECIFIED BUFFER.
;2) DECREMENT THE BUFFER'S REFERENCE COUNT.

;NOTE THIS OPERATION WILL NOT WRITE THE BLOCK
;TO DISC EVEN IF IT IS MARKED DIRTY.


STULWD ROUT
 JSR FNDSTA
 BEQ #10
 JSR INTERR
10 JSR DECCNT
 LDAIM 0
 JMP STEXIT



;************ STFLWD ************


;STFLWD:FLUSH WINDOW. THIS FUNCTION INFORMS
;STRMAN THAT A STORE BUFFER WILL PROBABLY NOT
;BE NEEDED IN THE NEAR FUTURE.

;ENTRY: ARGB = LS(BUFFER STORE ADDRESS)
;ARGC = MS(BUFFER STORE ADDRESS)

;EXIT : ARGA = RC

;FUNCTION: 1) SEARCH CACHTB FOR THE BUFFER
;AND THEN DECREMENT ITS REFERENCE COUNT
;2) IF BUFFER MARKED 'DIRTY'
;THEN WRITE IT TO DISC
;3) AGE OF BUFFER := LRU (I.E. VERY OLD)
;4) IF REFCOUNT=0 THEN REMOVE OBJ FROM CACHE


STFLWD ROUT
 JSR FNDSTA
 BEQ #10
 JSR INTERR
10 JSR ENSURE
 PHA
 JSR DECCNT
 LDYIM CEAGE
 LDAIM LRU
 STAIY CRNT
 JSR TSTCNT
 BNE #20
 JSR REMVIT
20 PLA ;RC from ENSURE
 JMP STEXIT



;************ STRALL ************


;STRALL: REMOVES ALL THE BLOCKS, BELONGING TO
;A SPECIFIED FILE, FROM THE CACHE.
;NOTE IT IS ASSUMED THAT STEPS ARE TAKEN,
;BEFORE STRALL IS CALLED, TO
;AVOID BLOCKS OF THE FILE BEING LOADED.


;ENTRY: ARGB = LS(DISC NUMBER)
;ARGC = MS(DISC NUMBER)
;ARGD = LS(SIN)
;ARGE = CS(SIN)
;ARGF = MS(SIN)

;EXIT : ARGA = RC

;FUNCTION: 1) SCAN THE CACHTB REMOVING ALL THE
;WINDOWS BELONGING TO THIS FILE.
;2) THE WINDOWS MARKED DIRTY ARE WRITTEN TO DISC.
;3) THE WINDOWS ARE THEN REMOVED FROM
;THE CACHE.


STRALL ROUT
 JSR TSTSIN
 BNE #10

 LDXIM 5 ;COMPARE DISC NUMBER & SIN
 JSR EXPELL ;REMOVE ALL OBJECTS WITH GIVEN DISC NO & SIN

10 JMP STEXIT


;************ STREST ************


;STREST: RESTART
;1)GETVEC SPACE FOR
;a)THE BIG BUFFER
;b)FIRST CACHE ENTRY DESCRIPTOR & MAKE
;CACHTB PT TO IT.
;c)NUMBCE+1 CACHE ENTRY DESCRIPTORS & PUT
;THEM ON THE FREE CHAIN (FRECHN).
;d)THE CACHE ITSELF (CACHSZ BYTES)




STREST ROUT
 LDYIM :LSB:LGBFSZ ;Y:=LS(SIZE OF BIG BUFFER)
 LDXIM :MSB:LGBFSZ ;X:=MS(SIZE OF BIG BUFFER)
 JSR GETVEC ;Get big buffer
 STY BIGBUF
 STX BIGBUF+1 ;BIGBUF:=ADDR OF BIG BUFFER

;CREATE THE FIRST CACHE DESCRIPTOR (CACHTB)

 JSR CRDESC
 LDA CRNT
 STA CACHTB
 LDA CRNT+1
 STA CACHTB+1 ;CACHTB := ADDR OF DESC. FOR 1ST ENTRY

;NOW CALCULATE NO. OF CACHE DESCRIPTORS
;AND CACHE SIZE.

;CACHSZ := ENDPTR-FREPTR
;CACHSZ -:= (DESC. SIZE) * 2
;NO. OF OBJECTS := CACHSZ / (OBJECT SIZE+DESC. SIZE)
;CACHSZ -:= DESC.SIZE*NO. OF OBJECTS


 LDAIM CESIZE
 ROLA
 STA TEMPA ;TEMPA := DESC. SIZE * 2
 SEC
 LDA ENDPTR
 SBC FREPTR
 SBC TEMPA
 STA DIVPAR
 STA CACHSZ
 LDA ENDPTR+1
 SBC FREPTR+1
 STA DIVPAR+1
 STA CACHSZ+1

 LDXIM 0
10 SEC
 LDA DIVPAR
 SBCIM CESIZE ;(Object size + desc. size) lo
 STA DIVPAR
 LDA DIVPAR+1
 SBCIM 1 ;(Object size + desc. size) hi
 STA DIVPAR+1
 BCC #20
 INX
 ORA DIVPAR
 BEQ #20
 BCS #10
20 STX NUMBCE ;No. of cache objects :
30 SEC ;NOW SUBTRACT C.D. SIZE, NUMBCE TIMES
 LDA CACHSZ
 SBCIM CESIZE
 STA CACHSZ
 BCS #35
 DEC CACHSZ+1
35 DEX
 BNE #30

 [ $Level3
 JSR VSTRIN
 = CR,"Cache size - "
 NOP

 LDA CACHSZ+1
 JSR WHEX
 LDA CACHSZ
 JSR WHEX

 JSR VSTRIN
 = " objects - "
 NOP

 LDA NUMBCE
 JSR WHEX
 JSR OSCRLF
 ]

;NOW CREATE (NUMBCE+1) DESCRIPTORS & PLACE THEM ON
;THE FREE CHAIN.

 [ $CMOS
 STZ FRECHN
 STZ FRECHN+1 ;FRECHN := 0
 |
 LDAIM 0
 STA FRECHN
 STA FRECHN+1 ;FRECHN := 0
 ]
 LDX NUMBCE
 INX ;X:=NUMBCE+1
40 JSR CRDESC ;CREATE A DESCRIPTOR
 JSR MKFREE ;PLACE IT ON THE FREE CHAIN
 DEX
 BNE #40

;NOTE THAT THE FOLLOWING CODE IS ONLY TEMPORARY
;EVENTUALLY WE WANT TO USE THE REMAINDER OF FREE STORE
;FOR THE CACHE (N.B. CREATEING SUFFICIENT DESCRIPTORS).

;NOW CREATE THE CACHE AREA ITSELF

 LDY CACHSZ ;Y:=LS(SIZE OF CACHE AREA)
 LDX CACHSZ+1 ;X:=MS(SIZE OF CACHE AREA)
 JSR GETVEC
 STY CLRPTR
 STX CLRPTR+1

;MAKE FIRST DESCRIPTOR PT TO FIRST FREE CACHE BYTE

 JSR STCRNT ;PREV:=CACHTB
 LDYIM CESTA
 LDA CLRPTR
 STAIY PREV
 LDA CLRPTR+1
 INY
 STAIY PREV ;STORE OF PREV := PTR TO FIRST FREE BYTE

 JSR FRDESC ;GET A FREE DESCRIPTOR
 LDYIM CENEXT
 LDA CRNT
 STAIY PREV
 LDAIM 0
 STAIY CRNT
 INY
 LDA CRNT+1
 STAIY PREV ;NEXT OF PREV := CRNT
 LDAIM 0
 STAIY CRNT ;NEXT OF CRNT := 0

;MAKE LAST DESCRIPTOR POINT TO LAST+1 FREE BYTE

 LDYIM CESTA
 SEC ;BECAUSE WE WANT TO ADD 1
 LDA CLRPTR
 ADC CACHSZ
 STAIY CRNT
 LDA CLRPTR+1
 ADC CACHSZ+1
 INY ;Y := CESTA + 01
 STAIY CRNT

;NOW CLEAR WHOLE OF THE CACHE TO ZERO

 LDY CACHSZ
 LDX CACHSZ+1
 JSR CLRSTR

 LDAIM 0 ;RC := 0
 JMP STEXIT



;************ STGBB *************


;STGBB: GET BIG BUFFER
;THIS FUNCTION SUPPLIES THE STORE ADDRES
;AND SIZE OF A LARGE BUFFER.
;THIS BUFFER SHOULD BE USED FOR LARGE
;TRANSFERS TO AND FROM THE DISC.
;ENTRY:
;EXIT : ARGB = LS(BUFFER STORE ADDRESS)
;ARGC = MS(BUFFER STORE ADDRESS)
;ARGD = LS(SIZE OF BUFFER)
;ARGE = MS(SIZE OF BUFFER)



STGBB ROUT
 LDYIM ARGB
 LDA BIGBUF
 STAIY ARGPTR ;LS(BUFFER ADDRESS)
 INY ;Y:=ARGC
 LDA BIGBUF+1
 STAIY ARGPTR ;MS(BUFFER ADDRESS)
 INY ;Y:=ARGD
 LDAIM :LSB:LGBFSZ
 STAIY ARGPTR ;LS(BUFFER SIZE)
 INY ;Y:= ARGE
 LDAIM :MSB:LGBFSZ
 STAIY ARGPTR ;MS(BUFFER SIZE)
 LDAIM 0
 JMP STEXIT



;************ STEMPT ************


;STEMPT: EMPTY THE CACHE OF ALL THE OBJECTS WHICH
;CAME FROM A SPECIFIED DISC.

;ENTRY: ARGB = LS(DISC NUMBER)
;ARGC = MS(DISC NUMBER)

;EXIT : ARGA = RC


STEMPT ROUT
 LDXIM 2 ;COMPARE DISC NUMBER
 JSR EXPELL ;REMOVE ALL OBJECTS ON SPECIFIED DISC FROM CACHE
 JMP STEXIT

;STRDRT: REMOVES ALL THE DIRTY  BLOCKS, BELONGING TO
;A SPECIFIED FILE, FROM THE CACHE.
;NOTE IT IS ASSUMED THAT STEPS ARE TAKEN,
;BEFORE STRALL IS CALLED, TO
;AVOID BLOCKS OF THE FILE BEING LOADED.


;ENTRY: ARGB = LS(DISC NUMBER)
;ARGC = MS(DISC NUMBER)
;ARGD = LS(SIN)
;ARGE = CS(SIN)
;ARGF = MS(SIN)

;EXIT : ARGA = RC

;FUNCTION: 1) SCAN THE CACHTB REMOVING ALL THE DIRTY
;WINDOWS BELONGING TO THIS FILE.
;2) THE WINDOWS MARKED DIRTY ARE WRITTEN TO DISC.
;3) THE WINDOWS ARE THEN REMOVED FROM
;THE CACHE.


STRDRT ROUT
 JSR TSTSIN
 BNE #10

 LDAIM &FF ;=> Only remove DIRTY windows
 LDXIM 5 ;COMPARE DISC NUMBER & SIN
 JSR EXPELA ;REMOVE ALL DIRTY OBJECTS
;WITH GIVEN DISC NO & SIN
10 JMP STEXIT

 LNK Uade0B
