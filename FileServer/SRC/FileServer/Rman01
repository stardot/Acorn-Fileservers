 OPT RMAN01 ; > <FileServerSource>.Rman01
 TTL File server file RMAN01

RMNORG

 ORG RMNORG

;Set up ORG address so second pass gets
;addresses right when doing 2nd pass only

;Second pass also needs source and object
;drives correctly set.


;*********************************
;*          R N D M A N          *
;*********************************



;RNDMAN: THE RANDOM ACCESS MANAGER IS RESPONSIBLE
;FOR MAINTAINING A LIST OF OPENED OBJECTS
;(HANDTB) & FOR KEEPING VARIOUS DETAILS
;ABOUT OPENED FILES (RANDTB).
;RNDMAN PROVIDES THE FOLLOWING FUNCTIONS:-

;1) OPEN OBJECT (GIVE HANDLE)
;2) INFO (INDICATE WHETHER OPEN)
;3) CLOSE OBJECT
;4) RESTART
;5) CREATE A HANDLE FOR AN OBJECT WITH SPECD HANDLE
;6) DELETE ALL HANDLES FOR A GIVEN M/C
;7) READ BYTE FROM FILE
;8) WRITE BYTE TO FILE
;9) GETBYTES
;10) PUTBYTES
;11) Read args of open file
;12) Set args of open file
;13) Close all files for machine
;14) Set up for PUTBYTES/GETBYTES calls



;THE HANDTB CONTAINS THE FOLLOWING
;INFO:-
;0) HANDLE
;1) MC/NO
;2) TYPE AND ACCESS
;3) DISC NUMBER
;4) SIN
;5) MODE - MULTIPLE READER/SINGLE WRITER
;6) RANDTB OFFSET



;********* MAIN ROUTINE ***********



RNDMAN ROUT
 LDXIM &F ;RNDMAN HAS 15 ENTRY POINTS
 LDAIM MODRND ;A:=NAME OF THIS MODULE
 JSR ENTRY

 [ $CMOS
 LDAIM &F
 JSR SETFS ;SET FRAME SIZE
 JMIX RDRTNS
 |
 LDAAX RDRTNS
 STA RDJUMP+1
 LDAAX RDRTNS+1
 STA RDJUMP+2
 LDAIM &F
 JSR SETFS ;SET FRAME SIZE
RDJUMP JMP RDJUMP
 ]
RDRTNS
 & RDOPEN ;1 => OPEN OBJECT (ISSUE A HANDLE)
 & RDINFO ;2 => INFO (INDICATE WHETHER OBJECT IS OPEN)
 & RDCLOS ;3 => CLOSE OBJECT (INVALIDATE HANDLE)
 & RDREST ;4 => RESTART
 & RDCOPY ;5 => GENERATE ANOTHER HANDLE FOR AN OBJECT
 & RDCLAL ;6 => DELETE ALL HANDLES FOR A USER
 & RDRDCH ;7 => READCH
 & RDWRCH ;8 => WRITECH
 & RDGBTS ;9 => GETBYTES FROM FILE
 & RDPBTS ;10 => PUTBYTES TO FILE
 & RDRDAR ;11 => Read args of file
 & RDSTAR ;12 => Set args of file
 & RDCLAF ;13 => Close all files for machine
 & RDSUBO ;14 => Set up for bytes operation
 & RDEOF ;15 => Read "end of file" status

RDEXIT JMP PREXIT



;************ RDOPEN ************


;RDOPEN: OPEN AN OBJECT & RETURN A HANDLE FOR IT.

;ENTRY:
;ARGB-C PTR TO USERINFO
;ARGD = MODE(HOW OBJECT SHOULD BE OPENED)
;ARGE = TYPE & ACCESS ALLOWED TO OBJECT
;ARGF-G PTR TO OBJECT DETAILS

;NOTE:- ARGD (MODE)
;BIT 0 => READ ACCESS NEEDED
;BIT 1 => WRITE ACCESS NEEDED
;BIT 7 => FILE JUST CREATED
;RNDMAN INFORCES MULTIPLE READER - SINGLE WRITER
;INTERLOCKS.

;EXIT : ARGA = RC
;ARGB = HANDLE

;FUNCTION: MAKE HANDTB ENTRY
;IF TYPE OF OBJECT = TYPFIL
;THEN MAKE NEW RANDTB ENTRY
;FI


RDOPEN ROUT
 JSR INITRD ;INITIALISE MCNUMB,&GETPTR:=USERINFO,RNDPTR

;SEE IF THIS MACHINE CAN OPEN ANOTHER FILE
;AND SEE WHETHER THERE IS ANY ROOM IN THE HANDTB

 JSR GETHND ;HNDPTR:=PTR TO A FREE HANDTB ENTRY
 BNE #60
 LDYIM ARGE
 LDAIY ARGPTR ;TYPE & ACCESS
 ANDIM TYPDIR
 BNE #50

;ITS A FILE SO SEE IF THERE IS ROOM IN RANDTB

;The object is a file: must check that it can be opened
;for the requested access. (A file may be held open by
;a single writer, or by multiple readers).
;If it may be opened, then find a slot in RANDTB and
;fill it in.  A pointer to the entry in RANDTB is
;put in HANDTB (stored in 2 bytes).

 JSR RDCKAC ;Check access allowed (corrupts HNDPTR)
 BNE #60 ;not ok
 JSR GETHND ;HNDPTR := free HANDTB entry
 BNE #60 ;Didn't get one
 JSR GETRND ;RTEPTR := free RANDTB entry
 BNE #60 ;not got one

 LDA RTEPTR ;Store RANDTB entry ptr in HANDTB entry
 LDYIM HTRPTR
 STAIY HNDPTR
 INY
 LDA RTEPTR+1
 STAIY HNDPTR

;Fill in new RANDTB entry (currently all zero)

 LDAIM &80 ;"In use" flag + seq num zero
 LDYIM RTINUS
 STAIY RTEPTR ;Mark entry "in use"

;Current and old sequential file pointers
;already set to zero.
;High water mark and size both set from
;file size in object details.

 LDAIM RTFSZE
 JSR #80 ;Little block move routine

;High water mark used only if the object is open for
;update.  If the file is new, then leave zero, otherwise
;set to file size.

 LDYIM ARGD ;Get mode byte
 LDAIY ARGPTR
 ANDIM FILEJC ;Test file just created
 BNE #40 ;Jump if new file

;File existed before: set HWM to size

 LDAIM RTHWM
 JSR #80

40
;Leave address of cache descriptor (hint) to
;be filled in on first read/write operation
;** END OF FILE CODE **


;FIRST MARK HANDLE IN USE (IN USERTB ENTRY)

50 JSR MHINUS ;MARK HANDLE IN USE - IN USERTB ENTRY

;NOW COPY DETAILS (HANDLE,DISC NO,SIN, ETC.)
;INTO THE HANDTB (HNDPTR WAS SET BY GETHND)

 LDYIM HTHAND
 LDA RNDTMP
 STAIY HNDPTR ;HANDLE

 LDYIM HTMCNO
 LDA MCNUMB
 STAIY HNDPTR
 INY
 LDA MCNUMB+1
 STAIY HNDPTR
 INY
 LDA MCNUMB+2 ;**25/12/86**
 STAIY HNDPTR ;MACHINE NUMBER

 LDYIM ARGE
 LDAIY ARGPTR
 LDYIM HTACC
 STAIY HNDPTR ;TYPE & ACCESS

 LDXIM INFDIS
 LDYIM HTDISC
 LDAIM 2
 JSR #70

 LDXIM INFSIN
 LDYIM HTSIN
 LDAIM 3
 JSR #70

 LDYIM ARGD
 LDAIY ARGPTR
 LDYIM HTMODE
 STAIY HNDPTR ;MODE

 LDAIM 0 ;RC := 0

60 PHA
 LDA RNDTMP  ;A:=HANDLE
 LDYIM ARGB
 STAIY ARGPTR
 PLA
 JMP RDEXIT


70 STX OFF1
 STY OFF2
 LDXIM RNDPTR ;Move stuff from RNDPTR
 LDYIM HNDPTR ;To HNDPTR
 JMP MOVBLK


80 STA OFF2
 LDAIM INFSZE ;Move size from
 STA OFF1 ;RNDPTR to RTEPTR (offset already set)
 LDXIM RNDPTR
 LDYIM RTEPTR
 LDAIM 3
 JMP MOVBLK


;************ RDINFO ************


;RDINFO: SEARCH THE HANDTB TO DETERMINE WHETHER
;A PARTICULAR OBJECT IS OPEN.

;ENTRY: ARGB = LS(DISC NO)
;ARGC = MS(DISC NO)
;ARGD = LS(SIN)
;ARGE = CS(SIN)
;ARGF = MS(SIN)

;EXIT : ARGA = RC (0 => OBJECT OPEN)
;     : ARGB = MODE OF ACCESS (**28/4/83**)


RDINFO ROUT
 JSR INITHD ;HNDPTR:=HANDTB,X:=HTENTS
 CLC
 LDA ARGPTR
 ADCIM ARGB
 STA MOVFRM
 LDA ARGPTR+1
 ADCIM 0
 STA MOVFRM+1 ;MOVFRM := ARGPTR + ARGB

10 LDYIM HTHAND
 LDAIY HNDPTR
 BEQ #20 ;ENTRY IN USE ??
 CLC
 LDA HNDPTR
 ADCIM HTDISC
 STA MOVTO
 LDA HNDPTR+1
 ADCIM 0
 STA MOVTO+1 ;MOVTO := HNDPTR + HTDISC

 [ $CMOS
 PHX
 LDXIM 5 ;COMPARE DISC & SIN
 JSR COMPAR
 PLX
 TAY
 |
 TXA
 PHA
 LDXIM 5 ;COMPARE DISC & SIN
 JSR COMPAR
 TAY
 PLA
 TAX
 TYA
 ]
 BEQ #30

20 JSR INCHND
 BNE #10
 LDAIM RDERRE ;OBJECT NOT OPEN

30 PHA ;save A
 BNE #40

 LDYIM HTMODE
 LDAIY HNDPTR ;get mode from table
 LDYIM ARGB
 STAIY ARGPTR ;for return
 JSR RDopat ;**20/5/87** set 'open at' details

40 PLA
 JMP RDEXIT



;************ RDCLOS ************


;RDCLOS: CLOSE - INVALIDATE A HANDLE

;ENTRY: ARGB = LS(PTR TO USER INFO)
;ARGC = MS(PTR TO USER INFO)
;ARGD = HANDLE

;EXIT : ARGA = RC


RDCLOS ROUT
 JSR INITRD ;SETUP GENPTR & MCNUMB
 LDYIM ARGD
 LDAIY ARGPTR ;A := HANDLE
 BNE #10
 LDAIM RDERRB ;BAD HANDLE
 [ $CMOS
 BRA #20
 |
 BNE #20
 ]

10 STA RNDTMP ;RNDTMP := HANDLE
 JSR FNDHND ;SEARCH HANDTB FOR THE HANDLE
 BNE #20


;NOW CLEAR HANDTB (RANDTB) ENTRY
;and mark handle free in USERTB

 JSR CLRHTE

20 JMP RDEXIT



;************ RDREST ************


;RDREST: RESTART
;CREATE BOTH HANDTB & RANDTB.
;THE VARIABLES HANDTB & RANDTB ARE INITIALISED
;TO POINT TO THE FIRST ENTRY OF BOTH
;TABLES.

;NOTE - HANDLE TABLE HAS 6*USERS ENTRIES,
;AND RAND TABLE 5*USERS ENTRIES.


RDREST ROUT
 LDA USERS ;First create handle table
 LDXIM 5
 CLC
30 ADC USERS
 BCS #40
 DEX
 BNE #30
 [ $CMOS
 BRA #10
 |
 BEQ #10
 ]

40 LDAIM &FF
10 CMPIM 9
 BCS #20
 LDAIM 9
20 PHA
 STA HTENTS
 TAX
 LDYIM HTENSZ
 JSR SETTAB ;SET HANDLE TABLE
 STY HANDTB
 STX HANDTB+1

 PLA
 SEC
 SBC USERS
 STA RTNENT ;Store no. of RT entries
 TAX
 LDYIM RTENSZ
 JSR SETTAB
 STY RANDTB
 STX RANDTB+1
 LDAIM  0
 JMP RDEXIT



;************ RDCOPY ************


;RDCOPY: CREATE ANOTHER HANDLE FOR AN OBJECT
;(OOF TYPE DIR).  N.B. RNDMAN.RDCOPY IS
;USED BY USRMAN WHEN SELECTING A USER'S UFD.

;ENTRY: ARGB = LS(PTR TO USERINFO)
;AFGC = MS(PTR TO USERINFO)
;ARGD = HANDLE (FOR A DIR)

;EXIT : ARGA = RC
;ARGE = NEW HANDLE


RDCOPY ROUT
 JSR INITRD ;SETUP GENPTR & MCNUMB
 LDYIM ARGD
 LDAIY ARGPTR
 JSR FNDHND
 BNE #20
 LDA HNDPTR
 STA MOVFRM
 LDA HNDPTR+1
 STA MOVFRM+1 ;MOVFRM := PTR TO HANDTB ENTRY
 LDYIM HTACC
 LDAIY HNDPTR
 [ $CMOS
 BITIM TYPDIR ;IS HANDLE FOR A DIR?
 |
 ANDIM TYPDIR ;IS HANDLE FOR A DIR?
 ]
 BNE #10
 LDAIM RDERRF ;RDCOPY ONLY AVAILABLE FOR DIRECTORIES
 JSR INTERR
10 JSR GETHND ;HNDPTR:=PTR TO FREE HANDTB ENTRY
 BNE #20
 JSR MHINUS ;MARK THE HANDLE IN USE IN USERTB
 LDA HNDPTR
 STA MOVTO
 LDA HNDPTR+1
 STA MOVTO+1
 LDXIM HTENSZ
 JSR MOVE ;COPY OBJECT DETAILS INTO NEW USERTB ENTRY
 LDYIM ARGE
 LDA RNDTMP ;A := HANDLE TO BE USED (SETBY GETHND)
 STAIY ARGPTR
 LDYIM HTHAND
 STAIY HNDPTR ;PUT NEW HANDLE IN HANDTB ENTRY
 LDAIM 0 ;RC:=0
20 JMP RDEXIT




;************ RDCLEAR ALL *************


;RDCLAL: DELETE ALL HANDLES BELONGING
;TO A MACHINE.

;ENTRY: ARGB = LS(PTR TO USERINFO)
;ARGC = MS(PTR TO USERINFO)

;EXIT: ARGA = RETURN CODE


RDCLAL ROUT
 JSR INITRD ;SET GENPTR/MCNUMB/RDUPTR
 JSR INITHD ;SET HNDPTR

10 LDYIM HTMCNO ;M/C NUMBER
 LDAIY HNDPTR
 CMP MCNUMB
 BNE #30
 INY
 LDAIY HNDPTR
 CMP MCNUMB+1
 BNE #30
 INY
 LDAIY HNDPTR
 CMP MCNUMB+2 ;**25/12/86**
 BNE #30

;FOUND, SO DELETE

 LDA RDUPTR
 STA GENPTR
 LDA RDUPTR+1
 STA GENPTR+1 ;Ensure GENPTR pointing to right place

 [ $CMOS
 PHX
 |
 TXA
 PHA
 ]
 JSR CLRHTE ;CLEAR TABLE ENTRY
 [ $CMOS
 PLX ;tidy up stack
 TAX
 |
 TAX
 PLA ;tidy up stack
 TXA
 ]
 BNE #40
30 JSR INCHND ;INC. PTR
 BNE #10 ;(X DEC'D IN INCHND)

 LDAIM 0
40
 JMP RDEXIT




;GETHND: CHOOSE A HANDLE & A SLOT IN THE HANDTB
;WHICH ARE FREE.
;NOTE THAT EACH MACHINE CAN HAVE UPTO 8 HANDLES.
;THE HANDLES CURRENTLY BEING USED BY A
;PARTICULAR MACHINE ARE RECORDED IN THE USERTB.

;ENTRY: GENPTR = PTR TO USER INFO

;EXIT : A = RC
;HNDPTR = POINTER TO A FREE HANDTB ENTRY
;RNDTMP = HANDLE TO BE USED


GETHND ROUT
 LDYIM UTHNDB ;HANDLE BYTE HELD IN USERTB
 LDAIY GENPTR

;FIRST SEE IF THIS MACHINE HAS A FREE HANDLE

 CMPIM &FF
 BNE #10
 LDAIM RDERRC ;HANDLE QUOTA EXHAUSTED
 RTS

10 LDYIM 1
 STY RNDTMP
20 LSRA
 BCC #30 ;FOUND A FREE HANDLE
 ASL RNDTMP
 [ $CMOS
 BRA #20
 |
 JMP #20
 ]

;NOW SEE IF THERE IS A FREE SLOT IN HANDTB

30 JSR INITHD ;HNDPTR := HANDTB
 LDYIM HTHAND
40 LDAIY HNDPTR
 BEQ #50
 JSR INCHND
 BNE #40
 LDAIM RDERRD ;HANDTB FULL
50 RTS


INITRD ROUT
 LDYIM ARGB ;INIT GENPTR,MCNUMB,RNDPTR
 LDAIY ARGPTR
 STA GENPTR
 STA RDUPTR ;Store extra copy of user pointer INY
 INY
 LDAIY ARGPTR ;(used by RDCLAL and RDCLAF)
 STA GENPTR+1 ;GENPTR := PTR TO USERINFO
 STA RDUPTR+1 ;Extra copy high byte

 LDYIM UTMCNO
 LDAIY GENPTR
 STA MCNUMB
 INY
 LDAIY GENPTR
 STA MCNUMB+1
 INY
 LDAIY GENPTR
 STA MCNUMB+2 ;MCNUMB initialised **25/12/86**

 LDYIM ARGF
 LDAIY ARGPTR
 STA RNDPTR
 INY
 LDAIY ARGPTR
 STA RNDPTR+1 ;RNDPTR := PTR TO OBJECT INFO(SEE DIRMAN.RETR)
 RTS


MHINUS ROUT
 LDYIM UTHNDB ;MARK A HANDLE IN USE IN USERTB
 LDA RNDTMP ;A:=HANDLE (SEE GETHND)
 ORAIY GENPTR
 STAIY GENPTR
 RTS


;Mark handle free in USERTB
;GENPTR points at USERTB entry
;A      contains handle

MHFREE ROUT
 LDYIM UTHNDB ;Mark handle free in USERTB
 EORIM &FF ;Invert handle in A
 ANDIY GENPTR ;Clear handle bit
 STAIY GENPTR ;Put back in USERTB
 RTS



CLRHTE ROUT ;CLRHTE

;CLEAR HANDLE TABLE ENTRY POINTED TO
;BY HNDPTR. IF ENTRY IS FOR A FILE,
;CLEAR CORRESPONDING RANDOM TABLE ENTRY.
;The handle bit in the USERTB entry
;(pointed to by GENPTR) is cleared.

 LDYIM HTHAND ;Get handle in A
 LDAIY HNDPTR
 JSR MHFREE ;Mark handle free in USERTB

 LDYIM HTACC
 LDAIY HNDPTR
 ANDIM TYPE
 CMPIM TYPDIR
 BEQ #10
 JSR RDFLSH ;Flush object from cache
 BNE #30 ;**** 17/3/83 ****
 JSR RDSFSZ ;Set size from HWM
 JSR CLRRTE ;Clear RANDTB entry

10 LDYIM HTENSZ-1 ;Y := SIZE OF HANDTB ENTRY
 LDAIM 0
20 STAIY HNDPTR
 DEY
 BPL #20 ;A zero already
 TAY
30 RTS



;*** RDSFSZ ***

;If the file is open for update, then set
;its size to the HWM recorded in RANDTB.

;Entry: HNDPTR points to HANDTB entry for file

;Exit:  RC in A

RDSFSZ 
 LDYIM HTMODE ;Get mode in which open
 LDAIY HNDPTR
 ANDIM WRITAC ;Open for writing ?
 BEQ #30 ;Yes, exit A=0 and Z set

 JSR SETRPT ;Set RTEPTR
 LDYIM RTHWM
 LDAIY RTEPTR ;HWM LS
 STA NEWFSZ
 INY
 LDAIY RTEPTR ;HWM CS
 STA NEWFSZ+1
 INY
 LDAIY RTEPTR ;HWM MS
 STA NEWFSZ+2

 JMP RDCHSZ ;Change size and exit


 LNK Rman02
