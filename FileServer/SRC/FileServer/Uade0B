 OPT UADE0B ; > <FileServerSource>.Uade0B
 TTL File server file UADE0B


;**********************************
;*        STRMAN UTILITIES        *
;**********************************


CRDESC ROUT
 [ $CMOS
 PHY ;CREATE A NEW DESCRIPTOR
 PHX
 |
 TYA ;CREATE A NEW DESCRIPTOR
 PHA
 TXA
 PHA
 ]
 LDYIM CESIZE
 LDXIM 0
 JSR GETVEC
 STY CRNT
 STY CLRPTR
 STX CRNT+1 ;CRNT := ADDR OF NEW DESCRIPTOR
 STX CLRPTR+1
 LDYIM CESIZE
 LDXIM 0
 JSR CLRSTR ;CLEAR DESCRIPTOR TO ZERO
 [ $CMOS
 PLX
 PLY
 |
 PLA
 TAX
 PLA
 TAY
 ]
 RTS

MKFREE ROUT
 [ $CMOS
 PHX ;PUSH X
 |
 TXA
 PHA
 ]
 LDXIM CESIZE ;CLEAR CRNT DESCRIPTOR
 LDAIM 0
 TAY
10 STAIY CRNT
 INY
 DEX
 BNE #10
 LDA FRECHN ;PLACE CRNT DESCRIPTOR ON FREE CHAIN
 LDYIM CENEXT
 STAIY CRNT
 LDA FRECHN+1
 INY
 STAIY CRNT ;NEXT OF CRNT := (FRECHN)
 LDA CRNT
 STA FRECHN
 LDA CRNT+1
 STA FRECHN+1 ;FRECHN := CRNT
 [ $CMOS
 PLX ;PULL X
 |
 PLA
 TAX
 ]
 RTS


FRDESC ROUT
 LDA FRECHN ;REMOVE A DESCRIPTOR FROM FREE CHAIN
 STA CRNT
 LDA FRECHN+1
 STA CRNT+1 ;CRNT := PTR TO A FREE ENTRY
 ORA CRNT
 BNE #10
 LDAIM STERRG ;NO FREE CACHE DESCRIPTORS
 JSR INTERR
10 LDYIM CENEXT
 LDAIY CRNT
 STA FRECHN
 INY
 LDAIY CRNT
 STA FRECHN+1 ;FRECHN:=NEXT OF CRNT
 RTS


STCRNT LDA CACHTB ;PREV:=CACHTB;CRNT:=NEXT OF PREV
 STA PREV
 LDA CACHTB+1
 STA PREV+1
 LDYIM CENEXT
 LDAIY PREV
 STA CRNT
 INY
 LDAIY PREV
 STA CRNT+1
 RTS


INSRCH JSR STCRNT ;INITIALISE CRNT,CMPPTR
 CLC
 LDA ARGPTR
 ADCIM ARGB
 STA CMPPTR
 LDA ARGPTR+1
 ADCIM 0
 STA CMPPTR+1
 RTS


NEXTCE ROUT
 LDYIM CENEXT ;PREV:=CRNT;CRNT:=NEXT OF CRNT
 LDAIY CRNT
 INY
 ORAIY CRNT
 BEQ #10 ;NO MORE ENTRIES (A=0)
 LDA CRNT
 STA PREV
 LDA CRNT+1
 STA PREV+1
 DEY ;Y := CENEXT
 LDAIY CRNT
 TAX
 INY
 LDAIY CRNT
 STA CRNT+1
 TXA
 STA CRNT
 LDAIM &FF ;A INDICATES THAT THERE ARE MORE ENTRIES
10 RTS


COMP ROUT
 TXA  ;COMPARE CRNT ENTRY WITH X ARGS
 TAY
10 DEY
 LDAIY CMPPTR
 CMPIY CRNT
 BNE #20
 DEX
 BNE #10
20 TXA
 RTS


TSTSIN ROUT
 LDYIM ARGD
 LDAIY ARGPTR
 INY
 ORAIY ARGPTR
 INY
 ORAIY ARGPTR
 BNE #10
 LDAIM STERRB ;SIN = 0
 RTS

10 LDAIM 0
 RTS


RETSTA LDYIM CESTA
 LDAIY CRNT
 LDYIM ARGB
 STAIY ARGPTR ;LS(STORE ADDRESS)
 LDYIM CESTA+1
 LDAIY CRNT
 LDYIM ARGC
 STAIY ARGPTR ;MS(STORE ADDRESS)
 INY ;Y := ARGD
 LDA CRNT
 STAIY ARGPTR
 INY
 LDA CRNT+1
 STAIY ARGPTR ;ADDRESS OF CRNT DESCRIPTOR
 RTS


READ JSR MRKCLN ;MARK BUFFER CLEAN
 LDAIM 1 ;READ OBJECT
 JSR SETRTN ;DSCMAN.READ
 [ $CMOS
 BRA TRANSF
 |
 JMP TRANSF
 ]


ENSURE ROUT
 JSR TSTMRK ;IS IT DIRTY?
 BEQ #10
 LDAIM 2
 JSR SETRTN
 JSR TRANSF ;WRITE IT TO DISC
 BNE #10
 JSR MRKCLN ;preserve return code from TRANSF
10 RTS


TRANSF LDA CRNT
 STA MOVFRM
 LDA CRNT+1
 STA MOVFRM+1
 CLC
 LDA NEWARG
 ADCIM ARGB
 STA MOVTO
 LDA NEWARG+1
 ADCIM 0
 STA MOVTO+1
 LDXIM &B ;DISC NO -> STORE ADDRESS
 JSR MOVE
 JMP DSCMAN


REMVIT ROUT
 PHA ;PUSH A
 JSR TSTCNT
 BEQ #10
 LDAIM STERRH
 JSR INTERR
10 LDYIM CENEXT ;REMOVE CRNT FROM IN USE CHAIN
 LDAIY CRNT
 STAIY PREV
 PHA
 INY
 LDAIY CRNT
 STAIY PREV ;NEXT OF PREV := NEXT OF CRNT
 PHA
 JSR MKFREE ;PLACE IT ON FREE CHAIN
 PLA
 STA CRNT+1
 PLA
 STA CRNT ;CRNT := NEXT OF PREV
 PLA ;PULL A
 RTS


;EXPELL: ROUTINE TO REMOVE OBJECTS FROM THE CACHE.
;ENTRY: X := 2 => MATCH ON DISC NUMBER (I.E. ARGB&ARGC)
;X := 5 => MATCH ON DISC NUMBER + SIN

;THE ENTRY EXPELA IS USED FROM STRDRT WITH
;A NON-ZERO TO INDICATE THAT ONLY DIRTY
;BLOCKS SHOULD BE REMOVED FROM THE CACHE.

EXPELL ROUT
 LDAIM 0 ;=> REMOVE ALL BLOCKS REGARDLESS
EXPELA PHA
 STX STRTMP ;STRTMP := X
 JSR INSRCH
20 LDX STRTMP
 JSR COMP ;COMPARE DISC NUMBER & (POSSIBLY) SIN
 BNE #60
 JSR TSTCNT
 BEQ #30
 LDAIM STERRH ;REF COUNT > 0
 JSR INTERR

;ENSURE THE OBJECT & THEN REMOVE IT FROM THE CACHE

30 PLA
 PHA
 BEQ #50 ;EQ => REMOVE ALL BLOCKS
 JSR TSTMRK ;NZ => REMOVE DIRTY BLOCKS ONLY
 BEQ #60 ;NOT DIRTY, GO TO NEXT BLOCK

 JSR ENSURE ;ENSURE ITS UPTO DATE ON DISC
 PHA ;save error code (4/4/86)
 LDYIM CEAGE ;Age entry considerably (16/1/85)
 LDAIM &80
 STAIY CRNT
 PLA 
 BNE #70 ;br if error
 [ $CMOS
 BRA #60
 |
 BEQ #60
 ]

50 JSR ENSURE ;Ensure up to date on disc
 JSR REMVIT ;Destroy file so remove all
 BNE #70 ;Detect disc errors
 LDYIM CENEXT ;REMVIT compacted everything
 LDAIY CRNT
 INY
 ORAIY CRNT
 BNE #20
60 JSR NEXTCE ;PREV:=CRNT;CRNT:=NEXT OF CRNT
 BNE #20
 PLA ;RESTORE STACK
 LDAIM 0 ;RC:=0
 RTS

70
 [ $CMOS
 PLX ;save A, clean stack
 TAX
 |
 TAX ;save A, clean stack
 PLA
 TXA
 ]
 RTS


FNDSTA ROUT
 LDYIM ARGB ;FIND CACHE ENTRY WITH GIVEN STORE ADDRESS
 LDAIY ARGPTR
 STA STRTMP
 INY
 LDAIY ARGPTR
 STA STRTMP+1
 JSR STCRNT
10 LDYIM CESTA
 LDAIY CRNT
 CMP STRTMP
 BNE #20
 INY
 LDAIY CRNT
 CMP STRTMP+1
 BEQ #30
20 JSR NEXTCE
 BNE #10
 LDAIM STERRF ;INVALID WINDOW ADDRESS
30 RTS


DECGEN SEC
 LDYIM CESTA
 LDAIY CRNT
 SBCIM 1
 STA GENPTR
 INY
 LDAIY CRNT
 SBCIM 0
 STA GENPTR+1
 RTS


MRKCLN PHA  ;MARK STORE BUFFER CLEAN
 [ $CMOS
 PHY ;SAVE Y
 |
 TYA
 PHA
 ]
 JSR DECGEN ;GENPTR SHOULD CONTAIN ADDRESS OF BUFFER
 LDAIM 0 ;A := 0
 [ $CMOS
 STAI GENPTR ;[GENPTR] := 0
 PLY ;PULL Y
 |
 TAY
 STAIY GENPTR ;[GENPTR] := 0
 PLA
 TAY
 ]
 PLA ;PULL A
 RTS


TSTMRK JSR DECGEN ;TEST DIRTY MARKER - NOTE THIS RTN DESTROYS A & Y
 [ $CMOS
 LDAI GENPTR ;A:=[GENPTR]
 |
 LDYIM 0
 LDAIY GENPTR ;A:=[GENPTR]
 ]
 RTS


INCCNT ROUT
 LDYIM CERCNT ;INCREMENT REFERENCE COUNT
 LDAIY CRNT
 CMPIM &FF
 BNE #10
 LDAIM STERRK ;REFERENCE COUNT = $FF
 JSR INTERR
10
 [ $CMOS
 INCA
 |
 CLC
 ADCIM 1
 ]
 STAIY CRNT
 RTS


DECCNT ROUT
 LDYIM CERCNT ;DECREMENT REFERENCE COUNT
 LDAIY CRNT
 BNE #10
 LDAIM STERRD ;REFERENCE COUNT = 0
 JSR INTERR
10
 [ $CMOS
 DECA
 |
 SEC
 SBCIM 1
 ]
 STAIY CRNT
 RTS

TSTCNT LDYIM CERCNT ;TEST VALUE OF REFERNENCE COUNT
 LDAIY CRNT
 RTS


;FREEST: GET AMTNED WORTH OF FREE STORE.
;EXIT : A = RC
;CRNT POINTS TO DESCRIPTOR WITH STORE ADDRESS SET

;FUNCTION:-
;1) AGE ALL THE ENTRIES IN THE CACHE
;2)FIND OUT THE MOST COST EFFECTIVE AREA
;OF MEMORY TO USE.

;WHILE crnt <> 0 AND min cost <> 0
;DO IF amount needed<=(storeaddrOFcrnt-storeaddrOFprev
;- lengthOFprev-2)
;THEN IF cost<min cost
;THEN min cost := cost;
;best start := prev;
;best end := crnt
;FI;
;prev:=nextOFprev;
;cost:=cost-costOFprev
;ELSE IF ref count OF crnt <> 0
;THEN prev := crnt;
;cost := 0
;ELSE cost +:= cost OF crnt
;FI;
;crnt := next OF crnt
;FI
;OD;

;WHILE crnt <> best end
;DO ensure(crnt); #ENSURE WINDOW UPTO DATE ON DISC#
;remove(crnt) #REMOVE CRNT FROM IN USE CHAIN#
;OD;

;crnt := get free descriptor;
;straddrOFcrnt:=straddrOFprev+lengthOFprev+1

FREEST ROUT
 LDA AMTNED
 ORA AMTNED+1
 BNE #05
 LDAIM STERRE
 RTS

;FIRST,AGE EACH OBJECT IN THE CACHE

05 JSR STCRNT ;PREV:=CACHTB;CRNT:=NEXT OF PREV

10 LDYIM CEAGE
 LDAIY CRNT
 CMPIM LRU
 BEQ #15
 [ $CMOS
 DECA
 |
 SEC
 SBCIM 1
 ] 
 STAIY CRNT ;AGE OF CRNT -:= 1
15 JSR NXTCRN
 BNE #10

;NOW SEE WHICH IS THE BEST AREA OF MEMORY TO USE

 JSR STCRNT
 [ $CMOS
 STZ BSTSTA
 STZ BSTSTA+1 ;BSTSTA : = 0
 STZ BSTEND
 STZ BSTEND+1 ;BSTEND := 0
 STZ COST
 STZ COST+1 ;COST := 0
 |
 LDAIM 0
 STA BSTSTA
 STA BSTSTA+1 ;BSTSTA : = 0
 STA BSTEND
 STA BSTEND+1 ;BSTEND := 0
 STA COST
 STA COST+1 ;COST := 0
 ]
 LDAIM &FF
 STA MINCST
 LDAIM &7F
 STA MINCST+1 ;MINCST := $7FFF

20 JSR TSTGAP
 BEQ #22
 JMP #45

;SEE IF COST < MIN COST

22 LDXIM &FF ;X<>0 here
 LDA COST
 PHA
 LDA COST+1
 PHA ;save cost for new algorithm

 LDYIM CENEXT
 LDAIY PREV
 STA GP1
 INY
 LDAIY PREV
 STA GP1+1 ;intermediate pointer

 LDAIY GP1
 CMP CRNT+1
 BNE #30
 DEY
 LDAIY GP1
 CMP CRNT
 BNE #30 ;skip if not single slot

 LDYIM CEAGE
 LDAIY GP1 ;get the age
 TAX
 STA COST ;make new account
 [ $CMOS
 STZ COST+1
 |
 LDAIM 0
 STA COST+1
 ]

 LDY AMTNED+1
 LDA AMTNED
 BEQ #25
 INY

25 DEY
 BEQ #30
 CLC
 TXA
 ADC COST
 STA COST
 BCC #25
 INC COST+1
 BNE #25

30 LDA COST
 CMP MINCST
 LDA COST+1
 SBC MINCST+1
 BCS #35

 LDA PREV
 STA BSTSTA
 LDA PREV+1
 STA BSTSTA+1 ;BSTSTA := PREV
 LDA CRNT
 STA BSTEND
 LDA CRNT+1
 STA BSTEND+1 ;BSTEND := CRNT
 LDA COST
 STA MINCST
 LDA COST+1
 STA MINCST+1 ;MINCST := COST
 ORA MINCST
 TAX

35 PLA
 STA COST+1
 PLA
 STA COST ;restore old value of COST
 TXA
 BEQ #65 ;I.E. FOUND A GAP
 LDYIM CENEXT
 LDAIY PREV
 TAX
 INY
 LDAIY PREV
 STA PREV+1
 TXA
 STA PREV ;PREV := NEXT OF PREV

 LDYIM CEBLKS
 LDAIY PREV ;get length
 TAX ;count around the loop

40 SEC
 LDA COST
 LDYIM CEAGE
 SBCIY PREV
 STA COST
 BCS #43
 DEC COST+1 ;cost -:= cost OF prev*length OF prev
43 DEX
 BNE #40 ;count for length of blocks
 JMP #20

45 JSR TSTCNT
 BEQ #50

;COST := 0; PREV := CRNT

 [ $CMOS
 STZ COST
 STZ COST+1
 |
 LDAIM 0
 STA COST
 STA COST+1
 ]
 LDA CRNT
 STA PREV
 LDA CRNT+1
 STA PREV+1
 [ $CMOS
 BRA #55
 |
 JMP #55
 ]

50 LDYIM CEBLKS
 LDAIY CRNT ; grab length (one byte only)
 TAX
52 CLC  ;cost +:=(cost OF crnt)*(length OF crnt)
 LDA COST
 LDYIM CEAGE
 ADCIY CRNT
 STA COST
 BCC #54
 INC COST+1
54 DEX
 BNE #52

55 JSR NXTCRN ;CRNT := NEXT OF CRNT
 BEQ #60
 JMP #20

;FIRST SEE IF WE FOUND AN AREA OF MEMORY TO USE

60 LDA BSTSTA
 ORA BSTSTA+1
 BNE #65
 LDAIM STERRL ;STORE DEADLOCK !!!!
 RTS ;**15/6/87** return to client (was JSR INTERR)

;NOW REMOVE ALL THE OBJECTS IN THE GAP

65 LDA BSTSTA
 STA PREV
 LDA BSTSTA+1
 STA PREV+1 ;PREV := BSTSTA
 LDYIM CENEXT
 LDAIY PREV
 STA CRNT
 INY
 LDAIY PREV
 STA CRNT+1 ;CRNT := NEXT OF PREV

;NOW CREATE THE GAP (IF NECESSARY)

 LDAIM 0
 PHA ;save RC
70 LDA BSTEND ;WE MUST DO THIS TEST FIRST
 CMP CRNT
 BNE #80
 LDA BSTEND+1
 CMP CRNT+1
 BNE #80

 JSR NEWDES ;GET FREE DESCR,CHAIN IT IN,CALC STORE ADDR
 PLA ;RC here
 RTS

80 JSR ENSURE
 BEQ #85

 CMPIM &C9 ;look for protected disc
 BEQ #90 ;skip as object is now removed anyway

 JSR INTERR
85 JSR REMVIT
 [ $CMOS
 BRA #70
 |
 JMP #70
 ]

90 TAX
 PLA ; change old RC
 BNE #95
 TXA
95 PHA ;change return code
 [ $CMOS
 BRA #85
 |
 JMP #85
 ]


NEWDES ROUT
 JSR FRDESC ;CRNT := NEW DESCRIPTOR

;storeaddrOFcrnt:=storeaddrOFprev+lengthOFprev+1

 JSR LNTPRE
 SEC ;BECAUSE WE WANT TO ADD 1
 LDYIM CESTA
 LDAIY PREV
 ADC BREGA
 STAIY CRNT
 INY
 LDAIY PREV
 ADC BREGA+1
 STAIY CRNT

;NOW CHAIN IT IN

 LDYIM CENEXT
 LDAIY PREV
 STAIY CRNT
 INY
 LDAIY PREV
 STAIY CRNT ;NEXT OF CRNT := NEXT OF PREV
 DEY ;Y:=CENEXT
 LDA CRNT
 STAIY PREV
 INY
 LDA CRNT+1
 STAIY PREV ;NEXT OF PREV := CRNT
 RTS


LNTPRE LDYIM CEBLKS ;BREGA := LENGTH OF PREV (IN BYTES)
 LDAIY PREV
 STA BREGA
 INY
 LDAIY PREV
 STA BREGA+1
 JMP MULTBS


;TSTGAP: A:= IF amount needed <= storeaddrOFcrnt-
;storeaddrOFprev-lengthOFprev-2
;THEN 0
;ELSE FF
;FI

TSTGAP ROUT
 JSR LNTPRE ;BREGA := LENGTH OF PREV(IN BYTES)
 CLC
 LDYIM CESTA
 LDAIY CRNT
 SBCIY PREV
 STA STRTMP
 INY
 LDAIY CRNT
 SBCIY PREV
 STA STRTMP+1 ;STRTMP:=straddrOFcrnt-straddrOFprev-1
 SEC
 LDA BREGA
 ADC AMTNED
 STA BREGA
 LDA BREGA+1
 ADC AMTNED+1
 STA BREGA+1 ;BREGA:=amountneeded+lengthOFprev+1
 BVC #10
 LDAIM STERRM ;OVERFLOW!!!
 JSR INTERR
10 SEC
 LDA STRTMP
 SBC BREGA
 LDA STRTMP+1
 SBC BREGA+1
 BMI #20
 LDAIM 0 ;I.E. GAP BIG ENOUGH
 RTS

20 LDAIM &FF ;I.E GAP TOO SMALL
 RTS


NXTCRN LDYIM CENEXT ;CRNT := NEXT OF CRNT
 LDAIY CRNT
 TAX
 INY
 LDAIY CRNT
 STA CRNT+1
 TXA
 STA CRNT
 ORA CRNT+1 ;A:= CRNT ! CRNT +01
 RTS

 LNK Uade0C
