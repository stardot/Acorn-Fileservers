 OPT UADE12 ;> Uade12A
 TTL File server file UADE12A

; DEALLOCATE MAP BLOCK
;
;   DEALLOCATES THE SPECIFIED MAP BLOCK. OVERWRITES THE SEQUENCE NUBERS
;   SO THAT IT WILL NO LONGER APPEAR AS A MAP BLOCK
;
; ON ENTRY
;   MPTMPA HOLDS THE SIN OF THE MAP BLOCK
;   MPCYPT POINTS TO THE CYLINDER MAP
;
; USES : MPTMPA,MPTMPD,MPTMPC,MPSCPT
;
DAMPBK ROUT
 LDYIM MPSPCY
 LDAIY MAPPTR
 STA TMPSPC
 INY
 LDAIY MAPPTR
 STA TMPSPC+1
 LDA MPTMPA ;DEALLOCATE MAP BLOCK
 STA CBSIN
 LDA MPTMPA+1
 STA CBSIN+1
 LDA MPTMPA+2
 STA CBSIN+2
 JSR FNDMB ; GNCBPT POINTS TO CURRENT ENTRY
 LDYIM CBSA
 LDAIY GNCBPT
 STA MPSCPT ;SAVE POINTER TO MAP BLOCK
 STA CBSTA
 INY
 LDAIY GNCBPT
 STA MPSCPT+1
 STA CBSTA+1
 LDYIM MBSQNO
 LDAIM &FF
 STAIY MPSCPT ;SAVE INVALID SQ.NO.
 CLC
 LDA MPSCPT
 ADCIM :LSB:LSTSQ
 STA MPSCPT
 LDA MPSCPT+1
 ADCIM :MSB:LSTSQ
 STA MPSCPT+1
 LDAIM 0
 TAY
 STAIY MPSCPT
 JSR MMBWT
 [ $CMOS
 STZ MPTMPC ; ZERO VARIABLES
 STZ MPTMPC+1
 |
 LDAIM 0
 STA MPTMPC ; ZERO VARIABLES
 STA MPTMPC+1
 ] 
10 SEC
 LDA MPTMPA
 SBC TMPSPC ; FIND CYLINDER NUMBER
 STA MPTMPA
 LDA MPTMPA+1
 SBC TMPSPC+1
 STA MPTMPA+1
 LDA MPTMPA+2
 SBCIM 0
 STA MPTMPA+2
 BCC #20 ; CYLINDER FOUND
 INC MPTMPC ;INCREMENT CYLINDER COUNT
 BNE #10
 INC MPTMPC+1
 [ $CMOS
 BRA #10
 |
 JMP #10
 ]
 
20 JSR RDBTMP ; GET THE RELEVANT BIT MAP TO STORE
 CLC
 LDA MPTMPA ; GET WHICH BLOCK OF THIS CYLINDER
 ADC TMPSPC
 STA MPTMPA
 LDA MPTMPA+1
 ADC TMPSPC+1
 STA MPTMPA+1
 BCC #25
 INC MPTMPA+2
25 LDYIM 0
30 SEC ;GET POSITION IN BIT MAP
 LDA MPTMPA
 SBCIM 8
 STA MPTMPA
 LDA MPTMPA+1
 SBCIM 0
 STA MPTMPA+1
 BCC #40 ; POSITION FOUND IF BRANCH
 INY
 [ $CMOS
 BRA #30
 |
 JMP #30
 ]
 
40 CLC
 LDA MPTMPA ; GET OLD POSITION BACK
 ADCIM 8
 STA MPTMPA
 BCC #45
 INC MPTMPA+1
45 LDX MPTMPA
 INX
 LDAIY MPSCPT ; X HOLDS POSITION IN BYTE A HOLDS THE BYTE
50 RORA ;MOVE TO CORRECT POSITION
 DEX
 BNE #50
 SEC
 LDX MPTMPA ;BLOCK IS FLAGGED FREE AND X HOLDS NUMBER OF SHIFTS
 INX
60 ROLA ; UNTIL BACK TO CORRECT POSITION
 DEX
 BNE #60
 STAIY MPSCPT ; SAVE FLAGS
 CLC
 LDA MPCYPT ;NOW MAKE COUNTS CORRECT
 ADCIM 3
 STA MAPGEN
 LDA MPCYPT+1
 ADCIM 0
 STA MAPGEN+1
 LDA MPTMPC
 STA MPTMPE
 LDA MPTMPC+1
 STA MPTMPE+1
70 LDA MPTMPE
 ORA MPTMPE+1
 BEQ #80
 CLC
 LDA MAPGEN
 ADCIM 2
 STA MAPGEN
 BCC #75
 INC MAPGEN+1
75 LDA MPTMPE
 BNE #77
 DEC MPTMPE+1
77 DEC MPTMPE
 [ $CMOS
 BRA #70
 |
 JMP #70
 ]
 
80 LDYIM 0
 CLC
 LDAIY MAPGEN ;INCREMENT FREE BLOCK COUNT
 ADCIM 1
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADCIM 0
 STAIY MAPGEN
 LDYIM 0
 CLC
 LDAIY MPCYPT
 ADCIM 1
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 ADCIM 0
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 ADCIM 0
 STAIY MPCYPT
 LDA MPscor ;**23/1/87**
 STA CBSTA
 LDA MPscor+1
 STA CBSTA+1
 JMP MBMWT ; NOW FINISHED
;
; DALLOCATE A GROUP OF BLOCKS
; MARKS THE ENTRIES IN THE SPECIFIED BIT MAP FREE AND INCREASES THE FREE BLOCK COUNT
;
; ON ENTRY
;     MPSCPT POINTS TO RELEVANT ENTRY IN MAP BLOCK
;     MPCYPT POINTS TO CYLINDER MAP
;     MAPTMP POINTS TO MAP BLOCK
;
; USES MPTMPC,MAPGEN,MPTMPD,MAPTMP
;
DAGRP ROUT
 LDA MAPTMP
 PHA
 LDA MAPTMP+1
 PHA
 [ $CMOS
 STZ MPTMPC ; ZERO VALUES
 STZ MPTMPC+1
 |
 LDAIM 0
 STA MPTMPC ; ZERO VALUES
 STA MPTMPC+1
 ]
 LDYIM 0
 LDAIY MPSCPT ; GET SIN
 STA MPTMPD
 INY
 LDAIY MPSCPT
 STA MPTMPD+1
 INY
 LDAIY MPSCPT
 STA MPTMPD+2
 LDA MPSCPT ; SAVE MAP BLOCK POINTER
 STA MAPGEN
 LDA MPSCPT+1
 STA MAPGEN+1

05 LDYIM MPSPCY
 SEC ; NOW FIND CYLINDER
 LDA MPTMPD
 SBCIY MAPPTR
 STA MPTMPD
 INY
 LDA MPTMPD+1
 SBCIY MAPPTR
 STA MPTMPD+1
 LDA MPTMPD+2
 SBCIM 0
 STA MPTMPD+2
 BCC #10 ; END FOUND
 INC MPTMPC ; COUNT TO NEXT CYLINDER
 BNE #05
 INC MPTMPC+1
 [ $CMOS
 BRA #05
 |
 JMP #05
 ]
 
10 LDYIM MPSPCY
 CLC
 LDA MPTMPD ; RESTORE BLOCK COUNT
 ADCIY MAPPTR
 STA MPTMPD
 INY
 LDA MPTMPD+1
 ADCIY MAPPTR
 STA MPTMPD+1
 BCC #12
 INC MPTMPD+2
12 LDA MPTMPC ; SAVE CYLINDER NUMBER
 STA MAPTMP
 LDA MPTMPC+1
 STA MAPTMP+1
 JSR RDBTMP
 LDYIM 0
15 SEC ; GET POSITION IN BIT MAP
 LDA MPTMPD
 SBCIM 8
 STA MPTMPD
 LDA MPTMPD+1
 SBCIM 0
 STA MPTMPD+1
 LDA MPTMPD+2
 SBCIM 0
 STA MPTMPD+2
 BCC #20 ; WHEN POSITION FOUND
 INY
 [ $CMOS
 BRA #15
 |
 JMP #15
 ]
 
20 CLC ; GET BIT POSITION BACK
 LDA MPTMPD
 ADCIM 8
 STA MPTMPD
 BCC #22
 INC MPTMPD+1
 BNE #22
 INC MPTMPD+2
22 LDA MPTMPD
 [ $Level3
 STA MPTMPC ; SAVE BIT COUNT
 INC MPTMPC  
 |
 INCA
 STA MPTMPC ; SAVE BIT COUNT
 ]
 LDAIY MPSCPT ; GET CORRECT BYTE
 LDXIM 9
25 RORA ; ROTATE TO GET CORRECT POSITION
 DEX
 DEC MPTMPC
 BNE #25
 PHA ;SAVE VALUE
 [ $CMOS
 PHY ;SAVE POSITION
 |
 TYA
 PHA ;SAVE POSITION
 ] 
 LDYIM 3
 LDAIY MAPGEN ; GET NUMBER OF BLOCKS TO BE DEALLOCATED
 STA MPTMPC
 INY
 LDAIY MAPGEN
 STA MPTMPC+1
 [ $CMOS
 PLY ; GET POSITION BACK
 |
 PLA ; GET POSITION BACK
 TAY
 ]  
 PLA
30 SEC ;MARK BLOCK FREE
 RORA
 DEX
 BEQ #40
 PHP
 PHA ; SAVE VALUE
35 LDA MPTMPC ; DECREMENT COUNT
 BNE #37
 DEC MPTMPC+1
37 DEC MPTMPC
 LDA MPTMPC+1
 ORA MPTMPC ; CHECK FOR END
 BEQ #45
 PLA ; GET VALUE BACK
 PLP
 [ $CMOS
 BRA #30 ; DEALLOCATE NEXT BLOCK
 |
 JMP #30 ; DEALLOCATE NEXT BLOCK
 ]
 
40 STAIY MPSCPT ; SAVE NEW VALUE
 INY
 LDAIY MPSCPT ; GET NEXT VALUE
 RORA ; POSITION CORRECTLY
 PHP
 PHA
 LDXIM 8 ;GIVE X CORRECT VALUE
 [ $CMOS
 BRA #35
 |
 BNE #35
 ]
 
45 CPXIM 0
 BEQ #55 ; BRANCH IF POSITION CORRECT
 PLA ;BLOCKS HAVE BEEN DEALLOCATED SO CORRECT POSITION
 PLP
50 RORA
 DEX
 BNE #50 ; KEEP GOING UNTIL BACK RIGHT
 [ $CMOS
 BRA #60
 |
 BEQ #60
 ]
 
55 PLA
 PLP
60 STAIY MPSCPT ;SAVE VALUE
 LDA MPscor ;**23/1/87**
 STA CBSTA
 LDA MPscor+1
 STA CBSTA+1
 JSR MBMWT
 LDYIM 3 ; NOW CORRECT FREE BLOCK COUNT
 LDAIY MAPGEN
 STA MPTMPC
 INY
 LDAIY MAPGEN
 STA MPTMPC+1
 LDYIM 0
 CLC ; NOW ADD TO FREE BLOCK COUNT
 LDA MPTMPC
 ADCIY MPCYPT
 STAIY MPCYPT
 INY
 LDA MPTMPC+1
 ADCIY MPCYPT
 STAIY MPCYPT
 INY
 LDAIM 0
 ADCIY MPCYPT
 STAIY MPCYPT
 CLC ;NOW GET POSITION IN CYLINDER MAP
 LDAIM 3
 ADC MPCYPT
 STA MPSCPT
 LDAIM 0
 ADC MPCYPT+1
 STA MPSCPT+1
65 LDA MAPTMP
 ORA MAPTMP+1 ; HAVE WE GOT THERE ?
 BEQ #70
 CLC ; MOVE TO NEXT ENTRY
 LDA MPSCPT
 ADCIM 2
 STA MPSCPT
 BCC #67
 INC MPSCPT+1
67 LDA MAPTMP ; DECREMENT CYLINDER COUNT
 BNE #68
 DEC MAPTMP+1
68 DEC MAPTMP
  [ $CMOS
 BRA #65
  |
 JMP #65
 ]
 
70 CLC ; NOW DO THE ADD
 LDYIM 0
 LDAIY MPSCPT
 ADC MPTMPC
 STAIY MPSCPT
 INY
 LDAIY MPSCPT
 ADC MPTMPC+1
 STAIY MPSCPT
 LDA MAPGEN ; RESTORE SOME VALUES
 STA MPSCPT
 LDA MAPGEN+1
 STA MPSCPT+1
 LDYIM 0
 TYA
 LDXIM 5
75 STAIY MPSCPT
 INY
 DEX
 BNE #75
 PLA
 STA MAPTMP+1
 STA CBSTA+1
 PLA
 STA MAPTMP
 STA CBSTA
 JMP MMBWT

;CLRBLK
;   DEALLOCATES ALL BLOCKS FROM A GIVEN ENTRY.
;   THE ORIGINAL MAP BLOCK WILL BE DELETED IF A FLAG IS SET.
;
; ON ENTRY
;   MPTMPA HOLDS THE SIN OF THE MAP BLOCK
;   MPSCPT HOLDS THE OFFSET IN THE MAP BLOCK
;   MPTMPE IF NON-ZERO IMPLIES MAP BLOCK TO BE DELETED
;

CLRBLK ROUT
 LDYIM MPCYMP
 LDAIY MAPPTR
 STA MPCYPT
 INY
 LDAIY MAPPTR
 STA MPCYPT+1
 CLC
 JSR RDMPBK ; MAKE SURE MAP BLOCK IS IN STORE
 BNE #20
 CLC
 LDA MAPTMP ; GET POINTER TO MAP BLOCK
 STA MPMBPT
 ADC MPSCPT ; GET CURRENT POSITION
 STA MPSCPT
 LDA MAPTMP+1
 STA MPMBPT+1
 ADC MPSCPT+1
 STA MPSCPT+1
10 LDYIM 0 ; CHECK IF END OF BLOCK
 LDAIY MPSCPT
 INY
 ORAIY MPSCPT
 INY
 ORAIY MPSCPT
 BNE #30 ; END OF MAP BLOCK REACHED
15 LDA MPTMPE
 BEQ #20
 LDA DNDLTE
 BNE #20
 JSR DAMPBK
20 RTS

30 CLC
 LDA MPMBPT
 ADCIM :LSB:LSTENT
 TAX
 LDA MPMBPT+1
 ADCIM :MSB:LSTENT
 CPX MPSCPT ; CHECK FOR LAST ENTRY
 BNE #60
 CMP MPSCPT+1
 BNE #60
 LDYIM 0 ; GET NEW SIN
 LDAIY MPSCPT
 STA MPTMPB
 INY
 LDAIY MPSCPT
 STA MPTMPB+1
 INY
 LDAIY MPSCPT
 STA MPTMPB+2

 LDYIM 4
 LDAIM 0
40 STAIY MPSCPT ;clear out this pointer
 DEY
 BPL #40 ;**14/9/84**
 JSR MMBWT ;**8/5/87** mark block written to

 JSR #15 ; CHECK IF THIS BLOCK TO BE DELETED
 [ $CMOS
 STZ DNDLTE
 |
 LDAIM 0
 STA DNDLTE
 ]
 LDAIM 1
 STA MPTMPE
 LDA MPTMPB
 STA MPTMPA
 LDA MPTMPB+1
 STA MPTMPA+1
 LDA MPTMPB+2
 STA MPTMPA+2
 CLC
 JSR RDMPBK ; READ IN NEW MAP BLOCK
 CLC
 LDA MAPTMP ;TRANSFER POINTER
 STA MPMBPT
 ADCIM :LSB:MBENTS ; GET TO POINT TO START OF ENTRIES
 STA MPSCPT
 LDA MAPTMP+1
 STA MPMBPT+1
 ADCIM :MSB:MBENTS
 STA MPSCPT+1
60 JSR DAGRP
 LDA SAVSC
 BNE #70
 INC SAVSC
 JSR ENSMB
 JSR ULBM
70 CLC ; MOVE TO NEXT ENTRY
 LDA MPSCPT
 ADCIM :LSB:ENSZ
 STA MPSCPT
 LDA MPSCPT+1
 ADCIM :MSB:ENSZ
 STA MPSCPT+1
 JMP #10

 LNK UADE13
