 OPT UADE11 ;> Uade11A
 TTL File server file UADE11A

;GETPOS
;   FINDS NEXT FREE POSITION IN MAP BLOCK
; SETS CARRY FLAG IF MAP BLOCK FULL
;
; ON ENTRY
;      MAPGEN POINTS TO START OF MAP BLOCK
;
; ON EXIT
;      MAPGEN POINTS TO NEXT FREE POSITION
;
; USES
;      MPTMPE
;
GETPOS ROUT
 CLC
 LDA MAPGEN
 ADCIM :LSB:MBENTS ;GET MAPGEN TO START OF ENTRIES
 STA MAPGEN
 LDA MAPGEN+1
 ADCIM :MSB:MBENTS
 STA MAPGEN+1
 STZ MPTMPE
 STZ MPTMPE+1 ;CLEAR VARIABLES
10 LDA MPTMPE
 CMPIM :LSB:(MXENTS-1) ;CHECK FOR END OF LIST
 LDA MPTMPE+1
 SBCIM :MSB:(MXENTS-1)
 BCS #50 ;RETURNS WITH CARRY SET IF END OF LIST
 LDYIM 0 ;Y POINTS AT SIN
 LDAIY MAPGEN
 BNE #30 ;ZERO IS END OF LIST
 INY
 LDAIY MAPGEN
 BNE #30
 INY
 LDAIY MAPGEN 
 BEQ #40
30 CLC ;LOOK AT NEXT ENTRY
 LDA MAPGEN
 ADCIM ENSZ
 STA MAPGEN
 BCC #35
 INC MAPGEN+1
35 INC MPTMPE ;MPTMPE HOLDS NUMBER OF ENTRIES WE'VE LOOKED AT
 BNE #10
 INC MPTMPE+1
 BRA #10

40 CLC
50 RTS ;RETURNS HERE WITH CARRY CLEAR, ALL OK, SET IF NOT.

; GET CYLINDER MAP POSITION
;
; STARTS A SEARCH FROM MPTMPC FOR THE NEXT
; CYLINDER WITH A FREE SECTOR
;
; ON ENTRY
;     MPTMPC HOLDS THE CURRENT CYLINDER
;     MAPGEN POINTS TO START OF CYLINDER MAP
;     MAPPTR POINTS TO MABTB ENTRY
;
; ON EXIT
;     MAPGEN POINTS TO CYLINDER WITH FREE ENTRY
;
; USES  MPTMPE

GTCYPS ROUT
 LDA MPTMPC
 ASLA
 STA MPTMPE ;**1/7/88** current position*2
 LDA MPTMPC+1
 ROLA
 STA MPTMPE+1
 CLC
 LDA MAPGEN ;POINT TO START OF MAP
 ADCIM 3
 STA MAPGEN
 BCC #10
 INC MAPGEN+1
10 CLC
 LDA MAPGEN ;**1/7/88** add offset to cylinder
 ADC MPTMPE
 STA MAPGEN
 LDA MAPGEN+1
 ADC MPTMPE+1
 STA MAPGEN+1
 LSR MPTMPE+1
 ROR MPTMPE

30 LDYIM 0 ;NOW LOOK FOR POSITION WITH FREE BLOCK
 LDAIY MAPGEN
 INY
 ORAIY MAPGEN
 BNE #50 ;FOUND IF NON ZERO
 INC MPTMPE
 BNE #32
 INC MPTMPE+1
32 LDA MPTMPE
 LDYIM MPNOCY ;CHECK FOR END OF CYCLINDER MAP
 CMPIY MAPPTR
 INY
 LDA MPTMPE+1
 SBCIY MAPPTR
 BCS #40
 LDAIM 2 ;NOT END SO LOOK AT NEXT ENTRY
35 CLC
 ADC MAPGEN
 STA MAPGEN
 BCC #30
 INC MAPGEN+1
 BRA #30

40 STZ MPTMPE ;END SO BACK TO BEGINNING
 STZ MPTMPE+1
 LDYIM MPCYMP
 LDAIY MAPPTR ;GET START OF CYLINDER MAP
 STA MAPGEN
 INY
 LDAIY MAPPTR
 STA MAPGEN+1
 LDAIM 3 ;GET POINTER TO START OF ENTRIES
 BRA #35

50 RTS

; FIND CYLINDER
;
; FINDS THE CYCLINDER WITH THE LARGEST AMOUNT
; OF FREE SPACE
;
; ON ENTRY
;     MPCYPT POINTS TO START OF CYLINDER MAP
;
; ON EXIT
;     MPCYPT POINTS TO CYLINDER FOUND
;
; USES  MAPTMP MPTMPA MPTMPB

FNDCY ROUT
 STZ MAPTMP ;ZERO VALUES
 STZ MAPTMP+1
 STZ MPTMPA
 STZ MPTMPA+1
 STZ MPTMPC
 STZ MPTMPC+1
 CLC
 LDA MPCYPT ;GET TO START OF ENTRIES
 ADCIM 3
 STA MPCYPT
 STA MPTMPB
 LDA MPCYPT+1
 ADCIM 0
 STA MPCYPT+1
 STA MPTMPB+1
10 LDYIM 0 ;NOW SCAN ENTRIES FOR LARGEST
 LDA MAPTMP
 CMPIY MPCYPT
 INY
 LDA MAPTMP+1
 SBCIY MPCYPT ; MAPTMP HOLDS LARGEST SO FAR
 BCS #20 ;BRANCH IF NOT LARGER
 LDAIY MPCYPT
 STA MAPTMP+1
 DEY
 LDAIY MPCYPT
 STA MAPTMP
 LDA MPCYPT ;SAVE POSITION
 STA MPTMPB
 LDA MPCYPT+1
 STA MPTMPB+1
 LDA MPTMPA
 STA MPTMPC ;SAVE CYLINDER NUMBER
 LDA MPTMPA+1
 STA MPTMPC+1
20 CLC
 LDA MPCYPT ;MOVE TO NEXT ENTRY
 ADCIM 2
 STA MPCYPT
 BCC #25
 INC MPCYPT+1
25 INC MPTMPA
 BNE #30
 INC MPTMPA+1
30 LDYIM MPNOCY ;CHECK FOR END OF MAP
 LDAIY MAPPTR
 CMP MPTMPA
 BNE #10
 INY
 LDAIY MAPPTR
 CMP MPTMPA+1
 BNE #10
 LDA MPTMPB ;END SO RETURN POINTER
 STA MPCYPT
 LDA MPTMPB+1
 STA MPCYPT+1
 RTS

; RETURNS THE SIZE OF A BLOCK OF STORE
;
; ON ENTRY
;    MPSCPT POINTS TO BIT MAP
;
; ON EXIT
;    MPTMPD HOLDS THE SIZE
;
; USES MPTMPE
;
SIZE ROUT
 LDYIM MPSPCY
 LDAIY MAPPTR
 STA TMPSPC
 INY
 LDAIY MAPPTR
 STA TMPSPC+1
 STZ MPTMPD ;CLEAR VARIABLES
 STZ MPTMPD+1
 STZ MPTMPE
 STZ MPTMPE+1
 LDYIM 0
10 LDAIY MPSCPT
 BEQ #80 ;NO FREE BITS IN THIS PART
 LDXIM 8 ;LOOK AT ALL EIGHT BITS
20 RORA ;GET BIT INTO CARRY
 PHA
 BCC #70 ;CLEAR SO CHECK FOR END
 INC MPTMPD
 BNE #30 ;KEEP A COUNT OF SECTORS
 INC MPTMPD+1
30 INC MPTMPE
 BNE #40
 INC MPTMPE+1 ;AND CHECK HOW MANY BITS WE'VE LOOKED AT
40 JSR TESTME ;**23/1/87** check for end of map
 BCC #60
 LDA MPTMPD
 ORA MPTMPD+1
 BNE #50
48 LDAIM &F6
 JSR INTERR
50 PLA ;GET BIT MAP VALUE BACK
55 RTS

60 PLA
 DEX
 BNE #20
65 INY
 BRA #10

70 LDA MPTMPD
 ORA MPTMPD+1
 BNE #50 ;END IF ALREADY SOME COUNT
 BRA #30

80 LDA MPTMPD
 ORA MPTMPD+1
 BNE #55
 CLC
 LDA MPTMPE
 ADCIM 8 ;LOOK AT NEXT BYTE OF MAP
 STA MPTMPE
 BCC #85
 INC MPTMPE+1
85 JSR TESTME ;**23/1/87** test for end of map
 BCC #65
 BRA #48

; FILL BLOCKS
;    ALLOCATES REST OF BLOCKS THAT ARE REQUIRED
;
; ON ENTRY
;      DIVTMP HOLDS SIZE
;      MPSCPT POINTS TO CURRENT BIT MAP
;      MPTMPC HOLDS CYLINDER NUMBER
;      MAPTMP POINTS TO MAP BLOCK
;      MAPPTR POINTS TO MAP TABLE
;      MPCYPT POINTS TO POSITION IN CYLINDER MAP
;
; ON EXIT
;      C SET IF FAILED
;

FLBLKS ROUT
 LDA DIVTMP ;CHECK IF ALL BLOCKS ALLOCATED
 ORA DIVTMP+1
 ORA DIVTMP+2
 BEQ #40
 JSR GETBIT ;FIND FIRST FREE BLOCK
 BCS #10 ;NONE LEFT SO GET NEXT TRACK
 JSR ABLKS ;ALLOCATE THESE BLOCKS
 BCC FLBLKS ;KEEP ALLOCATING BLOCKS UNTIL NONE LEFT
 LDA ERRTYP
 BEQ #10
00 SEC
 RTS

10 INC MPTMPC
 BNE #20
 INC MPTMPC+1
20 LDA MPTMPC ;GET NEXT BIT MAP
 LDYIM MPNOCY ; CHECK FOR END
 CMPIY MAPPTR
 INY
 LDA MPTMPC+1
 SBCIY MAPPTR
 BCS #30
 CLC
 LDA MPCYPT ;KEEP CYLINDER MAP POINTER UP TO DATE
 ADCIM 2
 STA MPCYPT
 BCC #25
 INC MPCYPT+1
25 LDYIM 0
 LDAIY MPCYPT
 INY
 ORAIY MPCYPT
 BEQ #10
 JSR RDBTMP ; GET THE BIT MAP
 BNE #00 ;**23/2/87** Failed
 BRA FLBLKS ; KEEP TRYING TO ALLOCATE

30 STZ MPTMPC ;GO BACK TO THE BEGINNING
 STZ MPTMPC+1
 LDYIM MPCYMP ;RETURN CYLINDER MAP TO BEGINNING
 CLC
 LDAIY MAPPTR
 ADCIM 1
 STA MPCYPT
 INY
 LDAIY MAPPTR
 ADCIM 0
 STA MPCYPT+1
 BRA #20

40 CLC ;INDICATE OK
 RTS

;
; GET BIT
;   FINDS THE FIRST FREE BIT IN THE BIT MAP
;
; ON ENTRY
;     MPSCPT POINTS TO BIT MAP
;
; ON EXIT
;     MPTMPE HOLDS BIT NUMBER
;     C SET IF NOT BITS FOUND
;
GETBIT ROUT
 LDYIM MPSPCY
 LDAIY MAPPTR
 STA TMPSPC
 INY
 LDAIY MAPPTR
 STA TMPSPC+1
 LDYIM 0
 STY MPTMPE
 STY MPTMPE+1
10 LDAIY MPSCPT ; GET BYTE OF BIT MAP
 BEQ #40 ; IF NONE FREE GET NEXT BYTE
20 RORA ; ROTATE UNTIL BIT FOUND
 BCS #50 ; BRANCH WHEN FOUND
 INC MPTMPE ;KEEP TRACK OF WHERE WE ARE
 BNE #30
 INC MPTMPE+1
30 PHA
 JSR TESTME ;CHECK FOR END OF ENTRY
 PLA
 BCC #20
40 CLC
 LDA MPTMPE ;ADD 8 FOR THIS BYTE
 ADCIM 8
 STA MPTMPE
 BCC #45
 INC MPTMPE+1
45 INY
 JSR TESTME ; CHECK FOR END OF BIT MAP
 BCC #10
 SEC ;WHEN NONE FOUND
 RTS

50 CLC
 RTS

;
; CHECK FOR END OF BIT MAP
;
TESTME LDA MPTMPE
 CMP TMPSPC
 LDA MPTMPE+1
 SBC TMPSPC+1
 RTS
;
; CORRECT THE CURRENT FREE BLOCK COUNT
;
; ON ENTRY
;     MPTMPB HOLDS NUMBER OF BLOCKS
;     MPTMPC HOLDS CYLINDER NUMBER
;     MAPPTR POINTS TO MAP TABLE ENTRY
;
; USES MAPGEN
;
ADDFR ROUT
 LDYIM MPCYMP
 LDAIY MAPPTR
 STA MAPGEN
 INY
 LDAIY MAPPTR
 STA MAPGEN+1 ;GET POINTER TO CYLINDER MAP
 LDYIM  0
 CLC
 LDAIY MAPGEN ;ADD TO FREE COUNT AT START
 ADC MPTMPB
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADC MPTMPB+1
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADC MPTMPB+2
 STAIY MAPGEN
 CLC ; NOW FOUND CYLINDER POSITION
 LDA MAPGEN
 ADCIM 3 ;START OF ENTRIES
 STA MAPGEN
 BCC #05
 INC MAPGEN+1
05 LDA MPTMPC
 ORA MPTMPC+1
 BEQ #40
 LDX MPTMPC
 LDY MPTMPC+1
 BRA #20

10 CLC
 LDA MAPGEN
 ADCIM 2
 STA MAPGEN
 BCC #20
 INC MAPGEN+1
20 CPXIM 0
 BEQ #30
 DEX
 BRA #10

30 CPYIM 0
 BEQ #40
 DEX
 DEY
 BRA #10

40 LDYIM 0
 CLC ;NOW ADD THE NEW VALUES
 LDAIY MAPGEN
 ADC MPTMPB
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADC MPTMPB+1
 STAIY MAPGEN
 RTS

MPMKFR ROUT
 LDAIY ARGPTR ;form zero page pointer from supplied info
 STA GENPTR
 INY
 LDAIY ARGPTR
 STA GENPTR+1
10 RTS

MPSETF TAX
 BNE #10 ;non-zero => dont update the free store
 JSR MPMKFR
 CLC
 TAX
 LDA GENPTR
 ADCIM UTUSID
 LDYIM ARGB
 STAIY NEWARG
 INY
 BCC #20
 INX
20 TXA
 STAIY NEWARG

 LDXIM :LSB:-4
30 INY
 LDAAX MPNWFR-:LSB:-4 ;write calculated new free space
 STAIY NEWARG
 INX
 BNE #30
 LDAIM 9
 JSR SETRTN
 JMP USRMAN

MPsetd ROUT ;**8/5/87** Copy ARGD into MPTMPA
 LDYIM ARGD
 LDAIY ARGPTR
 STA MPTMPA
 INY
 LDAIY ARGPTR
 STA MPTMPA+1
 INY
 LDAIY ARGPTR
 STA MPTMPA+2
 INY ;exit with Y=ARGG
 RTS

MPFRAD ROUT
 JSR MPMKFR ;setup pointer
 JSR RDmpbd ;**8/5/87** Read block at ARGD
 BNE #30 ;exit

 LDA MAPTMP
 STA MPMBPT
 LDA MAPTMP+1
 STA MPMBPT+1
 JSR MPGTSZ

 LDXIM :LSB:-3
 LDYIM UTFREE
 CLC

20 LDAIY GENPTR
 ADCAX MPTMPA-:LSB:-3
 STAAX MPNWFR-:LSB:-3 ;save it away
 INY
 INX
 BNE #20

;deal with extra length byte

 LDAIY GENPTR
 ADCIM 0 ;'cos size only three bytes
 STAAX MPNWFR+3

 TXA ;return ok
30 RTS

 LNK UADE12
