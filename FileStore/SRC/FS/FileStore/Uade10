 OPT UADE10 ;> Uade10
 TTL File server file UADE10


;**********************************
;*           M A P M A N          *
;**********************************

;THE MAP TABLE (MAPTB) CONTAINS :-
;0) DISC NUMBER (2 BYTES)
;1) NO. OF SECTORS/TRACKS ON DISC (2 BYTES)
;2) SIN OF ROOT DIRECTORY (3 BYTES)
;3) DATE ROOT CREATED (2 BYTES)
;DRIVE NUMBER PROVIDES THE OFFSET IN MAPTB.
;POSSIBLE STATES ARE :-

MAPMAN ROUT

 LDXIM 16 ;MAPMAN ENTRY POINTS
 LDAIM MODMAP ;A := NAME OF THIS MODULE
 JSR ENTRY
 LDAIM 20
 JSR SETFS
 JMIX MPRTNS ;JUMP TO CORRECT ROUTINE

;ADDRESSES OF ENTRY POINTS FOR EACH ROUINE
MPRTNS
 & MPCRSP ;1 => CREATE SPACE
 & MPFRSP ;2 => FREE SPACE
 & MPCHSZ ;3 => CHANGE SIZE
 & MPSNRT ;4 => SIN OF ROOT
 & MPSZIN ;5 => SIZE OF CHAIN
 & MPENSR ;6 => WRITE MAP TO DISC
 & MPREST ;7 => START
 & MPDSNB ;8 => RETURN DISC NUMBER FOR A GIVEN DRIVE
 & MPREDR ;9 => RESTART ONE DRIVE
 & MPDNNA ;10 => RETURN NUMBER FOR GIVEN DISC NAME
 & MPNADN ;11 => RETURN NAME FOR GIVEN DISC NO.
 & MPFREE ;12 => FREE AREA ON DISC
 & MPZDSK ;13 => ZERO AREA OF DISC
 & MPCHSJ ;14 => changesize without space check
 & MPDRNB ;15 => return drive number from disc number
 & MPFLSH ;16 => flush bit map and map block caches

MPENSR LDAIM 0 ;Null routine now
MPEXIT JMP PREXIT

;MPCRSP: CREATE SPACE

;ENTRY:
;ARGB-C DISC NUMBER
;ARGD-F NUMBER OF BYTES WANTED
;ARGG-H Ptr to user info

;EXIT:
;ARGA = RC
;ARGB-C DISC NUMBER
;ARGD-F SIN
;ARGG-H Ptr to user info

;FUNCTION: MAPTB IS SEARCHED TO FIND THE RELEVANT ENTRY. IF THE SECTOR MAP
;IS NOT IN STORE, IT IS READ IN. THE FREE SPACE COUNT IS CHECKED TO SEE IF
;THE SPACE IS AVAILABLE. A CHAIN IS CREATED, THE FREE COUNT IS DECREMENTED
;AND THE MAP IS MARKED DIRTY. THE SIN OF THE FIRST BLOCK OF THE CHAIN IS
;RETURNED.

MPBLTX = "paMseJ" ;Mapblocktext

MPCRSP LDYIM ARGG
 JSR MPMKFR ;make pointer
 LDAIM ARGD
 STA MAPTMP
 LDAIM UTFREE
 STA MAPTMP+1
 LDXIM :LSB:(1-UTFRLN)
 SEC

10 LDY MAPTMP+1
 LDAIY GENPTR
 LDY MAPTMP
 SBCIY ARGPTR
 STAAX MPNWFR-:LSB:(1-UTFRLN) ;save this result
 INC MAPTMP
 INC MAPTMP+1
 INX
 BNE #10

 LDY MAPTMP+1
 LDAIY GENPTR
 SBCIM 0 ;extra length byte
 STA MPNWFR+(UTFRLN-1)

 LDAIM MPERRN ;error code to return with insufficient free space
 BCC #20

 STZ ERRTYP ;NO ERRORS YET!!!
 STZ DNDLTE
 JSR FNDMAP ;GET POINTER TO MAPTB
 BEQ #25
20 JMP #90
25 LDA Mpdrve ;**24/2/88** check drive for write protect
 JSR Testdv
 BNE #20 
 LDYIM ARGD ;NUMBER OF BYTES REQUIRED
 LDAIY ARGPTR
 STA DIVPAR
 INY
 LDAIY ARGPTR
 STA DIVPAR+1
 INY
 LDAIY ARGPTR
 STA DIVPAR+2
 JSR DVDE ;TO FIND MOST LIKELY NUMBER OF BLOCKS
 BCC #30
 JMP #85
30 LDYIM MPCYMP ;READY TO CHECK IF ENOUGH ROOM
 LDAIY MAPPTR
 STA MPCYPT
 INY
 LDAIY MAPPTR
 STA MPCYPT+1
 SEC
 LDYIM 0
 LDAIY MPCYPT
 SBC DIVTMP ;FOR NUMBER OF BLOCKS
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 SBC DIVTMP+1
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 SBC DIVTMP+2
 STAIY MPCYPT
 BCC #55 ;BRANCH IF NO ROOM
 JSR FNDCY ;FIND LARGEST CYLINDER
 JSR RDBTMP ;READ IN THE BIT MAP
 BNE #55 ;**25/12/86** Disc fault - say no room
 JSR ALBLK ;ALLOCATE ONE BLOCK AS MAP BLOCK
 LDA MPTMPA
 LDYIM ARGD
 STAIY ARGPTR ; SAVE SIN OF NEW FILE
 INY
 LDA MPTMPA+1
 STAIY ARGPTR
 INY
 LDA MPTMPA+2
 STAIY ARGPTR
 LDA DIVTMP ;ONE LESS BLOCK REQUIRED
 BNE #42
 LDA DIVTMP+1
 BNE #41
 DEC DIVTMP+2
41 DEC DIVTMP+1
42 DEC DIVTMP

 SEC
 JSR RDMPBK ;ALLOCATE SPACE FOR MAP BLOCK
 LDA DIVTMP+2
 ORA DIVTMP+1
 ORA DIVTMP ;CHECK IF ONLY ONE BLOCK REQUIRED
 BEQ #60 ;BRANCH IF JUST ONE BLOCK
 LDA MAPTMP
 STA MPMBPT
 LDA MAPTMP+1
 STA MPMBPT+1
 LDA MPTMPB ;POINTS TO CYCLINDER MAP
 STA MPCYPT
 LDA MPTMPB+1
 STA MPCYPT+1
 LDYIM 0
 LDAIY MPCYPT ;CHECK FOR NO FREE SPACR
 INY
 ORAIY MPCYPT
 BEQ #45 ;BRANCH TO GET NEW CYLINDER
 JSR ABLKS ; ALLOCATE THE REST OF THE BLOCKS
45 LDA DIVTMP
 ORA DIVTMP+1
 ORA DIVTMP+2 ;CHECK IF ALL BLOCKS ALLOCATED
 BEQ #60 ;OK IF THEY HAVE
 JSR FLBLKS ;OTHERWISE CONTINUE ALLOCATING BLOCKS
 BCC #60 ;CARRY CLEAR IF OK
50 LDA ERRTYP
 STA DNDLTE
 JSR MPDLTE ;CLEAR ALL BLOCKS
 JSR ULMB
 JSR ENSMB
 JSR ENSBM
55 BRA #80 ;INDICATE NO ROOM

60 JSR RDmpbd ;**8/5/87** Read block at ARGD
 LDA MAPTMP
 STA MPSCPT
 STA CBSTA
 LDA MAPTMP+1
 STA MPSCPT+1
 STA CBSTA+1

 LDYIM BLKSN
 LDXIM 5 ;mapblock identifier text
70 LDAAX MPBLTX
 STAIY MPSCPT
 INY
 DEX
 BPL #70

 LDYIM BILB
 LDA DIVPAR ;FILL IN ODD BYTES
 STAIY MPSCPT
 INY
 LDA DIVPAR+1
 STAIY MPSCPT
 JSR MMBWT
 JSR ENSBM ;ENSURE THE BIT MAPS
 JSR ENSMB ;ENSURE THE MAP BLOCKS
 LDA ERRTYP
 BNE #50
 BRA #90 ;INDICATES ALL WAS WELL

80 CLC
 LDYIM 0
 LDAIY MPCYPT
 ADC DIVTMP
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 ADC DIVTMP+1
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 ADC DIVTMP+2
 STAIY MPCYPT
 LDA ERRTYP
 BEQ #85
 SEC
 LDYIM 0
 LDAIY MPCYPT
 SBCIM 1
 STAIY MPCYPT ;MAP BLOCK LEFT!
 INY
 LDAIY MPCYPT
 SBCIM 0
 STAIY MPCYPT
 INY
 LDAIY MPCYPT
 SBCIM 0
 STAIY MPCYPT
 LDAIM MPERRC
 BRA #90

85 LDAIM MPERRB
90 LDYIM ARGG
 JSR MPSETF ;update the user free store if operation ok
 JMP MPEXIT

;MPFLSH; Flush bit map and map block caches.  This is done when a disc is to be
;        Changed, otherwise we can get confused over who's blocks are cached.

MPFLSH ROUT ;**26/2/87**
 JSR ENSBM ;Ensure all bitmaps
 JSR ENSMB ;Ensure all map blocks
 JSR SETBM ;Scan all bit map CBs and mark idle
 JSR #50
 JSR SETMB ;Scan all map block CBs and mark idle
 JSR #50
 JMP MPEXIT

50 LDX NCBDB
60 LDYIM CAFLG
 LDAIM 0
 STAIY GNCBPT ;Zero all flags
 JSR ADGNCB
 DEX
 BNE #60
 TXA
 RTS


 LNK UADE10A
