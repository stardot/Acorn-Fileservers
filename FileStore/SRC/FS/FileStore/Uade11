 OPT UADE11 ;> Uade11
 TTL File server file UADE11

;************************
;*  Restart one drive   *
;*  Disc number -> name *
;*  Disc name -> number *
;*                      *
;*  U T I L I T I E S   *
;************************


;MPFRSP: FREE SPACE

;ENTRY:
;ARGB-C DISC NUMBER
;ARGD-F SIN
;ARGG-H Ptr to user info

;EXIT:  ARGA = RC

;FUNCTION: MAPTB IS SEARCHED TO FIND THE RELEVANT ENTRY. IF THE SECTOR
;MAP IS NOT IN STORE IT IS READ IN. THE SIN IS CHECKED TO ENSURE THAT IT
;POINTS TO THE FIRST BLOCK OF THE CHAIN. ALL THE SECTORS ON THE CHAIN ARE
;THEN ADDED TO THE FREE CHAIN. THE FREE SECTOR COUNT IS THEN ADJUSTED. THE
;DIRTY FLAG FOR THE SECTOR MAP IS SET.

MPFRSP ROUT
 JSR FNDMAP ;GET CURRENT MAP TABLE POSITION
 BNE #10

 STZ ERRTYP
 STZ DNDLTE

 LDYIM ARGG
 JSR MPFRAD
 BNE #10

 JSR MPDLTE
 BNE #10
 JSR ENSMB
 JSR ENSBM
 LDAIM 0 ; REPLY ZERO
10 LDYIM ARGG
 JSR MPSETF
 JMP MPEXIT


;MPREDR: *** RESTART ONE DRIVE **

;ENTRY: ARGB = DRIVE NO.

;EXIT:  ARGA = RC

MPREDR ROUT
 STZ ERRTYP
 LDA BBUF
 STA DSCCB+TRADD ;SET UP AREA TO READ IN SECTOR TWO
 STA MPSCPT
 LDA BBUF+1
 STA DSCCB+TRADD+1
 STA MPSCPT+1

 LDYIM ARGB
 LDAIY ARGPTR
 STA CURDRV ;SET CURRENT DRIVE
 STA MPDRVE

 JSR SMPPTR ;**6/7/88** MAPPTR to map table
 LDYIM MPNOCY ;**6/7/88** see if drive was used
 LDAIY MAPPTR
 INY
 ORAIY MAPPTR
 BEQ #20 ;**6/7/88** no, pretend mount ok now

 LDA MPDRVE
 JSR RDSTWO ;GET SECTOR ZERO TO BIG BUFFER
 BNE #30 ;**6/7/88**

 JSR CHKDSC ;CHECK DISC IS FS DISC
 BNE #30

; Store old MAPTB entry for use after new entry has been copied.

 LDYIM MPDCNO
10 LDAIY MAPPTR
 STAAY MAPTBF-MPDCNO
 INY
 CPYIM MPTBSZ
 BNE #10

 JSR SMAPEN ;Move sector zero info. from BBUF

 JSR MPRESZ ;**5/3/88** get size of disc
 JSR CHMPSZ ;CHECK MAP WILL FIT IN AVAILABLE SPACE
 BNE #30

 JSR MPSTCY ;SET CORRECT MAP (MOST RECENT)

 JSR AGENTB ;AGE NAME TABLE

 LDA BBUF
 STA MPSCPT
 LDA BBUF+1
 STA MPSCPT+1 ;CHMAPS destroys MPSCPT

 LDA MAPTBF
 STA CURDSC ;Set disc no. for FNDDNO
 LDA MAPTBF+1
 STA CURDSC+1
 JSR FNDDNO ;Find name table entry of old disc
 LDAIM UNUSED
 LDYIM NTUSED
 STAIY DNMPTR ;Mark old disc unused

 JSR CHDNAM ;CHECK DISC NAME AND PUT IN NAME TABLE
 BNE #30 ;POSSIBLY NOT UNIQUE DISC
 JSR Defdsc ;Define disc parameters to MOS
 BNE #30

 LDAIM 0 ;=> Success
20 JMP MPEXIT ;*** EXIT **

30 PHA ;Error exit !!
 LDYIM MPNOCY ;**6/7/88** mark entry unavailable
 LDAIM 0
 STAIY MAPPTR
 INY
 STAIY MAPPTR
 PLA
 BRA #20

;MPDRNB:

;ENTRY: ARGB-C DISC NUMBER

;EXIT:  ARGA = RC
;ARGB   DRIVE NUMBER

;FUNCTION: finds the relevant entry
;in MAPTB and returns the drive number currently
;containing that disc (if any)

MPDRNB ROUT
 JSR FNDMAP ;to find disc number
 PHA
 LDYIM ARGB ;save possible answer
 LDA MPDRVE
 STAIY ARGPTR
 PLA
 JMP MPEXIT

;MPDSNB:

;ENTRY: ARGB = DRIVE NUMBER

;EXIT:  ARGA = RC
;ARGB-C DISC NUMBER

;FUNCTION: FINDS THE RELEVANT ENTRY
;IN MAPTB AND RETURNS THE DISC NUMBER CURRENTLY
;ON THAT DRIVE.

MPDSNB ROUT
 LDYIM ARGB ;TO FIND DRIVE NUMBER
 LDAIY ARGPTR
 CMP DRIVES
 BCS #10 ;BRANCH IF LEG PULL
 STA CURDRV
 JSR SMPPTR
 LDYIM MPNOCY ; ** 14/06/86 ** Unless disc has cyls ...
 LDAIY MAPPTR
 INY
 ORAIY MAPPTR
 BEQ #10 ; ** 14/06/86 ** It is a gap between drives

;ENTRY FOUND SO LOOK AT IT
 LDYIM MPDCNO ;FOR DISC NUMBER
 LDAIY MAPPTR
 LDYIM ARGB ;TO SAVE IT FOR RETURN
 STAIY ARGPTR
 LDYIM MPDCNO+1
 LDAIY MAPPTR
 LDYIM ARGC
 STAIY ARGPTR
 LDAIM 0 ;RC
 BRA #20

10 LDAIM MPERRF
20 JMP MPEXIT

;MPDNNA

;ENTRY: ARGB-C PTR TO DISC NAME

;EXIT : ARGB-C DISC NO.

MPDNNA ROUT
 LDYIM ARGB
 LDAIY ARGPTR
 STA GENPTR
 INY
 LDAIY ARGPTR
 STA GENPTR+1
 LDYIM 0

 LDAIY GENPTR
 CMPIM CR
 BNE #10
 LDAIM MPERRK
 BRA #50 ;null disc name

10 LDAIY GENPTR
 CMPIM CR
 BEQ #20 ;ARG. IS TERMINATED CR, SO NEEDS PADDING
 STAAY DNMBUF
 INY
 BRA #10

20 LDAIM SPACE
30 CPYIM DNAMLN ;CONTINUE PADDING ?
 BCS #40 ;NOPE, Y>=DNAMLN
 STAAY DNMBUF ;YEP, CONTINUE
 INY
 BRA #30

40 JSR FNDNAM ;LOOK UP NAME IN NAME TABLE
 BNE #50 ;NOT FOUND ...

 LDYIM NTDNO
 LDAIY DNMPTR
 PHA
 INY
 LDAIY DNMPTR
 LDYIM ARGC

 STAIY ARGPTR
 PLA
 DEY
 STAIY ARGPTR
 LDAIM 0

50 JMP MPEXIT


;MPNADN

;**  DISC NO. -> DISC NAME **

;ENTRY: ARGB-C DISC NO.

;EXIT:  ARGB-C PTR. TO NAME

MPNADN ROUT
 LDYIM ARGB
 LDAIY ARGPTR
 STA CURDSC
 INY
 LDAIY ARGPTR
 STA CURDSC+1

 JSR FNDDNO
 BEQ #10

 LDAIM MPERRA ;DISC NO. NOT FOUND
 BRA #20

10 LDYIM ARGB
 CLC
 LDA DNMPTR
 ADCIM NTNAME
 STAIY ARGPTR
 INY
 LDA DNMPTR+1
 ADCIM 0
 STAIY ARGPTR
 LDAIM 0 ;OK EXIT ...

20 JMP MPEXIT

;MPFREE
; RETURN SIZE OF FREE CHAIN
;
; Entry:
;    ARGB-C DISC NO
;
; Exit:
;    ARGB-D SIZE
;    ARGE-G TOTAL SPACE

MPFREE ROUT
 JSR FNDMAP ;GET MAP TO STORE
 BNE #10
 LDYIM MPCYMP
 LDAIY MAPPTR
 STA MPCYPT
 INY
 LDAIY MAPPTR
 STA MPCYPT+1
 LDYIM 0
 LDAIY MPCYPT ;GET FREE SPACE
 STA MPTMPA
 INY
 LDAIY MPCYPT
 STA MPTMPA+1
 INY
 LDAIY MPCYPT
 STA MPTMPA+2
 LDYIM ARGB
 LDA MPTMPA
 STAIY ARGPTR
 INY
 LDA MPTMPA+1
 STAIY ARGPTR
 INY
 LDA MPTMPA+2
 STAIY ARGPTR
 LDYIM MPSCTT
 LDAIY MAPPTR
 STA MPTMPA
 INY
 LDAIY MAPPTR
 STA MPTMPA+1
 INY
 LDAIY MAPPTR
 LDYIM ARGG
 STAIY ARGPTR
 DEY
 LDA MPTMPA+1
 STAIY ARGPTR
 DEY
 LDA MPTMPA
 STAIY ARGPTR
 LDAIM 0
10 JMP MPEXIT

;MPZDSK: ZERO AREA OF DISC
;
;ENTRY:
;ARGB-C DISC NUMBER
;ARGD-F SIN
;ARGG-I OLD SIZE
;
;EXIT: ARGA = RC

MPZDSK ROUT
 JSR MPsetd ;**8/5/87** MPTMPA = ARGD
 LDAIY ARGPTR
 STA OLDSZE
 INY
 LDAIY ARGPTR
 STA OLDSZE+1
 INY
 LDAIY ARGPTR
 STA OLDSZE+2
 STZ OLDSZE+3
 JSR ZERDSK
 JMP MPEXIT

;**********************************
;*           M A P M A N          *
;*        U T I L I T I E S       *
;**********************************



; READS THE SPECIFIED BIT MAP INTO STORE
;
; ON ENTRY
;     MAPPTR points to map table entry
;     MPTMPC IS CYLINDER NUMBER OF BIT MAP
;
; ON EXIT
;     MPSCPT points to first byte of bit map
;     MPSCOR points to first byte of bit map sector

RDBTMP ROUT ;READ BIT MAP
 STZ CBSIN ;ZERO OUT SIN
 STZ CBSIN+1
 STZ CBSIN+2
 STZ MPSCPT
 STZ MPSCPT+1
 LDYIM MP1BIT
 LDAIY MAPPTR ;**23/1/87** See if packed bitmap
 BNE #60 
 LDA MPTMPC ;GET CYLINDER NUMBER
 STA CBTPPT ;SAVE FOR DECREMENTING
 LDA MPTMPC+1
 STA CBTPPT+1
 JSR #90 ;**23/1/87** Calculate SIN of bit map
20 JSR SETBM ;**23/1/87** FOUND SO SET SIZE OF BIT MAP CHAIN
 JSR GTBTS ;READ IN BLOCK IF NECESSARY
 BNE #50 ;NON-ZERO IF FAILED
 CLC
 LDA CBSTA ;GET STORE ADDRESS
 STA MPSCOR ;**23/1/87** AND SAVE FOR RETURN
 ADC MPSCPT
 STA MPSCPT ;**23/1/87** calculate offset start
 LDA CBSTA+1
 STA MPSCOR+1
 ADC MPSCPT+1
 STA MPSCPT+1
 LDA ERRTYP
 BEQ #40
 LDA RSTFLG
 BNE #30
 LDAIM IERRAJ
 JSR INTERR
30 LDA CBSTA
 STA CLRPTR
 LDA CBSTA+1
 STA CLRPTR+1
 LDYIM 0
 LDXIM 1
 JSR CLRSTR
40 LDAIM 0
50 RTS

60 LDYIM MPSCYL ;**23/1/87** packed bit map code
 LDAIY MAPPTR ;calculate SIN of packed map
 STA CBTPPT
 INY
 LDAIY MAPPTR
 STA CBTPPT+1
 JSR #90
 LDA MPTMPC ;get cylinder number
 STA CBTPPT
 LDA MPTMPC+1
 STA CBTPPT+1
70 LDA CBTPPT ;see if sector/offset found
 ORA CBTPPT+1
 BEQ #20 ;yes, go read bit map sector
 LDA CBTPPT
 BNE #75
 DEC CBTPPT+1
75 DEC CBTPPT ;count through cylinders
 LDYIM MP1BIT
 CLC
 LDA MPSCPT ;calculate offset
 ADCIY MAPPTR
 BEQ #80
 STA MPSCPT
 ADCIY MAPPTR ;entry must not cross sector bdry
 BCC #70
 BEQ #70 ;exact fit allowed ok
80 STZ MPSCPT ;flows or new sector
 INC CBSIN
 BNE #70
 INC CBSIN+1
 BNE #70
 INC CBSIN+2
 BRA #70

90 LDA CBTPPT ;CHECK IF CYLINDER FOUND
 ORA CBTPPT+1
 BEQ #50 ; FOUND SO GO AND READ IN
 LDYIM MPSPCY
 CLC
 LDA CBSIN
 ADCIY MAPPTR
 STA CBSIN
 INY
 LDA CBSIN+1 ;GET TO NEXT BIT MAP
 ADCIY MAPPTR
 STA CBSIN+1
 BCC #95
 INC CBSIN+2
95 LDA CBTPPT ; DECREMENT CYLINDER COUNTER
 BNE #96
 DEC CBTPPT+1
96 DEC CBTPPT
 BRA #90

;
; READ THE BLOCK SPECIFIED AT ARGD INTO STORE
;
RDmpbd ROUT
 JSR MPsetd ;**8/5/87** MPTMPA = ARGD
 CLC ;**8/5/87** fall into RDMPBK

;
; READ THE SPECIFIED MAP BLOCK INTO STORE
;
; ON ENTRY
;     MPTMPA HOLDS SIN
;     CARRY SET IF BLOCK NOT TO BE READ IN
;
; ON EXIT
;     MAPTMP HOLDS POINTER
;
RDMPBK ROUT ;READ IN MAP BLOCK
 PHP ;SAVE STATE OF CARRY FLAG
 LDA MPTMPA ;GET SIN TO RIGHT PLACE
 STA CBSIN
 LDA MPTMPA+1
 STA CBSIN+1
 LDA MPTMPA+2
 STA CBSIN+2
 JSR SETMB ;**1/7/88**
 PLP ;GET CARRY FLAG BACK
 BCS #30 ;BRANCH IF NOT TO BE READ IN
 JSR GTBTS ; GET THE MAP BLOCK TO STORE
 BNE #20 ; NON-ZERO IF FAILED
 LDA CBSTA ;SAVE ADDRESS IN CORRECT PLACE
 STA MAPTMP
 STA GNCBPT
 LDA CBSTA+1
 STA MAPTMP+1
 STA GNCBPT+1
 LDYIM MBSQNO ;POINT TO FIRST SEQUNCE NUMBER
 LDAIY GNCBPT
 TAX
 CLC
 LDA GNCBPT
 ADCIM :LSB:LSTSQ
 STA GNCBPT
 LDA GNCBPT+1
 ADCIM :MSB:LSTSQ
 STA GNCBPT+1
 LDYIM 0
 TXA
 CMPIY GNCBPT ;COMPARE WITH LAST NUMBER
 BEQ #10
 LDAIM MPERRC
 RTS

10 LDAIM 0
20 RTS

30 JSR FNDMB
 BCC #40
 LDYIM CBSA
 BRA #50

40 JSR GETFR ;JUST FIND A FREE SPACE
 BNE #20
 LDYIM CBDR
 LDA MPDRVE
 STAIY GNCBPT
 LDYIM CAFLG
 LDAIY GNCBPT
 ORAIM 1 ;FLAG ALLOCATED
 STAIY GNCBPT
 INY
 LDA MPTMPA
 STAIY GNCBPT
 INY
 LDA MPTMPA+1
 STAIY GNCBPT
 INY
 LDA MPTMPA+2
 STAIY GNCBPT
 INY
50 LDAIY GNCBPT ;GET ADDRESS OF FREE STORE
 STA MAPTMP
 STA CLRPTR
 INY
 LDAIY GNCBPT
 STA MAPTMP+1
 STA CLRPTR+1
 LDYIM :LSB:BTINBK
 LDXIM :MSB:BTINBK
 JSR CLRSTR ;CLEAR MAP BLOCK TO ZEROES SINCE NOT READ IN
 BRA #10
 
; CALCULATE THE NUMBER OF SECTORS REQUIRED FROM
; THE NUMBER OF BYTES REQUIRED. 
;
;   ON ENTRY
;           DIVPAR HOLDS THE NUMBER OF BYTES
;
;   ON EXIT
;           DIVPAR HOLDS ODD BYTES
;           DIVTMP HOLDS THE NUMBER OF BLOCKS
;           Carry Set if Overflow
;
DVDE ROUT
 STZ DIVTMP
 STZ DIVTMP+1
 STZ DIVTMP+2
 LDA DIVPAR
 ORA DIVPAR+1
 ORA DIVPAR+2
 BEQ #40
10 SEC ;NOW LOOP DO DIVIDE BY BLOCK SIZE
 LDA DIVPAR
 SBCIM :LSB:BTINBK
 STA DIVPAR
 LDA DIVPAR+1
 SBCIM :MSB:BTINBK
 STA DIVPAR+1
 LDA DIVPAR+2
 SBCIM 0
 STA DIVPAR+2
 BCC #20 ;CARRY CLEAR AT END OF DIVISION
 LDA DIVPAR
 ORA DIVPAR+1
 ORA DIVPAR+2
 BEQ #30
 INC DIVTMP
 BNE #10
 INC DIVTMP+1
 BRA #10

20 LDA DIVPAR ;REPLACE LOWER BYTE
 ADCIM :LSB:BTINBK
 STA DIVPAR
 LDA DIVPAR+1
 ADCIM :MSB:BTINBK
 STA DIVPAR+1
 BCC #30
 INC DIVPAR+2
30 CLC
 LDA DIVTMP
 ADCIM 2 ;AT LEAST TWO BLOCKS LONG
 STA DIVTMP
 BCC #45
 INC DIVTMP+1
 BNE #45
 INC DIVTMP+2
 BNE #45
 SEC
 RTS

40 INC DIVTMP                      
45 CLC
 RTS

 LNK UADE11A
