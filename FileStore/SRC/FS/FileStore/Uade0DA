 OPT UADE0D ;FILE > Uade0DA
 TTL File server file UADE0DA

;RETDIR: RETRIEVE DIR BEFORE LAST COMPONENT OF FILE TITLE.

;EXIT: A = RC
;NAMPTR = PTR TO LAST TEXT NAME.
;DIRSTA = ADDR OF DIR IN MEMORY

;FUNCTION: IF SYNTAX OF FILE TITLE OK
;THEN RETRIEVE PENULTIMATE DIR
;FI

RETDIR ROUT
 JSR CHKTIT ;CHECK SYNTAX OF FILE TITLE
 BNE #70

;attempts to delete "$" fail in eyecatching manner
;**20/5/87** and "^", "&", "%" and "@" too!

 JSR ISLAST ;**23/1/87** check if name is last
 BNE #10
 JSR TSTROT ;look for ROOT here
 BEQ #02
 JSR TESTPD ;**20/5/87** check pseudo-directories also
 BNE #10
 JSR TSTTER
 BNE #10
02 LDAIM DRERRC ;'not found', well it cant be can it !
05 RTS ;exit with error

10 JSR LOADDR ;LOAD CURRENT DIR
 BNE #05 ;Fail, return (dir not locked **25/12/86**)

;IF THE FIRST NAME=ROOT or "^" or "$" or "%" or "@"
;THEN WE HAVE TO ADJUST NAMPTR

 JSR TSROOT ;SEE IF FIRST NAME COMPONENT=ROOT
 BEQ #15
 JSR Testpd ;**20/5/87** or pseudo-directory
 BNE #20
 INY
 LDAIY NAMPTR
 CMPIM SEPART ;**20/5/87** must be single char
 BNE #20
15 CLC
 LDA NAMPTR
 ADCIM 2
 STA NAMPTR
 BCC #20
 INC NAMPTR+1 ;NAMPTR+:=2

20 JSR ISLAST ;Check if last text name
 BEQ #60

;COPY NEXT TEXT NAME COMPONENT INTO TXTNAM
;& MOVE NAMPTR TO NEXT COMPONENT

 JSR LOADTX

 JSR Tsparn ;**2/6/87** test for parent "^"
 BNE #30
 JSR Unlock
 JSR Retpar ;**2/6/87** retrieve parent
 BEQ #20
 RTS

;CHECK DIR EXISTS

30 JSR FNDTEX ;SEARCH DIR FOR TEXT NAME
 BNE #45

;FIRST CHECK THAT ITS A DIR

40 JSR ISDIR
 BEQ #50 
 JSR FNDTEZ ;try on next match
 BEQ #40
45 JMP UNLOCK ;unlock the entry

;NOW PREPARE FOR NEXT DIR TO BE LOADED, AND
;UNLOCK THE CURRENT ONE

50 JSR SETSIN ;DIRSIN := SIN OF NEXT DIR TO BE LOADED
55 JSR UNLOCK ;UNLOCK CURRENT DIR
 JSR LOADDR ;**2/6/87** load next directory
 BNE #70
 BRA #20

60 LDAIM 0
70 RTS

ISDIR LDYIM DRACCS
 LDAIY CRNTEN ;check type found
 ANDIM TYPDIR
 CMPIM TYPDIR
 RTS

ISLAST ROUT ;Test if name is last
 LDA NAMPTR
 CMP LASTNM
 BNE #10
 LDA NAMPTR+1
 CMP LASTNM+1
10 RTS ;Exit with Z set correctly

RETENT ROUT
 JSR RETDIR ;FIND APPROPRIATE DIR
 BNE #10
 JSR LOADTX ;COPY LAST TEXTNAME INTO TXTNAM
 LDAIM &02 ;**2/6/87** is "^" allowed?
 BIT Dirwc
 BEQ #00
 JSR Tsparn ;**2/6/87** test for parent "^"
 BNE #00
 JSR Unlock
 BRA Retpar

00 JSR FNDTEX ;SEARCH FOR LAST TEXT NAME
 BEQ #10
05 JSR UNLOCK
10 RTS

RETEND JSR RETENT ;**20/5/87**
 BNE #10
 JSR Tsparn ;**8/8/87** test for parent "^"
 BEQ #10
20 JSR ISDIR
 BEQ #10
 JSR FNDTEZ
 BEQ #20
 BRA #05

Tsparn ROUT ;**1/6/87**
 LDA TXTNAM ;**1/6/87** test for parent "^"
 CMPIM "^"
 BNE #10
 LDA TXTNAM+1
 CMPIM &20
10 RTS

; Retrieve parent directory **23/1/87**

RETPAR ROUT
 JSR LOADDR ;**23/1/87** load current directory
 BNE #50
 LDYIM DRSTAR+DRLINK ;**23/1/87** special unchained entry?
 LDAIM &FF
 CMPIY DPTRLD
 BNE #60
 INY
 CMPIY DPTRLD
 BNE #60
 LDYIM DRSTAR+DRSIN ;**23/1/87** extract parent SIN only
 LDAIY DPTRLD
 STA DIRSIN
 INY
 LDAIY DPTRLD
 STA DIRSIN+1
 INY
 LDAIY DPTRLD
 STA DIRSIN+2
 JSR UNLOCK ;release current directory

 LDYIM UTPRIV ;now select access
 LDAIY DRUSIN
 ANDIM SYSTPV ;same as now if system user
 BNE #30
 LDAIM 4 ;MAPMAN.SINOFROOT
 JSR SETDSA
 JSR MAPMAN ;**1/6/88** revised tests
 BNE #70 ;fail if can't locate root
 LDYIM ARGB ;check if parent is root directory
 LDAIY NEWARG
 CMP DIRSIN
 BNE #30 ; no, will use same access as child
 INY
 LDAIY NEWARG
 CMP DIRSIN+1
 BNE #30
 INY
 LDAIY NEWARG
 CMP DIRSIN+2
 BNE #30
 LDAIM TYPDIR+ANYBDY ;root, access reverts now to public
 STA DIRACC

30 JSR LOADDR ;load parent directory
 BNE #50
 LDAIM 0
50 RTS

60 LDAIM DRERRC ;parent not found
70 JMP UNLOCK ;unlock and exit
 

TSTDIR ROUT
 JSR ISDIR ;Test CRNTEN for directory
 BEQ #10
 JSR UNLOCK ;UNLOCK CURRENT DIR IF ENTRY NOT FOR A DIR
 LDAIM DRERRD ;RC := OBJECT NOT A DIR
10 RTS

SETSIN LDYIM DRSIN ;DIRSIN := SIN OF CRNTEN
 LDAIY CRNTEN
 STA DIRSIN
 INY
 LDAIY CRNTEN
 STA DIRSIN+1
 INY
 LDAIY CRNTEN
 STA DIRSIN+2
 RTS

;MAXACC: CALC ACCESS TO A PARTICULAR DIR ENTRY
;EXIT: A:=OBJACC:= TYPE & MAX ACCESS TO OBJECT

MAXACC ROUT
 LDYIM DRACCS
 LDAIY CRNTEN
 ANDIM TLAMSK
 STA OBJACC ;OBJACC:=TYPE & ACCESS SPECIFIED IN DIR ENTRY
 ANDIM TYPDIR
 BEQ #10

;ITS A DIR SO OBJACC := TYPDIR!DIRACC

 LDA DIRACC
 ANDIM OWNER ;** 30/9/84 **
 ORA OBJACC
 BRA #30

;ITS A FILE SO
;IF (DIRACC & OWNER) = OWNER
;THEN TYPFIL!((OBJACC SHR 2)&RDWRACC)!(OBJACC&RDWRAC)
;ELSE TYPFIL ! (OBJACC & RDWRAC)
;FI

10 LDA DIRACC
 ANDIM OWNER
 BEQ #20 ;BRANCH IF ANYBODY

;OWNER ACCESS

 LDA OBJACC
 LSRA
 LSRA
 ANDIM RDWRAC
 TAX  ;X:= A & RDWRAC
 LDA OBJACC
 ANDIM LOCKED ;** 28/3/85 **
 STA OBJACC
 TXA
 ORA OBJACC
 BRA #30

;ANYBODY ACCESS

20 LDA OBJACC
 ANDIM RWLACC ;ANYBODY ACCESS
30 STA OBJACC
 LDA DIRACC
 ANDIM OWNER
 ORA OBJACC ;Include owner bit in result
 STA OBJACC
 RTS

LOADTX ROUT
 LDAIM :LSB:TXTNAM ;MOVE TEXT NAME INTO TXTNAM
 STA TXTPTR
 LDAIM :MSB:TXTNAM
 STA TXTPTR+1
 LDYIM  0
10 LDAIY NAMPTR
 CMPIM TERMIN
 BEQ #20
 CMPIM SEPART
 BEQ #20
 STAIY TXTPTR ;MOVE CHAR INTO TXTNAM
 INY
 BRA #10

;MAKE NAMPTR PT TO 1ST CHAR AFTER <terminator>|<separator>

20 TYA
 SEC ;ADD 1
 ADC NAMPTR
 STA NAMPTR
 BCC #30
 INC NAMPTR+1

;FILL REMAINDER OF TXTNAM WITH SPACES

30 CPYIM NAMLNT+1 ;** 5/9/84 **
 BEQ #40
 LDAIM SPACE
 STAIY TXTPTR
 INY
 BNE #30
40 RTS

SETFRE ROUT
 CLC  ;SETUP DIRFRE (ADDR OF FREE CHAINPTR IN DIR)
 LDA DIRSTA
 ADCIM DRFREE
 STA DIRFRE
 LDA DIRSTA+1
 ADCIM 0
 STA DIRFRE+1
 LDYIM 0 ;TEST FOR [DIRFRE]=0
 LDAIY DIRFRE
 INY
 ORAIY DIRFRE ;A=0 IF NO FREE ENTRIES
 RTS

;DELCHK: RTN TO CHECK WHETHER A DIR ENTRY MAY BE DELETED

;EXIT: A = RC

;FUNCTION: IF ENTRY 'LOCKED'
;THEN ERROR (I.E. A>0)
;ELIF OBJECT OPEN
;THEN ERROR
;ELIF TYPE = TYPDIR ANDF NOT EMPTY
;THEN ERROR
;ELSE OBJECT MAY BE DELETED (I.E. A = 0)
;FI

DELCHK ROUT
 LDYIM DRACCS
 LDAIY CRNTEN
 ANDIM LOCKED
 BEQ #10
 LDAIM DRERRG
 RTS

;SAVE SIN OF OBJECT TO BE DELETED

10 JSR CRNSIN ;OBJSIN := SIN OF OBJECT

;SEE IF THE OBJECT TO BE DELETED IS OPEN

 LDAIM 2
 JSR SETDSA ;SETUP DISC NO AND SIN ON NEWARG STACK
 JSR RNDMAN ;RNDMAN.INFO
 BNE #20
 LDAIM DRERRI ;CANNOT DELETE OPENED OBJECT
 RTS

;IF IT IS DIR MAKE SURE THAT IT IS EMPTY

20 LDYIM DRACCS
 LDAIY CRNTEN
 ANDIM TYPDIR
 BEQ #50 ;Exit; A=0 and Z set

;LOAD FIRST BLOCK OF THE DIR
;TO SEE IF IT IS EMPTY

 LDAIM 1
 JSR SETDSA ;PLACE DISC NO AND SIN ON NEWARG STACK
 LDYIM ARGG
 LDAIM 0
 STAIY NEWARG ;LS
 INY
 STAIY NEWARG ;MS(BLK NO) START BLOCK NO := 0
 INY  ;Y:=ARGI
 INCA ;one
 STAIY NEWARG
 INY
 DECA ;zero
 STAIY NEWARG ;NO OF BLOCKS TO BE LOADED := 1
 JSR STRMAN
 BNE #50
 LDYIM ARGB
 LDAIY NEWARG
 STA GENPTR
 INY
 LDAIY NEWARG
 STA GENPTR+1 ;GENPTR:=STORE ADDRESS OF LOADED DIR
 LDYIM DRFRST ;PTR TO FIRST DIR ENTRY IN USE
 LDAIY GENPTR
 INY
 ORAIY GENPTR
 PHA  ;PUSH A
 LDAIM 4
 JSR SETRTN
 JSR STRMAN ;STRMAN.FLUSH WINDOW
 BEQ #40
 PLX
 TAX
 RTS

40 PLA
 BEQ #50
 LDAIM DRERRJ
50 RTS

FREECH ROUT
 JSR SETFRE
 LDYIM 0 ;RTN TO PLACE ENTRY ON FREE CHAIN
 LDAIY DIRFRE
 STAIY CRNTEN
 INY
 LDAIY DIRFRE
 STAIY CRNTEN ;[CRNTEN] := [FREE ENTRY PTR]

 SEC  ;CALC RELATIVE ADDRESS OF CRNTEN
 LDA CRNTEN
 SBC DIRSTA
 LDYIM 0
 STAIY DIRFRE
 LDA CRNTEN+1
 SBC DIRSTA+1
 INY
 STAIY DIRFRE ;[DIRFRE] := DIR ENTRY
 RTS

; SETDSA: Put arg, DRDISC & OBJSIN on NEWARG stack
; SETDSN: Put just DRDISC & OBJSIN on NEWARG stack
; Exits:  Y=ARGF

SETDSA ROUT
 JSR SETRTN ;Put arg on NEWARG stack **25/12/86**
SETDSN LDYIM ARGB ;PUT DISC NO & OBJSIN ON NEWARG STACK
 LDA DRDISC
 STAIY NEWARG
 INY
 LDA DRDISC+1
 STAIY NEWARG
 INY
 LDA OBJSIN
 STAIY NEWARG
 INY
 LDA OBJSIN+1
 STAIY NEWARG
 INY
 LDA OBJSIN+2
 STAIY NEWARG
 RTS

ARGDSN LDYIM ARGB ;PLACE DISC NO & OBJSIN ON ARGPTR STACK
 LDA DRDISC
 STAIY ARGPTR
 INY
 LDA DRDISC+1
 STAIY ARGPTR
 INY
 LDA OBJSIN
 STAIY ARGPTR
 INY
 LDA OBJSIN+1
 STAIY ARGPTR
 INY
 LDA OBJSIN+2
 STAIY ARGPTR
 RTS

CRNSIN LDYIM DRSIN ;OBJSIN := SIN OF CRNTEN
 LDAIY CRNTEN
 STA OBJSIN
 INY
 LDAIY CRNTEN
 STA OBJSIN+1
 INY
 LDAIY CRNTEN
 STA OBJSIN+2
 RTS

SINSZE LDAIM 5 ;CALL MAPMAN.SIZE FOR OBJSIN
 JSR SETDSA
 JMP MAPMAN

RETDSZ LDYIM INFDIS ;MOVE DISC NO & SIZE INTO INFPTR
 LDA DRDISC
 STAIY INFPTR
 INY
 LDA DRDISC+1
 STAIY INFPTR
 JSR SINSZE
 PHA ;Record MAPMAN return code
 LDYIM ARGB ;MOVE SIZE ON NEWARG STACK TO INFPTR
 LDAIY NEWARG
 LDYIM INFSZE
 STAIY INFPTR
 LDYIM ARGC
 LDAIY NEWARG
 LDYIM INFSZE+1
 STAIY INFPTR
 LDYIM ARGD
 LDAIY NEWARG
 LDYIM INFSZE+2
 STAIY INFPTR ;MS(SIZE)
 PLA ;Restore MAPMAN return code
 RTS

TSROOT ROUT
 LDYIM 0 ;TEST FOR <root>
 LDAIY NAMPTR
 CMPIM ROOT
 RTS

TSTROT ROUT
 JSR TSROOT ;TEST FOR <root><terminator>
00 BNE #10
TSTTER INY
05 LDAIY NAMPTR
 CMPIM TERMIN
10 RTS

TSTERM LDYIM 0 ;is file title <term> omly?
 BRA #05
                  
TSTPAR ;**23/1/87**
 LDYIM 0
 LDAIY NAMPTR
 CMPIM "^" ;check parent directory name
 BRA #00

TESTPD ROUT ;**2/6/87** test pseudo-directory name
 CMPIM "^"
 [ Pseudods = Yes
 BEQ #10
 CMPIM "&"
 BEQ #10
 CMPIM "%"
 BEQ #10
 CMPIM "@"
 ]
10 RTS

TSTOWN ROUT
 LDA DIRACC ;TEST FOR OWNER ACCESS
 ANDIM OWNER
 CMPIM OWNER
 BEQ #10
 LDAIM DRERRE ;INSUFFICIENT ACCESS
10 RTS

SETGEN LDA DIRSTA ;GENPTR := [DIRSTA]
 STA GENPTR
 LDA DIRSTA+1
 STA GENPTR+1
 RTS

;OUTPUT LOAD AND EXECUTE ADDRESSES
;FOR THE CURRENT ENTRY.

OUTLEX LDYIM DRLOAD
 JSR OUTHEX
 JSR OUTSP
 LDYIM DREXEC
 JSR OUTHEX
 LDXIM 3
 JMP OUTSPS ;SPACE AND EXIT

 LNK UADE0E
