
 OPT UADE15 ; > Uade15
 TTL File server file UADE15


;*  C O M M A N D  P R O C E S S O R*

CMND ROUT

;SET UP RXCB

 STZ RIPPLE ;Rxcb counter

 JSR OPENRX ;open CB1

; QPTR is always zero as only one CB is
; read at any time

 STZ QPTR ;standard offset

;Provide p.0 pointer to control block (used
;in XMIT/REPLY etc.)

 CLC
 LDA QPTR
 ADCIM :LSB:RXCBV
 STA NETCB
 LDAIM :MSB:RXCBV
 ADCIM 0
 STA NETCB+1

;Now poll the control blocks using the MOS

COMRTS  ;come here for new command

 BIT Cmndsw ;ignore door in maintenance modes
 BMI #50
 BVS #10 ;br if door open for disc change

 LDAIM 128 ;poll door switch
 LDXIM 0
 JSR OSbyte
 ANDIM 2
 BEQ #50 ;br unless drive door opened

; Door has been opened, presumably user wishes to change one or more discs

 LDAIM &40 ;mark door noted open
 TSB Cmndsw
 LDAIM 137 ;turn on led
 LDXIM 1
 JSR OSbyte
 LDAIM 8
 JSR Setrtn
 JSR Usrman ;USRMAN.QUIT
 JSR Flusys ;flush entire system for restart

; Door is open, flash led from clock until door closed.
; Then restart movable drives only.

10 JSR Getdte ;get date to find seconds
 LDA Date+4
 ANDIM 1
 TAX
 LDAIM 137 ;flash led slowly
 JSR OSbyte

 LDAIM 128 ;poll door switch
 LDXIM 0
 JSR OSbyte
 ANDIM 2
 BNE #50 ;until door closed

 LDAIM 137 ;turn off led
 LDXIM 0
 JSR OSbyte

 LDA Drives ;restart changeable drives
20 DECA
 CMPIM 4 ;(assume drives 4 up are movable)
 BCC #30 ;br if all drives restarted
 STA Curdrv
 LDYIM Argb
 STAIY Newarg
 LDAIM 9
 JSR Setrtn
 JSR Mapman ;*** Restart one drive ***
 BNE #25
 LDA Curdrv
 BRA #20

25 JSR USRERR ;drive restart failed.  What better now?

30 LDAIM 6 ;Restart AUTMAN
 JSR Setrtn ;Ignore any error (no PW file) because
 JSR Autman ;There was a PW file earlier
 STZ Cmndsw ;Indicate back in user mode

50 LDX RXTAB ;get number of CB to poll
 STX RXCBN ;save this for later use
 LDAIM 51 ;poll Rx number (X)
 JSR OSBYTE ;result returned in X
 TXA
 BMI #60 ;leap off to deal with the Rx'd packet
 JSR Pollps ;else check printer polling
 JMI PRjump ;then go test other printer activity

;Reception has happened, so check
;the function code in the RXbuffer
;and jump to the operation.

60 LDA RXCBN ;save CB number
 PHA ;altered in OPENRX
 JSR OPENRX ;open a new Rxcb
 PLA ;RXTAB updated to new CB here
 STA RXCBN ;reset CB number

 LDXIM :LSB:RXCBN
 LDYIM :MSB:RXCBN
 LDAIM &11 ;MOS interface
 JSR OSWORD ;read the control block

; the structure set up in RXCBV is of the form
; CB number (1) ;in RXCBN
; CB data (12)

 SEC
 LDA RXCBV+4 ;get low byte of address
 SBCIM :LSB:RXBUF ;calculate buffer offset
 STA BPTR ;point at the buffer
 TAX

 LDAAX RXBUF ;Reply port at top of buffer
 STA RPLYPT ;Store reply port

 LDA CBBUF
 STA OLDRXB ;STORE OLD BUFFER PTR.
 LDA CBBUF+1
 STA OLDRXB+1

 LDAAX RXBUF+1 ;Get fn. code
 BEQ #80 ;code 0 always allowed
 BIT Cmndsw ;Else ensure in user mode
 BMI #70 ;Fault if either command mode
 BVC #80 ;Ok if user mode door closed
70 JMP Badmod

80 CMPIM FCMAX ;Is < biggest fn. code?
 BCC #90 ;Yes => ok

;Send error return to machine

 LDAIM COERRA
 JSR EXTERR

;Finish command (don't matter if error
;didn't get through).

 JMP COMRTS


;FN. code is ok, so get routine entry address

90 ASLA
 TAX
 LDY BPTR
 LDAAY CPUFD ;**20/5/87** set all handles for use
 STA UMHUFD ;**20/5/87** by pseudo-directory references
 LDAAY CPLIB
 STA UMHLIB
 LDAAY CPCSD
 STA UMHCSD
 JMIX FNTAB ;Enter routine


;T A B L E S

CTABA ROUT

;Initial receive control block
;First 12 bytes - addresses may change

 = RXFLAG
 = COPORT ;Command port
 = 0
 = 0 ;Set to RX on any station
 & RXBUF
 = 0,0
 & RXBUF+RXBUFL
 = 0,0

FNTAB ROUT

;Addresses of functions

 & CLINE ;Decode command line
 & SAVONA ;1
 & LOAD   ;2
 & EXAMIN ;3
 & CATHDR ;4
 & LOAD ;Load command for execution
 & FIND   ;6
 & CPSHUT ;7
 & GETBYT ;8
 & PUTBYT ;9
 & GBYTES ;10
 & PBYTES ;11
 & CPRDAR ;=> GETARGS
 & CPSTAR ;=> SETARGS
 & DISCS  ;14
 & CPUSRS ;15
 & CPDATE ;16
 & CPEOF  ;17
 & CPINFO ;18
 & CPSTAT ;Set object attributes
 & CPDEL ;Delete from fn. code
 & USRENV ;21
 & CPSOPT ;Set user option bits
 & FCBYE ;Logoff by function code
 & CPUINF ;Single user info.
 & CPVERN ;25
 & CPSPAC ;26 - returns disc free space
 & CDIRFN ;27 - cdir from function code, specify size
 & CPSETD ;28 - Set date and time from program
 & SAVONA ; 29 - Do a 'create', like 'save' but no data
 & RDFREE ;30 - read callers free space
 & WRFREE ;31 - write users free space
 & CPWHO ;32 - return client user name
FNusr2 & CPUSRS ;33 - user list with job/task numbers
FNuin2 & CPUINF ;34 - single user info with job/task number
FCMAX * (.-FNTAB)/2

;COMMAND LINE DECODER ....

;Command table.  Verb string; mode mask; and process address.
; Mode mask has &80 (always); &20 if allowed in user mode;
; &40 if allowed in maint. mode 1, &10 if ok in maint. mode 0.

COMTAB

 [ Lang = English
 = "CAT",&A0
 & CAT
 = "DELETE",&A0
 & DELETE
 = "INFO",&A0
 & INFO
 = "LOAD",&A0
 & DOLOAD
 = "SAVE",&A0
 & SAVE
 = "DIR",&A0
 & SELDIR
 = "SDISC",&A0
 & SELDSC
 = "CDIR",&A0
 & CDIR
 = "ACCESS",&A0
 & SETACC
 = "PASS",&A0 
 & SETPW
 = "I AM",&B0
 & LOGON
 = "BYE",&A0
 & USROFF
 = "NEWUSER",&A0
 & NEWUSE
 = "PRIV",&A0
 & STPRIV
 = "LIB",&A0
 & SLIB
 = "REMUSER",&A0
 & REMUSE
 = "RENAME",&A0
 & RENAME
 = "REPORT",&E0
 & REPORT
 = "PRNAME",&A0
 & PRNAME
 = "FORMAT",&C0
 & FMFORM
 = "VERIFY",&C0
 & VERIFY
 = "CERTIFY",&C0
 & CERTIFY
 = "MAXDRIVE",&C0
 & RDMAXD
 = "MAXUSER",&C0
 & RDMAXU
 = "FSSTN",&C0
 & SETSTN
 = "FSMODE",&F0 ;unique code for FSMODE
 & FSMODE
 = "FSPROT",&C0
 & FSPROT
 = "FSUSER",&C0
 & FSUSER
 =  0 ;Indicates table end
 ]

 [ Lang = Italian
 = "CANCELLA",&A0
 & DELETE
 = "INFO",&A0
 & INFO
 = "DIR",&A0
 & SELDIR
 = "SDISC",&A0
 & SELDSC
 = "CDIR",&A0
 & CDIR
 = "ACCESSO",&A0
 & SETACC
 = "PASSA",&A0 
 & SETPW
 = "I SONO",&B0
 & LOGON
 = "CIAO",&A0
 & USROFF
 = "NUTENTE",&A0
 & NEWUSE
 = "PRIV",&A0
 & STPRIV
 = "BIBL",&A0
 & SLIB
 = "RIMUT",&A0
 & REMUSE
 = "RINOME",&A0
 & RENAME
 = "RIPORTA",&E0
 & REPORT
 = "NSTAMP",&A0
 & PRNAME
 = "PRPAGE",&C0
 & PRPAGE
 = "FORMATTA",&C0
 & FMFORM
 = "VERIFICA",&C0
 & VERIFY
 = "CERTIFICA",&C0
 & CERTIFY
 = "DRIVEMAS",&C0
 & RDMAXD
 = "UTEMAS",&C0
 & RDMAXU
 = "STMEFILE",&C0
 & SETSTN
 = "MOMEFILE",&F0 ;unique code for FSMODE
 & FSMODE
 = "PROTMEFILE",&C0
 & FSPROT
 = "UTMEFILE",&C0
 & FSUSER
 = "NOMEDISC",&C0
 &NMDISC
 =  0 ;Indicates table end
 ]

CLINE ROUT
 LDAIM :LSB:(Comtab-1)
 STA Genptr ;**20/2/87**
 LDAIM :MSB:(Comtab-1)
 STA Genptr+1
 CLD
10 LDY BPTR
 JSR SPACES
 DEY
20 INY
 JSR Incgpt
 LDAI Genptr
 BEQ BADCOM ;Last delimiter is zero
 BMI #50 ;Check next char after command is non-alpha
 EORAY MIDRX ;Compare
 ANDIM &DF ;Force cases
 BEQ #20
 BRA #35

30 JSR Incgpt
35 LDAI Genptr
 BPL #30
 LDAAY MIDRX
 CMPIM "."
 BNE #55
 INY
 BRA #60

50 LDAAY MIDRX ;Otherwise check char. after cmnd. is non-alpha
 JSR ISCHAR
 BCS #60 ;Is non-alpha => end of command
55 JSR Incgpt
 JSR Incgpt ;Inc. past terminator and address
 BRA #10

60 LDAIM &20 ;check type of command
 BIT Cmndsw
 BPL #70
 ASLA ;Maintenance mode 1 terminator bit
 BVS #70
 LSRA
 LSRA ;Maintenance mode 0 terminator bit
70 ANDI Genptr ;Check terminator
 BEQ Badmod ;Error if wrong mode command
 BIT Cmndsw ;Check if maintenance mode 1 or door open
 BVC #80
 LDAIM &F0 ;FSMODE command?
 CMPI Genptr
 BEQ #80 ;No station check (here)
 BIT Cmndsw ;User mode door open?
 BPL Badmod ;Yes, say bad mode now
 PHY
 JSR Fsmody ;Else check locked station
 BNE #85
 PLY
80 JSR Incgpt ;Get command processor address
 LDAI Genptr
 STA Cozero
 JSR Incgpt
 LDAI Genptr
 STA Cozero+1
 JMI Cozero ;Enter command processor

85 PLY ;reload Y and fall into BADCOM

;UNRECOGNISED COMMAND

BADCOM ROUT
 JSR BUFTXT
 BNE #30 ;Quotes error
 LDXIM 0 ;Now move from TXTBUF to TXBUF
10 LDAAX TXTBUF
 STAAX MIDTX
 INX
 CMPIM CR
 BNE #10

 CPXIM 1
 BNE #20
 LDAIM WOTERR
 JSR EXTERR ;Do WHAT? error immediately
 BRA #30

20 TXA
 CLC
 ADCIM TXHDR ;Message length
 LDYIM CCCMND
 STY CCODE
 JSR REPLYC
30 JMP COMRTS

 [ Lang = English
40 = "Bad command in ",0
 ]
 [ Lang = Italian
40 = "Comando errato nel ",0
 ]

Badmod BIT Cmndsw ;Door open or true wrong mode?
 BMI #45 ;Maintenance modes
 BVC #45 ;User mode
 LDAIM Doorer ;Door open, fail caller
 JMP Error

45 LDXIM 0 ;Special wrong mode error msg
50 LDAAX #40 ;Build base
 BEQ #55
 STAAX Midtx
 INX
 BRA #50

55 JSR Setmod ;add mode text
 LDAIM Woterr ;fix up message code
 STA RTcode
 TXA
 CLC
 ADCIM Txhdr
 STZ Ccode
 JSR Reply
 BRA #30

;Convert to decimal

MKDEC ROUT
 TAY
 LDAIM &FF
 STA TEMPA ;leading zero flag

 LDAIM 100
 JSR #10
 STA COWORK
 LDAIM 10
 JSR #10
 STA COWORK+1
 LDAIM 1

10 STA COWORK+3
 TYA
 LDXIM "0"-1
 SEC

20 INX
 SBC COWORK+3
 BCS #20
 ADC COWORK+3

 CPXIM "0"
 BNE #30
 BIT TEMPA
 BPL #30
 LDXIM SPACE
 BNE #40

30 INC TEMPA ;print zeros
40 TAY ;restore original parameter
 TXA
 STA COWORK+2 ;save this for now
 RTS


; Routine to open RECEIVE CB

OPENRX ROUT
 LDXIM 11 ;Table offset
10 LDAAX CTABA
 STAAX RXCBV ;Set flag, port and stid and bfr addresses.
 DEX
 BPL #10

 STZ RXCBN ;ready for OSWORD call

;Now correct buffer pointers if second buffer.
;The one byte gap between the buffers
;is to prevent corruption when a zero is placed
;at the end of received data to prevent
;catastrophe when a bad file name is being
;decoded.

 LDA RIPPLE
 INC RIPPLE
 LSRA ;flag in carry

 BCC #20

 LDAIM :LSB:(RXBUF+RXBUFL+1)
 STA RXCBV+4
 LDAIM :MSB:(RXBUF+RXBUFL+1)
 STA RXCBV+5

 LDAIM :LSB:(RXBUF+RXBUFL+RXBUFL+1)
 STA RXCBV+8
 LDAIM :MSB:(RXBUF+RXBUFL+RXBUFL+1)
 STA RXCBV+9

;At this point, previous CB is set to receive.

20 LDXIM :LSB:RXCBN
 LDYIM :MSB:RXCBN
 LDAIM &11
 JSR OSWORD ;do OPENRX

 LDA RXCBN
 STA RXTAB ;save CB number
 BNE #30

 LDAIM IERRAI ;unable to open Rxcb
 JMP INTERR

30 RTS

 LNK UADE15A
