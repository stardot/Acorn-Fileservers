 OPT UADE14 ; > Uade14
 TTL File server file UADE14

;*********************************
;*           D S C M A N         *
;*********************************

;DSCMAN: THE DISC MANAGER
;THIS MODULE READS & WRITES OBJECTS FROM
;AND TO THE DISC.
;NOTE THAT IT USES MANY OF THE POINTERS,VARIABLES,
;AND ROUTINES PROVIDED BY MAPMAN.


;ENTRY:
;ARGA = (1=>READ,2=>WRITE)
;ARGB-C DISC NO
;ARGD-F SIN
;ARGG-H START BLOCK NO
;ARGI-J NUMBER OF BLOCKS
;ARGK-L STORE ADDRESS

;EXIT: ARGA = RC



;********** MAIN ROUTINE **********

DSCMAN ROUT
 LDXIM 4
 LDAIM MODDSC
 JSR ENTRY
 JMIX DCRTNS ;N.B. NO NEED FOR SETFS-NOT CALLING ANY MODULE
DCRTNS
 & DCREAD ;1 => READ
 & DCWRIT ;2 => WRITE
 & DCIORD ;3 => READ (I/O processor style)
 & DCIOWR ;4 => WRITE (I/O processor style)
DCEXIT JMP PREXIT



;************ DCREAD ************


;DCREAD: READ AN OBJECT FROM THE DISC.
;NOTE IF A SECTOR HAS NOT BEEN WRITTEN THEN
;THE APPROPRIATE AREA OF STORE IS CLEARED TO ZERO.


DCIORD ROUT
DCREAD LDAIM 8 ;Select MOS read command
00 PHA ;**29/2/88** save function code

 JSR DCINIT ;INITIALISE FOR DSCMAN VARIABLES
 TAX
 PLA
 STA SAVCOM ;**29/2/88** restore function code
 TXA
 BNE #30

20 LDA MAPTMP ;DCSECT := MAPTMP (I.E SECTOR NUMBER)
 STA DCSECT
 STA RBDA
 LDA MAPTMP+1
 STA DCSECT+1
 STA RBDA+1
 LDA MAPTMP+2
 STA DCSECT+2
 STA RBDA+2

 LDA LDRNB ;Set logical drive number
 STA DRIVNO

 LDA DCRASH
 BNE #40 ;If a disc error occured in NMI task...error.

 JSR XFERIN ;TRANSFER MPTMPD SECTORS
 JSR MOVEON ;FIND NEXT SECTORS FROM DISC MAP
 BEQ #20
 CMPIM 1
 BNE #30 ;no more to transfer
 DECA ;set zero
30 TAX
 LDA DCRASH
 BNE #40 ;Check no crash on last BG job
 TXA
40 BRA DCEXIT



;************ DCWRIT ************


;DCWRIT: WRITE AN OBJECT TO DISC
;NOTE THAT IF A SECTOR IS WRITTEN FOR THE FIRST TIME
;IT IS MARKED DIRTY IN THE MAP (IN WHICH CASE
;THE MAP IS MARKED DIRTY).


DCIOWR
DCWRIT LDAIM &0A ;Select MOS write command
 BRA #00


;DCINIT: INITIALISE DSCMAN VARIABLES FOR TRANSFER
;0) GET APPROPRIATE DISC MAP LOADED
;1) LDRNB := LOGICAL DRIVE NUMBER (GOT FROM MAPTB ENTRY)
;2) NBLKS := NUMBER OF DISC BLOCKS TO TX
;3) DCSTAD := STORE ADDRESS OF SECTOR
;4) CHECK SIN IS FOR START OF OBJECT
;5) MAPTMP := SIN, MPSCPT:=PTR TO RELEVENT MAP ENTRY
;6) DSCTMP := PTR TO MAP'S DIRTY FLAG



DCINIT ROUT
 STZ DSCCB+TRADD+2 ;Zero high store addr
 STZ DSCCB+TRADD+3
 STZ DCRASH ;Initialise disc error flag
 JSR FNDMAP ;MAPPTR & MAPENT PT MAPTB ENTRY
 BNE #20
 LDA MPDRVE
 STA LDRNB ;LDRNB:= LOGICAL DRIVE NUMBER

;FIRST CHECK THAT THE SPECIFIED SIN IS SENSIBLE

 LDYIM ARGD
 LDAIY ARGPTR
 STA MPTMPA
 INY
 LDAIY ARGPTR
 STA MPTMPA+1 ;MPTMPA:=SIN
 INY
 LDAIY ARGPTR
 STA MPTMPA+2
 CLC
 JSR RDMPBK
 BNE #20
 LDA MAPTMP
 STA MPMBPT
 LDA MAPTMP+1
 STA MPMBPT+1
 STZ NBLKS+1
 LDYIM ARGI
 LDAIY ARGPTR
 STA NBLKS ;NBLKS:=NUMBER OF SECTORS TO BE TX
 BNE #30
10 LDAIM DCERRA ;INVALID NUMBER OF BLOCKS
20 RTS

30 INY
 LDAIY ARGPTR
 BNE #10

 LDYIM ARGK
 LDAIY ARGPTR
 STA DCSTAD
 INY
 LDAIY ARGPTR
 STA DCSTAD+1 ;DCSTAD:=STORE ADDRESS


;NOW GET TO THE CORRECT STARTING POINT IN THE OBJECT

 LDYIM ARGG
 LDAIY ARGPTR
 STA BREGA
 INY
 LDAIY ARGPTR
 STA BREGA+1 ;BREGA:=START BLOCK NUMBER

DCENT2 LDAIM :LSB:MBENTS
 STA MPTMPB
 LDAIM :MSB:MBENTS
 STA MPTMPB+1
 CLC
 LDA MPMBPT
 ADC MPTMPB
 STA MPSCPT
 LDA MPMBPT+1
 ADC MPTMPB+1
 STA MPSCPT+1
50 SEC
 LDYIM 3
 LDA BREGA
 SBCIY MPSCPT
 STA BREGA
 LDA BREGA+1
 INY
 SBCIY MPSCPT
 STA BREGA+1
 BCC #60
 JSR NXTEN
 BEQ #50
 RTS

60 CLC
 LDYIM 3
 LDAIY MPSCPT
 ADC BREGA
 STA BREGA
 INY
 LDAIY MPSCPT
 ADC BREGA+1
 STA BREGA+1
 LDYIM 0
 CLC
 LDAIY MPSCPT
 ADC BREGA
 STA MAPTMP
 INY
 LDAIY MPSCPT
 ADC BREGA+1
 STA MAPTMP+1
 INY
 LDAIY MPSCPT
 ADCIM 0
 STA MAPTMP+2
 SEC
 INY
 LDAIY MPSCPT
 SBC BREGA
 STA MPTMPD
 INY
 LDAIY MPSCPT
 SBC BREGA+1
 STA MPTMPD+1
 JSR SETSZE

 LDAIM 0
 RTS

SETSZE ROUT
 LDA NBLKS
 CMP MPTMPD
 LDA NBLKS+1
 SBC MPTMPD+1
 BCS #10
 LDA NBLKS
 STA MPTMPD
 LDA NBLKS+1
 STA MPTMPD+1
10 RTS

NXTEN ROUT
 CLC
 LDA MPTMPB
 ADCIM :LSB:ENSZ
 STA MPTMPB
 LDA MPTMPB+1
 ADCIM :MSB:ENSZ
 STA MPTMPB+1
10 CLC
 LDA MPMBPT
 ADC MPTMPB
 STA MPSCPT
 LDA MPTMPB+1
 ADC MPMBPT+1
 STA MPSCPT+1
 LDYIM 0
 LDAIY MPSCPT
 INY
 ORAIY MPSCPT
 INY
 ORAIY MPSCPT
 BEQ #30
 LDA MPTMPB
 CMPIM :LSB:LSTENT
 LDA MPTMPB+1
 SBCIM :MSB:LSTENT
 BCC #40
 LDYIM 0
 LDAIY MPSCPT
 STA MPTMPA
 INY
 LDAIY MPSCPT
 STA MPTMPA+1
 INY
 LDAIY MPSCPT
 STA MPTMPA+2
 LDA DSCCB+TRADD+2
 PHA
 LDA DCSTAD
 PHA
 LDA DCSTAD+1
 PHA
 LDA SAVCOM
 PHA
 CLC
 JSR RDMPBK
 BNE #20
 PLA
 STA SAVCOM
 PLA
 STA DCSTAD+1
 PLA
 STA DCSTAD
 PLA
 STA DSCCB+TRADD+2
 STA DSCCB+TRADD+3
 LDA MAPTMP
 STA MPMBPT
 LDA MAPTMP+1
 STA MPMBPT+1
 LDAIM :LSB:MBENTS
 STA MPTMPB
 LDAIM :MSB:MBENTS
 STA MPTMPB+1
 BRA #10

20 TAX
 PLA
 PLA
 PLA
 PLA
 TXA
 RTS

30 LDAIM DCERRC
 RTS

40 LDYIM 0
 LDAIY MPSCPT
 STA MAPTMP
 INY
 LDAIY MPSCPT
 STA MAPTMP+1
 INY
 LDAIY MPSCPT
 STA MAPTMP+2
 INY
 LDAIY MPSCPT
 STA MPTMPD
 INY
 LDAIY MPSCPT
 STA MPTMPD+1
 LDAIM 0
 RTS


;MOVEON: SET NXT SECTOR
;FUNCTION:- NBLKS -:=1
;DCSTAD +:= BLKSZE
;MAPTMP := NXT SECTOR NUMBER
;MPSCPT := PTR TO NXT MAP ENTRY

;EXIT: A = 0  => CARRY ON
;A = 1  => NO MORE BLOCKS TO TX
;A > 1 => ERROR

MOVEON ROUT
 SEC
 LDA NBLKS
 SBC MPTMPD
 STA NBLKS
 LDA NBLKS+1
 SBC MPTMPD+1
 STA NBLKS+1
 ORA NBLKS
 BNE #10
 INCA ;RC:=1 if no more blocks
 RTS

10 CLC;INCREMENT STORE ADDRESS
 LDA DCSTAD+1
 ADC MPTMPD
 STA DCSTAD+1
 BCC #20
 LDAIM DCERRB ;STORE ADDR GONE ILLEGAL
 JSR INTERR
20 JSR NXTEN ;UPDATE MAPTMP & MPSCPT
 JMP SETSZE


XFER ROUT
 LDAIM 1
 STA DDRSZE+1
 STZ DDRSZE
 BRA #10

XFERIN LDA MPTMPD
 STA DDRSZE+1
 LDA MPTMPD+1
 STA DDRSZE
10 LDA DCSTAD
 STA DDRSTA
 LDA DCSTAD+1
 STA DDRSTA+1
 LDA SAVCOM ;A:=TYPE OF TRANSFER (READ/WRITE)
 JSR TRANS
 BEQ #40 ;is ok, end NMI
 STA DCRASH  ;record fault
40 RTS


;Block read and write
;   On entry::
;      DRIVNO holds the drive number
;      DDRSTA holds the start address
;      RBDA   contains the first sector number
;      DDRSZE holds the number of bytes to transfer
;      A      holds read or write command code

TRANS ROUT
 STA DSCCB+CMD
 LDA DRIVNO
 ASLA
 ASLA
 ASLA
 ASLA
 ASLA
 ORA RBDA+2
 STA DSCCB+CMD+1
 LDA RBDA+1
 STA DSCCB+CMD+2
 LDA RBDA
 STA DSCCB+CMD+3

;test for writing to sector zero

; LDA RBDA
 ORA RBDA+1
 ORA RBDA+2
 BNE #10
 
 LDAIM IERRAK ;writing to sector zero
 JMP INTERR ;***

10 LDA DDRSTA
 STA DSCCB+TRADD ; SAVE THE ADDRESS
 LDA DDRSTA+1
 STA DSCCB+TRADD+1
 LDA DDRSZE+1 ;CHECK FOR END OF TRANSFER
 STA DSCCB+LENGTH+1
 LDA DDRSZE
 STA DSCCB+LENGTH+2
 STZ DSCCB+LENGTH
 STZ DSCCB+LENGTH+3
 STZ DSCCB+CMD+4
 STZ DSCCB+CMD+5 ; FALL INTO DSCCMD ***

;DSCCMD - entered with DSCCB prepared.
; Exit A=0 if Ok else FS error code (converted).

DSCCMD ROUT
 STZ DSCCB ; ZERO CONTROLLER CODE
 LDXIM :LSB:DSCCB
 LDYIM :MSB:DSCCB
 LDAIM &72
 JSR OSWORD
 LDA DSCCB
 BEQ #10 ;Br if ok
 CMPIM &FF ;Disc protected?
 LDAIM DCERRE ;Code if so
 BCS #10
 LDXIM 2 ;**12/7/88** copy disc addr for reports
00 LDAAX DSCCB+CMD+1
 STAAX IEsin
 DEX
 BPL #00
 LDAIM DCERRF ;Other hard disc fault
10 RTS

; Routines to communicate disc parameters to the MOS.
; DEFDEF defines a set of defaults for numbers of sides, number of cyls
;        and number of sectors per track side.
; DEFDSC defines a set of parameters based on those in the current MAPPTR
;        table (but it does not have a side count entry).
; MPDRVE contains the drive number in question.

DEFDEF ROUT
 LDAIM FDside
 LDXIM FDcyls
 LDYIM FDsecs
 BRA #20

DEFDSC LDYIM MPnocy
 LDAIY Mapptr
 TAX
 LDYIM MPspcy
 LDAIY Mapptr
 CMPIM FDsecs+2 ;determine if 1/2 sides
 BCC #10
 LSRA ; sectors per side now
 TAY
 LDAIM 2
 BRA #20

10 TAY ;1-sided sectors per track
 LDAIM 1

20 STA Dsccb+Cmd+1
 STY Dsccb+Cmd+2
 STX Dsccb+Cmd+3
 STZ Dsccb+Cmd+4
 STZ Dsccb+Cmd+5
 LDA Mpdrve ; get drive code
 LSRA
 RORA
 RORA
 RORA
 TSB Dsccb+Cmd+1
 LDAIM &0D ; Define function code
 STA Dsccb+Cmd
 BRA Dsccmd ; go tell MOS all about disc

; Routine to perform 'test drive' function, 
; used mainly to determine if write protected
; A on entry is the required drive number

Testdv ROUT ;**24/2/88**
 LDXIM Length+3
10 STZAX Dsccb
 DEX
 BPL #10
 LSRA
 RORA
 RORA
 RORA
 STA Dsccb+Cmd+1
 BRA Dsccmd

 LNK UADE15
