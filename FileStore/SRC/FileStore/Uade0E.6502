 OPT UADE0E ;FILE > Uade0E
 TTL File server file UADE0E
;********************************
;* DIRMAN U T I L I T I E S  2  *
;********************************

DETALS ROUT
 CLC ;COPY CRNTEN DETAILS INTO INFPTR
 LDA CRNTEN
 ADCIM DRTITL
 STA MOVFRM
 LDA CRNTEN+1
 ADCIM 0
 STA MOVFRM+1
 LDYIM INFDIS-1 ;COPY LOAD ADDR -> SIN
10 LDAIY MOVFRM
 STAIY INFPTR
 DEY
 BPL #10

;COPY DISC NO & SIZE OF OBJECT INTO DETAILS AREA

 JSR CRNSIN ;OBJSIN := SIN OF CRNTEN
 JMP RETDSZ

;********** MAKDIR RTN **********

;MAKDIR : CREATE A VIRGIN DIR

;ENTRY: DRDISC = DISC NUMBER
;DIRTMP := SIZE OF DIR REQUIRED(APPROX)
;EXRTN := SIN of parent, or zero if none (not coded)

;EXIT: A := RC
;ARGPTR STACK INITIALISED FOR PRESERVE


MAKDIR ROUT
 LDAIM 1 ;MapMan.CreateSpace
 JSR SETDSA ;PUT DISC NO ON NEWARG STACK
 LDYIM ARGD
 LDA DIRTMP
 STAIY NEWARG ;LS(SIZE)
 INY
 LDA DIRTMP+1 ;DIRTMP := SIZE OF NEW DIR
 STAIY NEWARG ;CS(SIZE)
 INY
 LDA DIRTMP+2
 STAIY NEWARG ;MS(SIZE)

 JSR JUSING ;pass pointer to user info **3/10/84**

 JSR MAPMAN ;MAPMAN.CREATE SPACE
 BNE #20

 JSR GETDTE ;Read date & time

;SETUP DETAILS ON ARGPTR STACK FOR RETAIN RTN

 LDYIM ARGD
 LDAIY NEWARG
 STA DIRSIN
 LDYIM ARGQ
 STAIY ARGPTR
 LDYIM ARGE
 LDAIY NEWARG
 STA DIRSIN+1
 LDYIM ARGR
 STAIY ARGPTR
 LDYIM ARGF
 LDAIY NEWARG
 STA DIRSIN+2 ;DIRSIN := SIN OF NEW DIR
 LDYIM ARGS
 STAIY ARGPTR
 JSR DIROBJ ;OBJSIN := SIN OF NEW DIR

 LDYIM ARGF
 LDAIM 0
10 STAIY ARGPTR ;LOAD ADDR:=EXEC ADDR:=0
 INY
 CPYIM ARGN
 BCC #10

 LDAIM TYPDIR+LOCKED
 STAIY ARGPTR ;TYPE & ACCESS INFO
 
 INY
 LDA DATE
 STAIY ARGPTR
 INY
 LDA DATE+1
 STAIY ARGPTR ;DATE CREATED

 JSR LOADDR ;LOAD DIR INTO STORE
 BEQ #30

 CMPIM DRERRB
 BEQ #25 ;Press on here, but relock directory

;IF WE CANNOT LOAD IT THEN CLEAN UP

 PHA ;REMEMBER RC
 JSR ARGOBJ ;OBJSIN:=SIN OF NEWDIR
 JSR DELB ;FREE SPACE ALLOCATED IN DISC MAP
 PLA
20 RTS

;CLEAR DRFRST -> DRENTS

25 JSR INCCNT ;Relock broken directory **25/12/86**

30 LDA DIRSTA
 STA CLRPTR
 STA GENPTR
 LDA DIRSTA+1
 STA CLRPTR+1
 STA GENPTR+1
 LDYIM DRSTAR+DRENSZ ;**23/1/87** zero first entry also
 LDXIM 0
 JSR CLRSTR

;Make dummy unchained first entry for parent ptr **23/1/87**

 LDYIM DRSTAR
 LDAIM &FF
 STAIY GENPTR ;mark entry not chained
 INY
 STAIY GENPTR
 LDYIM DRSTAR+DRSIN
 LDA EXRTN ;copy SIN of parent
 STAIY GENPTR
 INY
 LDA EXRTN+1
 STAIY GENPTR
 INY
 LDA EXRTN+2
 STAIY GENPTR

;NOW FORMAT IT

 CLC
 LDA DIRSTA
 ADCIM DRSTAR+DRENSZ ;**23/1/87**
 STA CRNTEN
 LDA DIRSTA+1
 ADCIM 0
 STA CRNTEN+1 ;CRNTEN PTS TO FIRST ENTRY TO BE MARKED FREE
 JSR FORMAT
 BEQ #40

 JSR DELOBJ ;DELETE THE OBJECT

40 RTS

;FORMAT: RTN TO INCREASE THE NO OF FREE ENTRIES IN A DIR

;ENTRY:OBJSIN = SIN OF DIR
;CRNTEN = PTR TO NEXT POSN TO BE PLACED ON FREE CHAIN
;DIRTMP = SIZE OF DIR (IN BYTES)
;DPTRLD = PTR TO FIRST BYTE OF DIR

;EXIT : A = RC
;N.B. CRNTEN & DIRTMP ARE DESTROYED
;DPTRTR IS UPDATED


FORMAT ROUT
 JSR DECCRN ;CRNTEN -:=DRENSZ

 CLC ;WE WANT TO SUBTRACT ONE AS WELL
 LDA DIRTMP
 SBCIM DRENSZ
 STA DIRTMP
 BCS #05
 DEC DIRTMP+1 ;N.B. WE SUBTRACT ONE FOR THE TRAILING SQ NO

05 CLC
 LDA DIRTMP
 ADC DIRSTA
 STA DIRTMP
 LDA DIRTMP+1
 ADC DIRSTA+1
 STA DIRTMP+1 ;DIRTMP:=DIRSTA+DIRSIZE-DRENSZ-1

10 JSR INCCRN ;CRNTEN +:= DRENSZ

 LDA DIRTMP
 CMP CRNTEN
 LDA DIRTMP+1
 SBC CRNTEN+1
 BCC #20 ;BRANCH IF CRNTEN > DIRTMP

 JSR FREECH ;PLACE CRNTEN ON THE FREE CHAIN
 BRA #10

;NOW SHRINK THE DIR TO AN 'EXACT' SIZE

20 LDAIM 3
 JSR SETDSA ;PLACE DISCNO & OBJSIN ON NEWARG STACK

 LDA CRNTEN
 STA DIRSZE
 STA DPTRTR
 LDA CRNTEN+1
 STA DIRSZE+1 ;DIRSZE := CRNTEN
 STA DPTRTR+1 ;DPTRTR := PTR TO LAST BYTE OF DIR (SQ.NO.)
 INC DIRSZE ;ADD ON 1 FOR TRAILING SQ. NO.
 BNE #30
 INC DIRSZE+1 ;DIRSZE := CRNTEN + 1
30 SEC
 LDA DIRSZE
 SBC DIRSTA
 STA DIRSZE
 LDYIM ARGG
 STAIY NEWARG ;LS(SIZE)
 LDA DIRSZE+1
 SBC DIRSTA+1
 STA DIRSZE+1 ;DIRSZE := CRNTEN + 1 - DIRSTA
 INY
 STAIY NEWARG ;CS(SIZE)
 INY
 LDAIM 0
 STAIY NEWARG

 JSR JUSINF ;** 3/10/84 **

 JSR MAPMAN ;MAPMAN.CHANGESIZE
 BNE #40

;NOW INSERT TRAILING SQ. NO. AND THEN

 LDYIM DRSQNO
 LDAIY DPTRLD
 STAI DPTRTR ;SET TRAILING SQ. NO. = LEADING SQ. NO.

;NOTE FORMAT DOES NOT ENSURE THE DIR OR THE MAP.
;SO WE MARK THE DIR DIRTY IN CASE IT GETS REMOVED FROM THE CACHE.

 LDA DPTRLD
 STA GENPTR
 LDA DPTRLD+1
 STA GENPTR+1
 JSR MRKDRT ;MARK IT DIRTY

 LDAIM 0 ;RC := 0

40 RTS

JUSING LDYIM ARGB ;21/12/84
 LDAIY ARGPTR ;passed in original call
 TAX
 INY
 LDAIY ARGPTR

 LDYIM ARGH
 STAIY NEWARG
 DEY
 TXA
 STAIY NEWARG
 RTS

DECCRN ROUT
 SEC ;CRNTEN -:= DRENSZ
 LDA CRNTEN
 SBCIM DRENSZ
 STA CRNTEN
 BCS #10
 DEC CRNTEN+1
10 RTS



;********* EXAMINE UTILS ********


;ALL INFO IN MACHINE READABLE FORM
;AND FILE TITLE.

;ON ENTRY, INFPTR POINTS TO RESULT
;AREA. ON EXIT, INFPTR POINTS TO
;BYTE AFTER RESULT.

EXRTNA ROUT
 JSR MOVEFT ;10 BYTE FILE TITLE

 LDYIM DRLOAD

;MOVE ALL OTHER INFO FROM DIR. TO
;RESULT AREA.

05 LDAIY CRNTEN
 STAI INFPTR
 JSR INCIPT
 INY
 CPYIM DRENSZ
 BNE #05
 JSR CRNSIN ;GET SIN OF CURRENT ENTRY
 JSR SINSZE ;GET SIZE ON STACK
 BNE #20
 LDYIM ARGB ;COPY SIZE -> INFO AREA
10 LDAIY NEWARG
 STAI INFPTR
 JSR INCIPT
 INY
 CPYIM ARGE
 BNE #10
 LDAIM 0 ;Successful exit
20 RTS


;ALL INFORMATION, FORMATTED IN CHAR. STRING

EXRTNB ROUT
 JSR OUTENT ;Output entry details
 BNE #10

ERTNBZ LDAIM ENTTRM ;Terminate string
 JSR OUTCH
 LDAIM 0
10 RTS


OUTENT ROUT
 JSR MOVEFT ;Print file title
 JSR OUTSP
 JSR OUTLEX
 JSR OUTSZE
 BNE #10 ;Map error
OUTEN2 JSR OUTACC
 LDXIM 4
 JSR OUTSPS
 JSR OUTDAT
 JSR OUTSIN
 LDAIM 0 ;Successful exit
10 RTS


;FILE TITLE + TITLE LENGTH, M/C READABLE

EXRTNC ROUT
 LDAIM NAMLNT
 STAI INFPTR ;File title length
 JSR INCIPT
 JSR MOVEFT ;Note pointer to locn. after f.t.
 LDAIM 0
 RTS ;Successful exit



;FILE TITLE + ACCESS IN CHAR FORM

EXRTND ROUT
 JSR MOVEFT
 JSR OUTSP
 JSR OUTACC
 BRA ERTNBZ


;*** MINOR UTILITIES ***


;MOVE FILE TITLE FROM DIRECTORY TO
;!INFPTR. ON EXIT, INFPTR POINTS TO
;BYTE AFTER FILE TITLE.

MOVEFT ROUT
 LDYIM DRTITL
10 LDAIY CRNTEN
 STAI INFPTR
 INY
 JSR INCIPT
 CPYIM DRTITL+NAMLNT
 BCC #10
 RTS

;v1.23
OUTZRO LDXIM  8
 LDAIM "0" ;Used to put out root load/exec addresses
OUTZLP JSR OUTCH
 DEX
 BNE OUTZLP
 RTS


OUTSPS JSR OUTSP
 DEX
 BNE OUTSPS
 RTS



;OUTPUT A SPACE AND INCREMENT INFPTR.

OUTSP LDAIM SPACE
OUTCH STAI INFPTR
 JMP INCIPT ;INCREMENT POINTER


;FOUR BYTES IN REVERSE ORDER IN HEX
;FROM CURRENT DIR. ENTRY

;Y POINTS TO CURRENT ENTRY DATA.

OUTHEX INY
 INY
 INY
 STZ FILLFL ;Set space fill ON
 LDAIY CRNTEN
 JSR OUTBYT ;TOP DIGIT
 DEY
 LDAIY CRNTEN
 JSR OUTBYT
 DEY
 LDAIY CRNTEN
 JSR OUTBYT ;TWO DIGITS
 DEY
 LDAIY CRNTEN ;Fall into OUTBYT


;OUTPUT TOP OF A IN HEX

OUTBYT ROUT
 PHA
 LSRA
 LSRA
 LSRA
 LSRA
 JSR OUTDIG

 PLA
OUTDIG ANDIM &F
 BNE #10 ;Non-zero, don't worry about fill
 BIT FILLFL
 BPL #10 ;Switch -ev => fill space
 LDAIM SPACE
 BRA OUTCH ;Space and exit

10 STZ FILLFL ;Printing a digit, so switch leading 0's off
 CMPIM &A
 BCC #20
 ADCIM 6
20 ADCIM &30
 BRA OUTCH


;THREE BYTE SIN IN HEX

OUTSIN LDYIM DRSIN+2
 STZ FILLFL

 LDAIY CRNTEN
 JSR OUTBYT
 DEY
 LDAIY CRNTEN
 JSR OUTBYT
 DEY
 STZ FILLFL ;Switch leading spaces off
 LDAIY CRNTEN
 BRA OUTBYT


;OUTPUT DATE TO INFPTR IN DD/MM/YY FORMAT

OUTDAT ROUT
 LDYIM DRDATE
 LDAIY CRNTEN

;v1.23
 STA TDATE
 INY
 LDAIY CRNTEN
 STA TDATE + 1

OUTRTD

;ENTRY POINT FOR PRINTING ROOT DATE, SET IN
;TDATE DURING INITDV

 LDA TDATE
 JSR OUTDEC

 LDAIM ":"
 JSR OUTCH

 LDA TDATE + 1
 PHA
 ANDIM &F
 JSR OUTDEC ;MONTH
 LDAIM ":"
 JSR OUTCH

 PLA
 LSRA
 LSRA
 LSRA
 LSRA
 CLC

;ADD TO GET BASEYR

 ADCIM BASEYR
 JSR OUTDEC
 JMP OUTSP
 
 
;v1.31
;
; PHA ;**24/2/88**
; ANDIM &1F ;**24/2/88** Isolate day of month
; JSR OUTDEC
;
; LDAIM ":"
; JSR OUTCH
;
; PLA ;**24/2/88**
; ANDIM &E0 ;**24/2/88** Year high order
; STA Fillfl ;**24/2/88**
; LDYIM DRDATE+1
; LDAIY CRNTEN
; PHA
; ANDIM &F
; JSR OUTDEC ;MONTH
; LDAIM ":"
; JSR OUTCH
;
; PLA
; LSRA
; LSRA
; LSRA
; ORA Fillfl ;**24/2/88**
; LSRA
; CLC
;
;;ADD TO GET BASEYR
;
; ADCIM BASEYR
; CMPIM 100 ;**24/2/88** Year 20xx?
; BCC #10
; SBCIM 100
;10 JSR OUTDEC
; JMP OUTSP



;OUTPUT A IN DECIMAL. NOTE A IS
;ASSUMED <100 COZ ROUTINE ONLY
;USED IN WRITING DATE.

OUTDEC ROUT
 LDXIM &FF ;TOP DIGIT IS IN X
 SEC
10 INX
 SBCIM &A
 BCS #10 ;IF >=10, CARRY ON
 ADCIM &A
 PHA
 TXA ;OUTPUT TOP DIGIT
 JSR #20
 PLA
20 
;v1.23
 CLC
 ADCIM "0"

;v1.31
;ORAIM "0" ;CONVERT TO CHAR.

 JMP OUTCH



;OUTPUT ACCESS BYTE AS A PADDED
;CHAR STRING, 7 BYTE LONG. ON
;EXIT, INFPTR POINTS TO BYTE AFTER
;ACCESS STRING.

OUTACC ROUT
 LDYIM DRACCS ;OFFSET IN DIR. ENTRY
 LDAIY CRNTEN
 ASLA ;ONE LEFT SO ACCESS BITS ROTATED INTO B.7

;v1.23
OUTACA

 LDXIM 0
 LDYIM 0

;LOOP ROUND FIRST FOUR ACCESS FIELDS

10 JSR OACCCH
 INX
 CPXIM 4
 BNE #10

 PHA
 LDAIM "/"
 JSR OUTCH
 PLA

 JSR OACCCH ;OWNER ACCESS WRITE
 INX

;FINALLY OWNER ACCESS READ
 JSR OACCCH

;NOW PAD TO THE RIGHT, Y BEING
;NO OF SPACES NEEDED.

20 JSR OUTSP
 DEY
 BNE #20
 RTS

ACCTAB = "DLWRWR"

OACCCH ASLA
 PHA
 BMI #40
 INY ;ACCESS NOT SET, INC SPACE COUNT
 PLA
 RTS

40 LDAAX ACCTAB
 JSR OUTCH
 PLA
 RTS



;GET SIZE FROM MAP AND OUTPUT IN
;HEX (3 BYTES, 5 DIGITS).

OUTSZE ROUT
 JSR CRNSIN ;SET CURRENT SIN TO A VARIABLE

;v1.23
OUTSZA

 JSR SETDSN ;SET DISC NO. + SIN ON STACK
 JSR SINSZE ;GET SIZE FROM MAP
 BNE #20 ;ERROR ... EXIT

 LDYIM ARGD ;TOP BYTE OF SIZE
 STZ FILLFL ;NO leading spaces
 LDAIY NEWARG
 JSR OUTBYT ;TOP DIGIT

 DEY
 LDAIY NEWARG
 JSR OUTBYT

 DEY
 LDAIY NEWARG
 JSR OUTBYT
 LDXIM 3
 JSR OUTSPS
 LDAIM 0 ;SUCCESSFUL EXIT

20 RTS



INCIPT ROUT
 INC INFPTR
 BNE #10
 INC INFPTR+1
10 RTS




;CHECK THAT THE NUMBER OF ENTRIES
;ASKED FOR OF A CERTAIN TYPE OF
;EXAMINE IS LESS THAN MAX. NO.

ENTTAB = MAXENA
 = MAXENB
 = MAXENC
 = MAXEND

CHKENS ROUT ;CHKENS
 LDX EXARG
 CPXIM 4
 BEQ #10 ;Asking for dir.name only, exit, C clear
 CMPIM 0 ;**1/5/87** If zero, set to max
 BEQ #05
 CMPAX ENTTAB
 RTS

05 LDAAX Enttab ;**1/5/87** load max for exam type
10 CLC
 RTS

 LNK UADE0EA
