 OPT UADE03 ;FILE > Uade03
 TTL File server file UADE03

;**********************************
;*        U T I L I T I E S       *
;**********************************

START JMP STRTFS ; .. here we go ..

CACORN = "(C)Acorn 1987"

;I N P U T - O U T O U T  R O U T I N E S

;Returns CC if digit or char.

ISDCHA ROUT
 PHA
 CMPIM "0"
 BCC #10 ;Fail
 CMPIM "9"+1
 BCC #20 ;Succeed
 PLA ;Now check if is char

;Returns CC if is alpha (upper or lower)

ISCHAR PHA
 ANDIM &DF
 CMPIM "A"
 BCC #10 ;=> char < A
 CMPIM "Z"+1
 BCC #20 ;=> char <= Z
10 SEC
20 PLA
 RTS


;E R R O R  H A N D L I N G

INTERR ROUT
 PHY
 PHX
 PHA
 LDXIM IEaddr ;Log out into RTC chip for persistence
10 PLA
 STAAX Cozero-IEaddr ;for PEEK debugging
 JSR OSwrad ;Write next byte off stack
 INX
 CPXIM IEaddr+5
 BCC #10 ;Copy A, X, Y, JSR address

;v1.31
;15 LDAAX IEsin-IEaddr-5 ;write last SIN
; JSR OSwrad
; INX
; CPXIM IEaddr+8
; BCC #15
;
; LDAIM 0 ;**29/4/88** temporary?  deprotect store
; JSR Doprot ;**29/4/88** to allow for taking dumps

 LDXIM 0 ;start flashing led
 PHX ;save marker to check door opened
20 LDAIM 137
 PHX
 JSR OSbyte ;invert led
 LDAIM 128 ;read door switch
 LDXIM 0
 JSR OSbyte
 PLX
 PLY
 ANDIM 2
 BNE #40 ;br if door open now
 TYA ;door ever opened?
 BNE #50
25 PHY ;save door opened latch
 TXA
 EORIM 1 ;invert led
 TAX
 TAY ;spin loop, A=Y=0 or 1
30 PHA ;1.5us
 PLA ;2us
 INCA  ;1us
 BNE #30 ;1us = 5.5us inner loop
 INY ;1us
 BPL #30 ;1us = 700us outer loop
 BRA #20 ;180ms half flash cycle

40 TAY ;set Y non-zero to say door was open
 BRA #25 

50 LDXIM &FF ;Reset stack ptr - delayed for debugging
 TXS
 
; v1.31
; LDX RXTAB ;**29/4/88** cancel any pending RX CBs
; BEQ #60
; LDAIM &34
; JSR OSBYTE

60 LDAIM 0 ;Indicate start in user mode required
 JMP Strtf1 ;then start all over again



USRERR * INTERR ;For now - what better?

;OSrdad, OSwrad read and write a byte in the alternate non-volatile memory
;Entry: X=address to read/write; A=data if write
;Exit:  A=read data if read. written data if write. X preserved, Y not.

OSrdad ROUT
 LDAIM 5 ;code for read
 BRA #10

OSwrad STA OSwork+4 ;save data
 LDAIM 6
10 STX OSwork
 STZ OSwork+1
 STZ OSwork+2
 STZ OSwork+3
 PHX
 LDXIM :LSB:OSwork
 LDYIM :MSB:OSwork
 JSR OSword
 PLX
 LDA OSwork+4
 RTS


;COMPAR: COMPARE TWO AREAS OF STORE,
;BYTE-BY-BYTE.

;ENTRY: MOVFRM = PTR TO 1ST AREA
;MOVTO  = PTR TO 2ND AREA
;X      = NO. OF BYTES TO BE COMPARED

;EXIT: A = 0 IF IDENTICAL
;<>0 IF NOT IDENTICAL
;N.B. STATE BITS (Z ETC) ARE ALSO SET.
;NOTE X,Y,A ARE DESTROYED.


COMPAR ROUT
 TXA
 TAY
10 DEY
 LDAIY MOVFRM
 CMPIY MOVTO
 BNE #20
 DEX
 BNE #10
20 TXA
 RTS


;F R E E  S P A C E  M A N A G E M E N T


;SPACE IS ALLOCATED FROM A
;CONTIGUOUS AREA OF MEMORY. N.B.
;THAT SPACE CANNOT BE RETURNED TO
;THE FREE POOL.


;GETVEC: RETURNS A POINTER TO A FREE
;AREA OF MEMORY.
;THE PAGE ZERO POINTER,
;FREPTR POINTS TO THE BEGINNING
;OF FREE SPACE.


;ENTRY: Y,X = SIZE (Y=LS)
;EXIT: Y,X = PTR TO VECTOR

;FUNCTION:-

;IF FREPTR+SIZE > ENDPTR
;THEN ERROR(INSUFFICENT SPACE)
;ELSE FREPTR +:=:= SIZE
;FI

GETVEC ROUT
 TXA  ;FIRST CHECK THAT SIZE REQUESTED <> 0
 BNE #10
 TYA
 BNE #10
 LDAIM IERRAF ;SIZE = 0
00 JSR INTERR
10 CLC
 TYA 
 ADC FREPTR
 STA GVWRKA ;GETVEC WORK VARIABLE A
 TXA
 ADC FREPTR+1
 STA GVWRKA+1
 BCC #20
 LDAIM IERRAD ;X,Y TOO BIG!
 BRA #00
20 LDA ENDPTR ;IS GVWRKA > ENDPTR
 CMP GVWRKA
 LDA ENDPTR+1
 SBC GVWRKA+1
 BCS #30
 LDAIM IERRAE ;INSUFFICIENT SPACE
 BRA #00
30 LDY FREPTR
 LDX FREPTR+1
 LDA GVWRKA
 STA FREPTR
 LDA GVWRKA+1
 STA FREPTR+1
 RTS


;CLRSTR: CLEARS A SPECIFIED STORE AREA TO ZERO.

;ENTRY:- CLRPTR (PAGE ZERO) = START ADDRESS
;X,Y = NUMBER OF BYTES (Y=LS)
;NOTE A & TEMPA ARE DESTROYED BY THIS RTN

CLRSTR ROUT
 STZ TEMPA+1
 STY TEMPA
 TYA
 BEQ #20
 LDAIM 0
10 DEY
 STAIY CLRPTR
 BNE #10
20 TXA
 BEQ #30
 CLC
 LDA CLRPTR
 ADC TEMPA
 STA CLRPTR
 LDA CLRPTR+1
 ADC TEMPA+1
 STA CLRPTR+1
 LDYIM 1
 STY TEMPA+1
 DEY ;zero
 TYA
 STY TEMPA
 DEX
 BRA #10

30 RTS


;MOVBLK: MOVE DATA FROM PTR AT X OFFSET BY OFF1, TO
;        PTR AT Y OFFSET BY OFF2. A CONTAINS THE AMOUNT
;        TO MOVE. USEFUL FOR MOVING TO AND FROM THE STACK
;        TO TABLES IN DYNAMIC AREA.
;

MOVBLK ROUT

 PHA  ;Push amount to move
 CLC
 LDAAX 0
 ADC OFF1
 STA MOVFRM ;Set "from" pointer
 LDAAX 0001
 ADCIM 0
 STA MOVFRM+1

 CLC
 LDAAY 0
 ADC OFF2 ;Set "to" pointer
 STA MOVTO
 LDAAY 0001
 ADCIM 0
 STA MOVTO+1

 PLX  ;Set length for MOVE

;And drop into MOVE

;MOVE: MOVE DATA FROM ONE AREA OF MEMORY TO A NEW AREA
;N.B. DATA AREAS SHOULD NOT OVERLAPP!!!!!

;ENTRY: MOVFRM - PAGE ZERO FROM ADDRESS
;MOVTO  - PAGE ZERO TO ADDRESS
;X       - AMOUNT TO BE MOVED

;NOTE THAT A,X,Y ARE DESTROYED BY THIS ROUTINE

MOVE LDYIM 0
 TXA
 BEQ #20 ;If zero to move, exit

10 LDAIY MOVFRM
 STAIY MOVTO
 INY
 DEX
 BNE #10
20 RTS


;MRKDRT: MARK A STORE BUFFER DIRTY

;ENTRY: GENPTR => STORE ADDRESS OF BUFFER

;SAVED: A,X,Y
;DESTROYED: GENPTR


MRKDRT ROUT
 PHA  ;PUSH A
 PHY  ;PUSH Y
 JSR DCGEN ;INITITIALISE GENPTR & Y
 LDAIM DIRTY
 STAIY GENPTR
 PLY  ;PULL Y
 PLA  ;PULL A
 RTS


;MRKCLE: MARK A STORE BUFFER CLEAN

;ENTRY: GENPTR => STORE ADDR OF BUFFER
;SAVED: A,X,Y
;DESTROYED: GENPTR

;MRKCLE PHA  ;PUSH A
;PHY  ;PUSH Y
;JSR DCGEN ;INITIALISE GENPTR & Y:=0
;TYA
;STAIY GENPTR
;PLY  ;PULL Y
;PLA  ;PULL A
;RTS


DCGEN ROUT
 LDA GENPTR
 BNE #10
 DEC GENPTR+1
10 DEC GENPTR
 LDYIM 0
 RTS



;I N T E R  M O D U L E  C O M M U N I C A T I O N


;ARGUMENTS ARE PASSED AROUND ON
;A SOFTWARE STACK. WHEN IN A
;MODULE ARGUMENTS SETUP BY THE
;CALLER (AND THOSE TO BE PASSED
;BACK) ARE POINTED TO BY THE
;PAGE ZERO REGISTER, ARGPTR.
;PARAMETERS FOR THE NEXT MODULE
;TO BE CALLED ARE POINTED TO BY
;THE PAGE ZERO REGISTER, NEWARG.
;THE POSN OF NEWARG RELATIVE TO
;ARGPTR IS SET BY THE SETFS ROUTINE.
;SETFS MUST BE CALLED
;BEFORE A MODULE IS CALLED.


;SETFS: SET FRAME SIZE. THIS RTN
;SETS UP THE CORRECT VALUE
;OF THE PAGE ZERO POINTER,
;NEWARG.
;ON ENTRY A = NUMBER OF ARGUMENT
;STACK POSNS TO BE SET ASIDE.
;IT ALSO PLACES ZERO IN THE REMEMBER ENTRY REASON SLOT.


;FUNCTION:-

;NEWARG  := ARGPTR+A+FINFO
;[NEWARG] := A+FINFO
;[NEWARG+ENTRES] := 0


SETFS ROUT
 CLC
 ADCIM FINFO ;A:=FINFO+A
 BCC #10
 LDAIM IERRAA ;FRAME SIZE TOO BIG
 JSR INTERR ;INTERNAL ERROR
10 PHA  ;PUSH A
 ADC ARGPTR ;A:=A+LS(ARGPTR)
 STA NEWARG ;LS(NEWARG) := A
 LDA ARGPTR+1 ;A:=MS(ARGPTR)
 ADCIM 0
 STA NEWARG+1 ;MS(NEWARG):=A
 PLA  ;PULL ACCUMULATOR
 LDYIM FRAMSZ ;Y:=POSN OF FRAME SIZE INFO
 STAIY NEWARG ;[NEWARG] :=A
 LDYIM ENTRES ;Y:= POSN OF ENTRY REASON TO BE REMEMBERED
 LDAIM 0
 STAIY NEWARG ;ENTRY REASON := 0 AT THE MOMENT
 RTS



;ENTRY: THIS RTN MUST BE CALLED ON
;EVERY ENTRY TO A MODULE. IT
;CHECKS THAT THE ENTRY CODE
;0 < (ARG0) >= A.  IT ALSO PLACES
;THE NAME OF THE CALLED MODULE
;AND THE VALUE OF ARGA (THE ENTRY REASON)
;ON THE ARGUMENT STACK (THIS IS USEFUL WHEN DEBUGGING).

;ON ENTRY:-

;X = NUMB OF MODULE ENTRY POINTS
;A= NUMBER OF MODULE

;FUNCTION:-

;ARGPTR := NEWARG
;X := JUMP TABLE OFFSET
;NEWARG := $FFFF (SHOULD BE SET BY SETFS RTN)


ENTRY ROUT
 LDYIM MODNME
 STAIY NEWARG ;PUSH NAME OF CALLED MODULE ON ARG STACK
 TXA  ;A:= NUMBER OF EXPECTED ENTRY POINTS
 LDYIM ARGA ;Y:=ARGA
 CMPIY NEWARG
 BPL #10
 LDAIM IERRAC ;UNKNOWN ENTRY REASON
00 JSR INTERR
10 LDAIY NEWARG ;A:=[NEWARG+ARGA]
 BNE #20
 LDAIM IERRAB ;FUNCTION CODE = 0
 BRA #00

;NOW MAKE ARGPTR := NEWARG

20 LDA NEWARG ;A:= LS(NEWARG)
 STA ARGPTR ;LS(ARGPTR):=A
 LDA NEWARG+1 ;A:=MS(NEWARG)
 STA ARGPTR+1 ;MS(ARGPTR):=A
;NOW WORKOUT JUMP TABLE OFFSET
 LDAIY ARGPTR
 LDYIM ENTRES
 STAIY ARGPTR ;COPY OF ARGA (THE ENTRY REASON)
 STA ENWRKA ;ENWRKA:=[ARGPTR+ARGA]
 DEC ENWRKA ;ENWRKA -:= 1
 ASL ENWRKA ;ENWRKA *:= 2
 LDX ENWRKA ;X := JUMP TABLE OFFSET
 LDAIM &FF
 STA NEWARG
 STA NEWARG+1 ;NEWARG := $FFFF
 RTS



;EXIT: THIS RTN SHOULD BE
;CALLED BY EVERY MODULE, JUST
;BEFORE IT RETURNS TO ITS CALLER.

;FUNCTION:-

;NEWARG := ARGPTR
;ARGPTR := ARGPTR-[ARGPTR]
;A := [NEWARG+ARGA]
;Y := ARGA

PREXIT LDYIM ARGA ; Common return sequence
 STAIY ARGPTR ; Falls into EXIT

EXIT ROUT
 LDYIM FRAMSZ ;Y:=POSN OF FRAME SIZE INFO
 LDA ARGPTR ;A:=LS(ARGPTR)
 STA NEWARG ;LS(NEWARG):=A
 LDA ARGPTR+1
 STA NEWARG+1 ;NOW NEWARG=ARGPTR
 SEC
 LDA ARGPTR ;A:=LS(ARGPTR)
 SBCIY ARGPTR ;A:=A-SIZE OF PREVIOUS STACK FRAME
 STA ARGPTR ;LS(ARGPTR):=A
 BCS #10
 DEC ARGPTR+1 ;MS(ARGPTR)-:=1
10 LDYIM ARGA ;Y:=ARGA
 LDAIY NEWARG ;A:=[NEWARG+ARGA] I.E. RETURN CODE
 RTS



;A R I T H M E T I C  R O U T I N E S


MULTBS ROUT
 LDXIM 8 ;BREGA *:= BLKSZE
10 ASL BREGA
 ROL BREGA+1
 ROL BREGA+2
 DEX
 BNE #10
 RTS


;SETTAB

;ENTRY: X - NO. OF ENTRIES IN TABLE
;Y - SIZE OF EACH ENTRY

;EXIT:  Y -> TABLE (LO)
;X -> TABLE (HI)

;TABLE IS CLEARED TO ZERO AFTER
;GETTING SPACE FROM GETVEC.

SETTAB ROUT
 STZ TEMPA
 STZ TEMPA+1
10 CLC
 TYA
 ADC TEMPA
 STA TEMPA
 BCC #20
 INC TEMPA+1
20 DEX
 BNE #10

 LDY TEMPA
 LDX TEMPA+1
 JSR GETVEC ;*** GET SPACE **
 PHY  ;DONT' TRUST CLRSTR WITH X/Y
 PHX
 STY CLRPTR
 STX CLRPTR+1
 LDY TEMPA
 LDX TEMPA+1
 JSR CLRSTR
 PLX
 PLY
 RTS


GETBB ROUT
 LDAIM 7
 LDYIM ARGA
 STAIY NEWARG
 JSR STRMAN  ;Do get big buffer
 BNE #20

 LDXIM 3
 LDYIM ARGE
10 LDAIY NEWARG
 STAAX BBUF ;Set address and size
 DEY
 DEX
 BPL #10
 CLC
 LDA BBUF
 ADC BBSIZE
 STA BBEND ;Set end address
 LDA BBUF+1
 ADC BBSIZE+1
 STA BBEND+1
 [ Cachesw=Yes
 LDXIM &FF
 STX ODSCMN ;illegal value for big buffer cache
 STX ODSCMN+1
 ]
 LDAIM 0
20 RTS


INCGPT INC GENPTR
 BNE #30
 INC GENPTR+1
30 RTS


MEMTST ROUT ;MEMTST

;First find end of memory. Then test memory
;several times with random numbers and once each
;with %0 and $FF.

 LDAIM 132 ;Top of RAM address
 JSR OSbyte
 DEY ;Leave a page for printer server
 DEY ;And mark last address
 STY Newarg+1
 LDYIM &FF
 STY Newarg

;NOW TEST MEMORY

 LDAIM &44 ;Set "random number"
 STA COZERO
 LDAIM &55
 STA COZERO+1
 STA COZERO+2
 STZ ARGPTR ;Use ARGPTR as an error flag
 LDXIM 3
30 JSR RMTSTA ;Random number test
 DEX
 BNE #30
 LDAIM 0
 JSR RMTSTB
 LDAIM &FF
 JSR RMTSTB

 LDA NEWARG
 STA MEMEND
 LDA NEWARG+1
 STA MEMEND+1
 LDA ARGPTR ;Error flag
 RTS


RMTSTA ROUT ;RMTSTA

;Test from FREPTR to NEWARG using pseudo rand. nos.
;in COZERO +00/01/02

 LDAIM :LSB:FRESTR
 STA GENPTR
 LDAIM :MSB:FRESTR
 STA GENPTR+1

10 LDA COZERO
 STA COZERO+3 ;Store for checking pass
 LDA COZERO+1
 STA COZERO+4
 LDA COZERO+2
 STA COZERO+5
 LDYIM 0
20 LDA COZERO
 STAIY GENPTR
 JSR RANDUM
 INY
 BNE #20

;Reset rand. no. and check page.

 LDA COZERO+3
 STA COZERO
 LDA COZERO+4
 STA COZERO+1
 LDA COZERO+5
 STA COZERO+2
30 LDA COZERO
 CMPIY GENPTR
 BEQ #40 ;OK, continue
 JSR MEMERR
40 JSR RANDUM
 INY
 BNE #30

;Finished testing one page, do next one.

 INC GENPTR+1
 LDA NEWARG+1
 CMP GENPTR+1
 BCS #10 ;G/ptr >= NEWARG, continue.
 RTS


RMTSTB ROUT ;RMTSTB

;Test memory using value in A.

 STA COZERO
 LDAIM :LSB:FRESTR
 STA GENPTR
 LDAIM :MSB:FRESTR
 STA GENPTR+1
10 LDYIM 0
 LDA COZERO
20 STAIY GENPTR
 INY
 BNE #20 ;Fill a page
30 LDAIY GENPTR
 CMP COZERO
 BEQ #40 ;OK, continue
 JSR MEMERR
40 INY
 BNE #30

 INC GENPTR+1
 LDA NEWARG+1
 CMP GENPTR+1
 BCS #10
 RTS


RANDUM ROUT ;RANDUM

;Generate next random number

 LDA COZERO
 EORIM 2
 LSRA
 LSRA
 ROR COZERO
 ROR COZERO+1
 ROR COZERO+2
 RTS



MEMERR ROUT ;MEMERR

 LDAIM &FB ; indicate memory error
 JMP INTERR ; have to stop system


;pass userinfo pointer to CHANGESIZE

JUSINF ROUT
 LDYIM ARGB
 LDAIY ARGPTR
 TAX
 INY
 LDAIY ARGPTR

 LDYIM ARGK
 STAIY NEWARG
 DEY
 TXA
 STAIY NEWARG
 RTS ;** 3/10/84 **

 LNK UADE04
