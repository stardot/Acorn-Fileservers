 OPT UADE10 ;> Uade10A
 TTL File server file UADE10A

;MPCHSZ: CHANGE THE SIZE OF A CHAIN ON DISC

;ENTRY:
;ARGB-C DISC NO
;ARGD-F SIN
;ARGG-I NEW SIZE IN BYTES
;ARGJ-K Ptr to user info

;EXIT:  ARGA = RC

;FUNCTION: MAPTB IS SCANNED TO FIND THE RELEVANT ENTRY. IF NECESSARY
;THE SECTOR MAP IS READ INTO STORE. THE CURRENT SIZE IS DISCOVERED AND IT
;IS DECIDED WHETHER IT IS AN INCREASE OR A DECREASE IN SIZE.
;THE RELEVANT NUMBER OF BLOCKS ARE THEN ALLOCATED/DEALLOCATED.


MPCHSZ ROUT
 JSR FNDMAP ;find map entry, set MPDRVE  ** 16/1/86 **
 BNE #10
 LDYIM ARGJ
 JSR MPFRAD ;get size of chain
 BNE #10 ;catch errors

 LDXIM :LSB:-3
 LDYIM ARGG
 SEC
05 LDAAX MPNWFR-:LSB:-3
 SBCIY ARGPTR
 STAAX MPNWFR-:LSB:-3
 INY
 INX
 BNE #05 ;calculate new size required

 LDA MPNWFR+3
 SBCIM 0
 STA MPNWFR+3

 LDAIM MPERRN
 BCC #10 ;exit 'cos there's no room
 BRA #08       

MPCHSJ JSR FNDMAP
 BNE #10
08 STZ ERRTYP ;NO ERRORS
 STZ DNDLTE
 STZ MPTMPB
 STZ MPTMPB+1
 STZ MPTMPB+2
 STZ SAVSC ;FIRST BLOCK FLAGGED
 JSR MPsetd ;**8/5/87** MPTMPA->ARGD
 LDAIY ARGPTR ;GET LENGTH IN BYTES
 STA DIVPAR
 INY
 LDAIY ARGPTR
 STA DIVPAR+1
 INY
 LDAIY ARGPTR
 STA DIVPAR+2
 CLC
 JSR RDMPBK ;READ IN RELEVANT MAP BLOCK
 LDA ERRTYP
 BEQ #13
 LDAIM MPERRC
10 JMP MPCHEN ;REPORT DISC ERROR

13 JSR DVDE ;DIVIDE BYTES TO GET BLOCKS
 BCC #16
 LDAIM MPERRB
 BRA #10

16 LDA DIVTMP ;DECREMENT SINCE NO MAP BLOCK REQUIRED
 BNE #18
 LDA DIVTMP+1
 BNE #17
 DEC DIVTMP+2
17 DEC DIVTMP+1
18 DEC DIVTMP

 STZ MPTMPB
 STZ MPTMPB+1
 STZ MPTMPB+2

19 LDA MAPTMP ;ADDRESS OF MAP BLOCK
 STA MPMBPT
 LDA MAPTMP+1
 STA MPMBPT+1
 CLC
 LDA MPMBPT ;GET TO POINT AT ENTRIES
 ADCIM :LSB:MBENTS
 STA MPMBPT
 LDA MPMBPT+1
 ADCIM :MSB:MBENTS
 STA MPMBPT+1
20 LDYIM 0
 LDAIY MPMBPT ;CHECK IF NEXT POINTER IS ZERO
 INY
 ORAIY MPMBPT
 INY
 ORAIY MPMBPT
 BEQ #30
 CLC
 LDA MAPTMP
 ADCIM :LSB:LSTENT
 TAX
 LDA MAPTMP+1
 ADCIM :MSB:LSTENT
 CPX MPMBPT
 BNE #26
 CMP MPMBPT+1
 BNE #26
 LDYIM 0 ;YES, SO THIS POINTER IS SIN OF MAP BLOCK
 LDAIY MPMBPT
 STA MPTMPA ;PREPARE TO READ NEW MAP BLOCK
 INY
 LDAIY MPMBPT
 STA MPTMPA+1
 INY
 LDAIY MPMBPT
 STA MPTMPA+2
 CLC
 JSR RDMPBK ;READ IN NEW MAP BLOCK
 BRA #19 ;**8/5/87**

26 CLC ; KEEP ADDING UP NUMBER OF BLOCKS
 LDYIM 3
 LDAIY MPMBPT
 ADC MPTMPB
 STA MPTMPB
 INY
 LDAIY MPMBPT
 ADC MPTMPB+1
 STA MPTMPB+1
 BCC #28
 INC MPTMPB+2
28 LDA MPTMPB
 CMP DIVTMP ;CHECK IF ENOUGH BLOCKS FOUND
 LDA MPTMPB+1
 SBC DIVTMP+1
 LDA MPTMPB+2
 SBC DIVTMP+2
 BCS #30 ;BRANCH IF ENOUGH FOUND
 CLC ;HERE IF JUST LOOK AT NEXT ENTRY
 LDA MPMBPT
 ADCIM :LSB:ENSZ
 STA MPMBPT ; LOOK AT NEXT ENTRY
 LDA MPMBPT+1
 ADCIM :MSB:ENSZ
 STA MPMBPT+1
 BRA #20

30 LDA MPTMPB ;NOW SEE ABOUT THE SIZE
 CMP DIVTMP
 LDA MPTMPB+1
 SBC DIVTMP+1
 LDA MPTMPB+2
 SBC DIVTMP+2
 BCS #33 ;BRANCH IF MORE SPACE REQUIRED
 JMP NEEDMR
33 LDA MPTMPB
 CMP DIVTMP
 BNE #36 ;IF THESE ARE NOT THE SAME, ODD BLOCKS MUST BE DISCARDED
 LDA MPTMPB+1
 CMP DIVTMP+1
 BNE #36
 LDA MPTMPB+2
 CMP DIVPAR+2
 BNE #36 ;THEY ARE EQUAL SO NO PART GROUPS TO DEALLOCATE
 JMP #80
36 SEC ;FIND ODD NUMBER FOR DEALLOCATION
 LDA MPTMPB
 SBC DIVTMP
 STA MPTMPB
 LDA MPTMPB+1
 SBC DIVTMP+1
 STA MPTMPB+1
 LDA MPTMPB+2
 SBC DIVTMP+2
 STA MPTMPB+2
 LDYIM 3
 SEC ;GET NUMBER OF THIS GROUP TO DEALLOCATE
 LDAIY MPMBPT
 SBC MPTMPB
 STA MPTMPD
 STAIY MPMBPT
 INY
 LDAIY MPMBPT
 SBC MPTMPB+1
 STA MPTMPD+1
 STAIY MPMBPT
 LDAIM 0
 SEC
 SBC MPTMPB+2
 STA MPTMPD+2
 LDA MAPTMP
 STA CBSTA
 LDA MAPTMP+1
 STA CBSTA+1
 JSR MMBWT
 LDYIM 0
 CLC ; FIND DISC ADDRESS FOR DEALLOCATION
 LDAIY MPMBPT
 ADC MPTMPD
 STA MPTMPE
 INY
 LDAIY MPMBPT
 ADC MPTMPD+1
 STA MPTMPE+1
 INY
 LDAIY MPMBPT
 ADC MPTMPD+2
 STA MPTMPE+2
 INY
 LDAIY MPMBPT
 INY
 ORAIY MPMBPT
 BNE #40
 LDYIM 0
 TYA
 STAIY MPMBPT
 INY
 STAIY MPMBPT
 INY
 STAIY MPMBPT
40 ;FIND CYLINDER NUMBER
 STZ MPTMPC ;ZERO CYLINDER COUNT
 STZ MPTMPC+1
43 SEC
 LDYIM MPSPCY
 LDA MPTMPE
 SBCIY MAPPTR
 STA MPTMPE
 INY
 LDA MPTMPE+1
 SBCIY MAPPTR
 STA MPTMPE+1
 LDA MPTMPE+2
 SBCIM 0
 STA MPTMPE+2
 BCC #46 ; FOUND IF GONE NEGATIVE
 INC MPTMPC
 BNE #43
 INC MPTMPC+1
 BRA #43

46 JSR RDBTMP ;READ THE RELEVANT BIT MAP
 BEQ #47
 JMP MPCHEN ;**23/2/87** failed, attempt recovery

47 JSR MBMLKD
 LDYIM MPSPCY
 CLC
 LDA MPTMPE
 ADCIY MAPPTR
 STA MPTMPD
 INY
 LDA MPTMPE+1
 ADCIY MAPPTR
 STA MPTMPD+1
 LDYIM 0
50 LDA MPTMPD+1
 BNE #53 ; CANNOT OF GOT TO THE RIGHT PLACE IF THIS NON-ZERO
 LDA MPTMPD
 CMPIM 8 ;CHECK FOR LESS THAN EIGHT
 BCC #56 ;IF LESS GO AND FIND ACTUAL BIT
53 INY
 SEC
 LDA MPTMPD ; KEEP DECREMENTING
 SBCIM 8
 STA MPTMPD
 BCS #50
 DEC MPTMPD+1
 BRA #50

56 LDA MPTMPB
 PHA ; SAVE THIS COUNT
 LDA MPTMPB+1
 PHA
 LDXIM 9 ; X TRACKS POSITION IN CURRENT BYTE
 LDAIY MPSCPT ; GET THE BYTE
60 RORA ; KEEP ROTATING FOR POSITION
 DEX
 DEC MPTMPD
 BPL #60
63 SEC ;MARK BLOCK FREE
 RORA
 PHP ; SAVE THESE VALUES
 PHA
 DEX
 BEQ #70 ; CHECK FOR END OF THIS BYTE
66 LDA MPTMPB ;CHECK IF ALL BLOCKS HAVE BEEN FREED
 BNE #67
 DEC MPTMPB+1
67 DECA
 STA MPTMPB
 ORA MPTMPB+1
 BEQ #73 ; ZERO WHEN ALL DEALLOCATED
 PLA
 PLP ;GET VALUES BACK
 BRA #63 ;JUMP BACK TO FREE NEXT

70 STAIY MPSCPT ;SAVE THIS VALUE
 LDXIM 8 ;SET UP FOR WHOLE BYTE
 INY ;POINT TO NEXT ENTRY IN BIT MAP
 PLA
 PLP ;JUST TO GET RID OF THEM
 LDAIY MPSCPT ; GET NEW BYTE
 RORA ;SET UP FOR FREEING BLOCKS
 PHP
 PHA
 BRA #66

73 PLA
 PLP ;CLEAR VALUES ON STACK
76 RORA
 DEX
 BNE #76
 STAIY MPSCPT ; AND SAVE HIS VALUE
 PLA ; RETRIEVE BLOCK COUNT
 STA MPTMPB+1
 PLA
 STA MPTMPB
 JSR ADDFR ; ADD FREED BLOCKS TO BLOCK COUNT
 LDA MPscor ;**23/1/87**
 STA CBSTA
 LDA MPscor+1
 STA CBSTA+1
 JSR MBMWT
80 LDYIM ENSZ ; NOW REST OF ENTRIES CAN BE DEALLOCATED
 LDAIY MPMBPT ;CHECK FOR LAST ENTRY
 INY
 ORAIY MPMBPT
 INY
 ORAIY MPMBPT
 BEQ #90 ;IF NONE LEFT WE'VE FINSHED
 SEC
 LDA MPMBPT ; RETRIEVE ADDRESS OF MAP BLOCK
 SBC MAPTMP ; AND GET OFFSET
 STA MPSCPT
 LDA MPMBPT+1
 SBC MAPTMP+1
 STA MPSCPT+1
 CLC ;NOW POINT AT NEXT ENTRY
 LDA MPSCPT
 ADCIM :LSB:ENSZ
 STA MPSCPT
 LDA MPSCPT+1
 ADCIM :MSB:ENSZ
 STA MPSCPT+1
 STZ MPTMPE ;don't delete this map block
 JSR CLRBLK
90 JSR ULBM
 JSR ENSMB
 JSR ENSBM
 LDA ERRTYP
 BEQ #95
 LDAIM MPERRC
 JMP MPCHEN

95 JMP CSEND ;FINISH REDUCTION
;
; SIZE TO BE INCREASED
;
NEEDMR ROUT
 SEC ;GET THE POINTER
 LDA MPMBPT
 SBC MAPTMP
 STA SAVPTA ;SAVE THE OFFSET IN THE MAP BLOCK IN CASE IT NEEDS TO BE RESTORED
 LDA MPMBPT+1
 SBC MAPTMP+1
 STA SAVPTA+1
 LDA MPTMPA ;SAVE THE SIN OF THE MAP BLOCK
 STA SAVPTB
 LDA MPTMPA+1
 STA SAVPTB+1
 LDA MPTMPA+2
 STA SAVPTB+2
 SEC ;DISCOVER HOW MUCH NEEDS TO BE ALLOCATED
 LDA DIVTMP
 SBC MPTMPB
 STA DIVTMP
 LDA DIVTMP+1
 SBC MPTMPB+1
 STA DIVTMP+1
 LDA DIVTMP+2
 SBC MPTMPB+2
 STA DIVTMP+2
 LDYIM MPCYMP ;GET ADDRESS OF CYLINDER MAP
 LDAIY MAPPTR
 STA MAPGEN
 INY
 LDAIY MAPPTR
 STA MAPGEN+1
 SEC
 LDYIM 0 ; CHECK IF THERE IS ENOUGH SPACE
 LDAIY MAPGEN
 SBC DIVTMP
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 SBC DIVTMP+1
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 SBC DIVTMP+2
 STAIY MAPGEN
 BCS #10
 JMP #50 ; BRANCH IF THERE IS NO ROOM
10 LDA SAVPTA
 CMPIM MBENTS
 BNE #20
 LDA SAVPTA+1
 BEQ #30 ; EMPTY MAP BLOCK SO ALLOCATE FROM SIN
20 SEC
 LDA MPMBPT

;v1.23
 SBCIM ENSZ
 STA MPMBPT
 LDA MPMBPT + 1
 SBCIM /(ENSZ )
 STA MPMBPT + 1
 LDYIM  0 ; GET A CURRENT DISC ADDRESS
 LDAIY MPMBPT
 STA MPTMPA
 INY
 LDAIY MPMBPT
 STA MPTMPA + 1
 INY
 LDAIY MPMBPT
 STA MPTMPA + 2
 CLC
 LDA MPMBPT
 ADCIM ENSZ
 STA MPMBPT
 LDA MPMBPT + 1
 ADCIM /(ENSZ )
 STA MPMBPT + 1
 
;v1.31
; PHA
; SBCIM :LSB:ENSZ
; STA MPMBPT
; LDA MPMBPT+1
; PHA
; SBCIM :MSB:ENSZ
; STA MPMBPT+1
; LDYIM 0 ; GET A CURRENT DISC ADDRESS
; LDAIY MPMBPT
; STA MPTMPA
; INY
; LDAIY MPMBPT
; STA MPTMPA+1
; INY
; LDAIY MPMBPT
; STA MPTMPA+2
; PLA
; STA MPMBPT+1 ;**1/7/88** restore pointer
; PLA
; STA MPMBPT
 
30 JSR DIVSEC ; FIND CYLINDER FROM SIN
 LDA MPTMPB ;GET CYLINDER TO SOMEWHERE USEFUL
 STA MPTMPC
 LDA MPTMPB+1
 STA MPTMPC+1
 JSR GTCYPS ; FIND A CLOSE CYLINDER WITH FREE BLOCKS
 LDA MPTMPE
 STA MPTMPC
 LDA MPTMPE+1
 STA MPTMPC+1
 JSR RDBTMP
 BNE #55 ;**23/2/87** Failed, attempt to report error
 LDA MAPGEN
 STA MPCYPT ; READY TO ALLOCATE BLOCKS
 LDA MAPGEN+1
 STA MPCYPT+1
 JSR ABLKS ; ALLOCATE ONE LOT OF BLOCKS
 BCS #40 ; BRANCH IF FAILED
 LDA DIVTMP
 ORA DIVTMP+1
 ORA DIVTMP+2
 BEQ CSEND ; CHECK IF FINISHED
 JSR FLBLKS ; FILL IN THE REST OF THE BLOCKS
 BCS #40 ; BRANCH IF ALL WENT WELL
 JSR ENSBM
 BRA CSEND

40 LDA SAVPTB ; IT FAILED SO DEALLOCATE ANY BLOCKS STILL ALLOCATED
 STA MPTMPA ; GET SIN BACK
 LDA SAVPTB+1
 STA MPTMPA+1
 LDA SAVPTB+2
 STA MPTMPA+2
 LDA SAVPTA ; GET OFFSET BACK
 STA MPSCPT
 LDA SAVPTA+1
 STA MPSCPT+1
 STZ MPTMPE ; LEAVE CURRENT MAP BLOCK ALONE
 JSR CLRBLK ; TIDY UP
50 CLC
 LDYIM 0
 LDAIY MAPGEN
 ADC DIVTMP
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADC DIVTMP+1
 STAIY MAPGEN
 INY
 LDAIY MAPGEN
 ADC DIVTMP+2
 STAIY MAPGEN
 LDA ERRTYP
 BEQ #60
 LDAIM MPERRC
55 BRA MPCHEN

60 LDAIM MPERRB ; FLAG NO ROOM
 BRA MPCHEN

CSEND JSR RDmpbd ;**8/5/87** Read block at ARGD
 LDA MAPTMP
 STA MPMBPT
 STA CBSTA
 LDA MAPTMP+1
 STA MPMBPT+1
 STA CBSTA+1
 LDYIM BILB ; POSITION OF ODD BYTES
 LDA DIVPAR ; BYTES FROM DIVISION
 STAIY MPMBPT
 INY
 LDA DIVPAR+1
 STAIY MPMBPT
 JSR MMBWT
 JSR ENSMB
 JSR ENSBM
 LDAIM 0 ; INDICATE SUCCESS

MPCHEN BNE #80
 LDYIM ARGA
 LDAIY ARGPTR
 EORIM 14 ;detect special case
 BEQ #80
 LDYIM ARGJ
 LDAIM 0
 JSR MPSETF
80 JMP MPEXIT

;MPREST:
;FUNCTION: LOADS THE MAP TABLE FROM DISC.
;CHECKS THAT ALL MAPS ARE O.K. ALSO
;SETS UP TABLE FOR FREE STORE MANAGEMENT

MPREST ROUT
 STZ ERRTYP
 
;v1.23
 STZ MAPTMP
 STZ MAPTMP+1
 STZ MPTMPA
 STZ MPTMPA+1
 STZ MPTMPB

 LDX DRIVES ;FOR LOOP
 LDYIM MPTBSZ
 JSR SETTAB ;SET MAP TABLE AND CLEAR STORE
 STY MAPTB
 STY MAPPTR
 STX MAPTB+1
 STX MAPPTR+1

 LDXIM NTSIZE
 LDYIM NTENSZ
 JSR SETTAB ;SET NAME TABLE
 STY NAMETB
 STX NAMETB+1

 STY DNMPTR
 STX DNMPTR+1
 LDXIM NTSIZE
 LDAIM UNUSED
 LDYIM NTUSED

;MARK ALL NAME TABLE ENTRIES UNUSED

10 STAIY DNMPTR
 PHA
 JSR INAMPT
 PLA
 DEX
 BNE #10

 LDXIM 1
 STX NXTDNO
 STZ NXTDNO+1 ;SET DISC ALLOCATION NO.
 JSR INBKMN

 STZ MPDRVE
;v1.23
 STZ LDRNB
20 LDA MPDRVE
 STA DRIVNO
 LDA FREPTR

;v1.31
;20 LDA FREPTR

 STA MPSCPT ;GENERAL PTR. TO SEC. ZERO DATA
 LDA FREPTR+1
 STA MPSCPT+1

;v1.23
 LDA DRIVNO ;CURRENT DRIV NUMBER

;v1.31
; LDA MPDRVE
; STA DRIVNO

 JSR RDDATA ;GET INFO FROM DISC
 BNE #50 ;Ignore if disc error ** 14/06/86 **
 JSR CHKDSC ;CHECK IS FS DISC
 BNE #50 ;NOPE, ISN'T

;NOW SET MAP TABLE ENTRY FOR THIS DRIVE

 JSR SMAPEN

 JSR CHDNAM ;PUT IN NAME TABLE
 BEQ #30
25 LDAIM 0 ;Couldn't (duplicate disc name??)
 LDYIM Mpnocy
 STAIY Mapptr ;... so mark map entry unused
 INY
 STAIY Mapptr ;by saying it has no cylinders
 
 
;v1.23 
 BRA #50 ; ** 14/10/86 **
;NOW CREATE CYCLINDER MAP FOR THIS DISC'S MAP

30 JSR Defdsc ;Define disc parameters to MOS
 BNE #25 ; back off map entry if failed

 JSR MPMPSZ ;GET SIZE OF MAP
 JSR DIVSEC ; GET NO. OF TRACKS
 LDYIM MPNOCY 
 CLC
 LDA MPTMPB ;CALCULATE SIZE OF CY.MAP
 STAIY MAPPTR ; SAVE NO. OF TRACKS
 INY
 ROL MPTMPB
; STA MPTMPB ; MULTIPLY TRACKS BY TWO
 LDA MPTMPB+ 1
 STAIY MAPPTR
 ROL MPTMPB+ 1

 CLC ;NOW INCREASE SIZE TO HOLD FREE SPACE COUNT
 LDA MPTMPB
 ADCIM 3
 TAY
 LDA MPTMPB+1
 ADCIM 0
 TAX
 JSR GETVEC ;get space for cylinder map
 TYA ; SAVE ADDRESS OF CY.MAP
 LDYIM MPCYMP
 STAIY MAPPTR
 INY
 TXA
 STAIY MAPPTR
 JSR MPSTCY
 LDYIM MPADFT
 CLC
50 INC MPDRVE ; ** 14/06/86 ** drives contiguously numbered
 JSR MPADMP
 INC LDRNB
 LDA LDRNB
 
;v1.31
; BNE #50 ; ** 14/10/86 **

;NOW CREATE CYCLINDER MAP FOR THIS DISC'S MAP
;30 JSR MPRESZ ;**5/3/88** get number of cylinders
; CLC ;NOW INCREASE SIZE TO HOLD FREE SPACE COUNT
; LDA MPTMPB
; ADCIM 3
; TAY
; LDA MPTMPB+1
; ADCIM 0
; TAX
; JSR GETVEC ;get space for cylinder map
; TYA ; SAVE ADDRESS OF CY.MAP
; LDYIM MPCYMP
; STAIY MAPPTR
; INY
; TXA
; STAIY MAPPTR
; JSR MPSTCY
;50 JSR MPADMP
; INC MPDRVE ; ** 14/06/86 ** drives contiguously numbered
; LDA MPDRVE

 CMP DRIVES
 BNE #20
 LDAIM 0 ;RC
 JMP MPEXIT

;v1.31
;MPRESZ ROUT ;**5/3/88*** calculate number of cylinders
; JSR MPMPSZ ;total number of sectors 
; STZ MPTMPB
; STZ MPTMPB+1
; LDYIM MPDSCS
; LDAIY MAPPTR
; TAX
;10 LDYIM MPNOCY
; CLC
; LDAIY MAPPTR
; ADC MPTMPB
; STA MPTMPB
; INY
; LDAIY MAPPTR
; ADC MPTMPB+1
; STA MPTMPB+1
; DEX
; BNE #10
; STAIY MAPPTR ;restore total count
; DEY
; LDA MPTMPB
; STAIY MAPPTR
; CLC
; ROL MPTMPB ;multiply cyls by two   
; ROL MPTMPB+1
; RTS

;MPSZIN: RETURNS THE LENGTH OF A CHAIN IN BYTES AND BLOCKS

;ENTRY:
;ARGB-C DISC NO
;ARGD-F SIN

;EXIT:
;ARGA = RC
;ARGB-D SIZE IN BYTES
;ARGE-F SIZE IN BLOCKS

;FUNCTION: GETS THE RELEVANT ENTRY IN MAPTB. CHECKS THAT
;THE SIN POINTS TO THE START OF A CHAIN. RETURNS THE LENGTH OF THE CHAIN.

MPSZIN ROUT
 JSR FNDMAP ;GET MAP TO MAPPTR
 BNE #20
 JSR RDmpbd ;**8/5/87** Read block at ARGD
 BEQ #10
 LDAIM MPERRC ;ERROR RETURN OF NOT START
 BRA #20 ;AND RETURN

10 LDA MAPTMP
 STA MPMBPT
 LDA MAPTMP+1
 STA MPMBPT+1
 JSR MPGTSZ ;GET SIZE OF MAP
 LDYIM ARGB
 LDA MPTMPA ;SIZE IS IN MPTMPA
 STAIY ARGPTR
 INY
 LDA MPTMPA+1
 STAIY ARGPTR
 INY
 LDA MPTMPA+2
 STAIY ARGPTR
 LDYIM ARGE
 LDA MPTMPD
 STAIY ARGPTR ;SAVE NUMBER OF BLOCKS
 INY
 LDA MPTMPD+1
 STAIY ARGPTR
 LDAIM 0 ;RC
20 JMP MPEXIT

;MPSNRT: RETURNS THE SIN OF THE ROOT DIRECTORY
;ENTRY:
;ARGB-C DISC NO

;EXIT:
;ARGA = RC
;ARGB-D SIN OF ROOT DIRECTORY
;ARGE-F DATE ROOT CREATED


MPSNRT ROUT
 JSR FNDMAP
 BNE #30
 LDYIM MPRTSN
10 LDAIY MAPPTR
 PHA
 INY
 CPYIM MPRTSN+5
 BNE #10

 LDYIM ARGF
20 PLA
 STAIY ARGPTR
 DEY
 CPYIM ARGA
 BNE #20

 LDAIM 0
30 JMP MPEXIT

 LNK UADE11
